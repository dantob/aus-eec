
// Disassembly of Ford A9L EEC-IV ROM software from ~1993 Mustang
//
AD Channels:
	0 - TAR
	1 - VCAL
	2 - KEYWR
	3 - OCC
	4 - SCCS
	5 - EGO2
	6 - MAF
	7 - TP
	8 - ECT
	9 - ACT
	A - NDS
	B - EGO1
	C - EVP

HSI:
	0 - PIP
	1 - KNK
	2 - BP
	3 - STI
	4 - not used
	5 - CID
	6 - VSS
	7 - IDM

HSO:
	0 - INJ3
	1 - INJ4
	2 - INJ6
	3 - INJ7
	4 - INJ5
	5 - ???	SPOUT?
	6 - INJ1
	7 - INJ2
	8 - INJ8

LSO:
	7 - FP
	6 - CPU/OK
	5 - MIL
	4 - SCVNT
	3 - ISC
	2 - EVR
	1 - DOL
	0 - SCVAC

BIDI:
	7 - ???
	6 - FAN HI
	5 - FAN
	4 - AM2
	3 - AM1
	2 - SHIFT_LIGHT
	1 - CANP
	0 - ???

Tag Address listing from reverse engineering demo GUI programs:
	$786B word checksum_base_address (set to zero to clear error code 15)
	$97B0 word WOT_Voltage (WOT breakpoint (TPS voltage - 1))
	$9A92 word open_loop_tp_Voltage (throttle position to force open loop (TPS voltage - 1))
	$9434 word part_throttle_spark_adder ( part throttle spark adder (Deg BTDC))
	$943A word wot_spark_adder ( Deg BTDC)
	$9462 byte tip_in_retard ( max tip in spark retard (Deg BTDC))
	$9456 word low_dwell ( max low speed dwell( off time in ms ))
	$9458 word high_dwell ( max high speed dwell ( off time in ms))

	$9504 Table - wot_advance_vs_RPM (WOT spark advance vs RPM)
	$9532 Table - wot_advance_vs_ect
	$9540 Table - wot_advance_vs_act 
	$94EE Table - pt_advance_vs_act
	$9528 Table - wot_advance_vs_bp (Hg , Degrees)
	$979C Table - advance_rate_vs_RPM
	$9761 Table - min_low_speed_dwell
	$9749 Table - min_high_speed_dwell
	$9574 Table - base_spark_table ( load vs RPM)(Deg BTDC)
	$95C4 Table - sea_level_lom_spark_table
	$9614 Table - altitude_lom_spark_table (load vs RPM)
	$8CDE Table - spark_table_RPM_scaling 
	$8CFA Table - spark_table_load_scaling
	
	$97BA word  - open_loop_fuel_multiplier (global)

	$901A word  - engine_displacement ( one unit = 0.0430981 Cubic Inches)

	$8F68 word  - maf_voltage - max

	$8DE3 Table - maf_function (mass air transfer function (volts, Kg per hr)
	$935A Table - ISC_during_crank (isc duty cycle during crank, keyed off ect at start (ect, duty cycle)
	$9BF0 Table - base_fuel_table (A/F ratio - load vs ECT)
	$9C40 Table - startup_fuel_table ( subtract corresponding cell values from base fuel table for startup/warmup enrichment)
	$8D17 Table - fuel_table_load_scaling 
	$8CD2 Table - fuel_table_ect_scaling
	$9B81 Table - wot_throttle_multiplier_vs_rpm
	$9DE9 Table - open_loop_fuel_multiplier_vs_rpm
	$982B Table - sea_level_lugging_open_loop_multiplier (vs rpm)
	$9847 Table - altitude_lugging_open_loop_fuel_multiplier (vs rpm)
	$9B48 Table - open_loop_fuel_multiplier_vs_act
	$9863 Table - crank_fuel_pulsewidth_multiplier_vs_time
	$987B Table - crank_fuel_pulsewidth_vs_ect
	$9002 word  - global_accel_multiplier (global accel pump multiplier)
	$91C1 Table - accel_enrichment_vs_TPS ( accelerator enrichment vs TP voltage)
	$91CB Table - accel_enrichment_fuel_table (lbs/min)
	$922D Table - injector_breakpoint_vs_battery_voltage ( voltage, lbs/rev)

	$901C word  - low_injector_slope ( one unit = 0.00171662 lbs/hr)
	$901E word  - high_injector_slope ( one unit = 0.00171662 lbs/hr)

	$8FFE word  - inj_delay
	$9160 Table - injector_timing_table (global injector delay in crank degrees)
	$91B9 Table - injector_firing_order
	$9B30 Table - injector_offset_vs_battery_voltage
	$91B1 Table - injector_output_port

	$9414 byte  - fan_temp ( coolant temp for electric fan in deg F)
	$941C byte  - fan_enable 
	$941D byte  - hedfhp hs electro-drive fan enable
	$941E byte  - ect1_hs_fan_on
	$941F byte  - ect2_hs_fan_on
	$9432 word  - closed_throttle_spark_adder
	$9B54 Table - closed_throttle_open_loop_fuel_multiplier
	$904C word  - drive_idle (rpm in drive)
	$9049 word  - neutral_idle (rpm in neutral)
	$BAB6 word  - max_rpm_closed_throttle_idle
	$B048 ????  - neutral_idle_open_loop_delay (time in seconds under closed loop control before going open loop)
	$9390 Table - desired_idle_airflow_in_drive (Kg/Hr)
	$939C Table - desired_idle_airflow_in_neutral
	$9346 Table - dashpot_clip (maximum dashpot airflow by rpm in Kg/Hr)
	$932A Table - dashpot_decrement_rate (dashpot decrement step at given flow(Kg/Hr(flow),Kg/Hr(Step))

	$8C16 word  - PIP limit (minimum pip period (pip = 6250000/max rpm) for A9L 6.25M/$03C1 = 6504 RPM 
	$9A94 word  - no_fuel_rpm (max rpm - no fuel)
	$9A9A word  - min_load_for_closed_loop 
	$9AA0 byte  - time_at_high_load_before_open_loop (time at high load to force Open loop(seconds))
	$9AC3 byte  - min_ect_for_fuel_shutoff (min ect for decel fuel shutoff Deg F)
	$9AC8 word  - min_rpm_for_fuel_shutoff
	$9AE4 byte  - min_act_for_adaptive_control
	$9AE5 byte  - max_act_for_adaptive_control
	$97CD byte  - egr_multiplier
	$97D9 byte  - egr_type ( 0=sonic, 1=PFE, 2=none)
	$9E65 byte  - thermactor_present

	$9D88 Table - exhaust_pulse_delay
	$9E70 byte  - number_of_hegos
	$9DA8 Table - hego_amplitude 
	$9DC8 Table - hego_bias
	$8CB2 Table - emission_table_load_scaling
	$9B10 Table - emission_table_rpm_scaling

PWM tables

; hang debug: 2D4,2EA,312,2E0,308, *hangs*



	$02C5 -  
	$02C6 -
	$02C7 - 
	$02C8 - 1ST ENTRY PTR IN DISPLAY - SPOUT
	
	$02CB - +5

	$02CE - 50[REG_74]
	$02D0 - 52[REG_74]
		2D1 - time hi 8 FROM L27EB (cylinder offset 0)
		2D2 - time lo 16 FROM L27EB

	$02D4 - (offset $0F) cylinder 1 HSO 6
		2D4 - byte - offset into 2C5 for ???
		2D6 - byte - offset into 2284 table???
		2D7 - HSO execution time for channel 
		2D8 - HSO execution time for channel 
		2D9 - HSO execution time for channel 
	$02D9 - (offset $14) +5
		2D9 - byte - offset link
		2DA - byte - offset into 2284 table - 5C[REG_74]
		2DB
		2DC
		2DD - time hi 8 FROM L27EB (cylinder offset 1)
		2DE - time lo 16 FROM L27EB
		2DE - ???
				32F3 treats this as lsb of 24bit time!!!
				27FE store ~PIP time in here
				249B - 6 Runs to hang
		2DF

	$02E0 - (offset $1B) cylinder 2 HSO 7

	$02E5 - +5
		2E7 - time hi 8 FROM L27EB (cylinder offset 2)

	$02EA - (offset $25) cylinder 3 HSO 0

	$02EF - +5
		2F1 - time hi 8 FROM L27EB (cylinder offset 3)

	$02F4 - (offset $2F) cylinder 4 HSO 1

	$02F9 - +5
		2FB - time hi 8 FROM L27EB (cylinder offset 4)

	$02FE - (offset $39) cylinder 5 HSO 4

	$0303 - +5
		305 - time hi 8 FROM L27EB (cylinder offset 5)

	$0308 - (offset $43) cylinder 6 HSO 2
		309 - byte - offset into 2284 table
		30A - word - time lo 16 biys
		30C - byte - time hi 8 bits
	$030D - +5
		30F - time hi 8 FROM L27EB (cylinder offset 6)

	$0312 - (offset $4D) cylinder 7 HSO 3

	$0317 - +5 
		319 - time hi 8 FROM L27EB (cylinder offset 7)

	$031C - (offset $57) cylinder 8 HSO 8

	$0321 - +5??????????????????
??
	$0322 - 9TH - STO/KTS
??

2000                      org   $2000
0000                Zero                              equ   $0000
0002                Low_Speed_Output                  equ   $0002
0003                BiDirect_Port                     equ   $0003
0004                AD_Lo                             equ   $0004
0004                Watchdog_Timer                    equ   $0004
0005                AD_Hi                             equ   $0005
0005                AD_Command                        equ   $0005
0006                Master_IO_Timer_Lo                equ   $0006
0007                Master_IO_Timer_Hi                equ   $0007
0008                Interrupt_Mask                    equ   $0008
0009                Interrupt_Pending                 equ   $0009
000A                IO_Status                         equ   $000A
000B                HSI_Sample                        equ   $000B
000C                HSI_Data_Mask                     equ   $000C
000D                HSI_Data_Hold                     equ   $000D
000E                HSI_Time_Hold                     equ   $000E
0010                Stack_Ptr                         equ   $0010
2000                Reset_Addr

2000  FF                  nop
2001  FA                  di
2002  2145                sjmp  L2149

2004                      word  $0000   ; FIXSUM usually zero
2006                      word  $DFFF
2008                      word  $FF00
200A                      word  $ECDE	; ROM_TO calibration version

200C                SMP_Base_Addr
200C  00A0                word  $A000
200E                Calib_Exec_Time
200E  5D00                word  $005D	; I/O times between console executions referenced @ $84C2
                    ;************************************************************
                    ;*  Interrupt Vectors
                    ;************************************************************
2010                Int_Vec
2010  5127                word  $2751                       ; HSO Port Output Interrupt #2
2012  3D27                word  $273D                       ; Master I/O Timer Overflow Interrupt
2014  5027                word  $2750                       ; reti - A/D End of Conversion Interrupt
2016  5027                word  $2750                       ; reti - HSI Port Input Data Available(we poll for input)
2018  5027                word  $2750                       ; reti - External Interrupt Vector
201A  B925                word  $25B9                       ; HSO Port Output Interrupt #1
201C  5027                word  $2750                       ; reti - HSI #1 Interrupt Vector
201E  2B27                word  $272B                       ; HSI #0 Interrupt Vector

2020                Num_levels
2020  08                  byte  $08
2021                Num_Calibs
2021  01                  byte  $01

2022                Calibration_ptrs
2022  008C                word  $8C00	- 00F0
2024  5A8E                word  $8E5A	- 00F2
2026  D68F                word  $8FD6	- 00F4
2028  A893                word  $93A8	- 00F6
202A  3094                word  $9430	- 00F8
202C  A897                word  $97A8	- 00FA
202E  7E9A                word  $9A7E	- 00FC
2030  5A9E                word  $9E5A	- 00FE

                    ;************************************************************
                    ;*  Reset Subroutine
                    ;*
                    ;*    input-  REG$2A   bit 5 =  ???
                    ;*                     bit 6 =  ???
                    ;*           - call from reset -> $2A = 00
                    ;*           - call at L8451   -> $2A = ??
                    ;************************************************************
2032  FA            L2032 di
2033  FF                  nop
2034  110C                clrb  HSI_Data_Mask		; no HSI interrupts wanted for now
                    ;* Save  REG$2A
2036  B02A12              ldb   REG_12,REG_2A		; save VIP_mode_flag  in low reg
2039  A1160014            ld    REG_14,#$0016 		; Clear locations from  $0016  through  $0489
203D  C61500        L203D stb   Zero,[REG_14]+
2040  1705                incb  Watchdog_Timer
2042  898A0414            cmp   REG_14,#$048A
2046  D3F5                jnc   L203D
                    ;* if byte $2A at entry has both bits 5 and 6 off,
                    ;*  then set bit 0  in  $EF
2048  51601214            andb  REG_14,REG_12,#$60
204C  D705                jne   L2053
204E  9101EF              orb   REG_EF,#$01
2051  2003                sjmp  L2056
2053  C42A12        L2053 stb   REG_12,REG_2A		; restore VIP_mode_flag
2056  0112          L2056 clr   REG_12
                    ;* load  $72, $74, $76  with parameters for this EPROM
2058  A1800172            ld    REG_72,#$0180		; RAM based tables
205C  A17E0274            ld    REG_74,#$027E
2060  A17A0376            ld    REG_76,#$037A
                    ;****
                    ;* init various locations in memory, use tables starting at $862a
                    ;* see description of their format there
                    ;****
2064  A12A8614            ld    REG_14,#$862A
                    ;* outer loop - setup to process an init table
2068  89FFFF14      L2068 cmp   REG_14,#$FFFF
206C  DF20                je    L208E
206E  A2151A              ld    REG_1A,[REG_14]+	    ; start address
2071  A21516              ld    REG_16,[REG_14]+	    ; end address
                    ;* inner loop - process an init table
                    ; initialize selected RAM locations to ROM preset values (saved in compressed form)
2074  881614        L2074 cmp   REG_14,REG_16           ;in this EPROM go until $8650 (1st table)
2077  DB0E                jc    L2087					; jmp if c=1
2079  B2151A              ldb   REG_1A,[REG_14]+        ;get lo-byte of addr to init
207C  B21A1C              ldb   REG_1C,[REG_1A]         ;get current contents
207F  92151C              orb   REG_1C,[REG_14]+        ;OR byte from table at $862a (1st table)
2082  C61A1C              stb   REG_1C,[REG_1A]         ;put byte back
2085  27ED                sjmp  L2074					; loop next byte in entry

2087  D9A9          L2087 jh    L2032                   ;(jmp if c=1&z=0)Error -  if  REG_14 != REG_16 then reset again (odd addr)
2089  A21614              ld    REG_14,[REG_16]         ;get addr of next table ?
208C  27DA                sjmp  L2068					; next init table entry

                    ;* init table processing done
208E  911024        L208E orb   REG_24,#$10             ; start flag = 'use $1000-$1FFF engineering console'
2091  EF1E64              lcall L84B2                   ; Init console if found - copy calibraion pointers to RAM
2094  EF0C65              lcall L85A3                   ; KAM : verify or int table 1 at 0702-07AF
2097  EF5B65              lcall L85F5                   ; KAM : validate or clr table 2 at 7E4-7EA (7EC is sum)
                    ;***** ----
209A  A374DE42            ld    REG_42,$DE[REG_74]	    ; engine load (VE)
209E  C3749E42            st    REG_42,$9E[REG_74]      ; $57+2C5 = 9E[REG_74]

20A2  45E201F042          add   REG_42,REG_F0,#$01E2    ; $8DE2 MAF transfer function TABLE (volts to Kg/Hr?)
20A7  C376B442            st    REG_42,$B4[REG_76]	    ; MAF transfer function table pointer

20AB  A3F00242            ld    REG_42,$02[REG_F0]	    ; ROM $8C02
20AF  C3728042            st    REG_42,$80[REG_72]	    ; TP? $0100 

20B3  B3FC53B3            ldb   REG_B3,$53[REG_FC]      ; ROM $9AD1
                    ;* if  ???   then set  bit 6 in $E6
20B7  B3FA3142            ldb   REG_42,$31[REG_FA]      ; ROM $97D9 EGR_Type contents = 00 - egr_type ( 0=sonic, 1=PFE, 2=none)
20BB  304203              jbc   REG_42,BIT_00,L20C1
20BE  9140E6              orb   REG_E6,#$40				; Switch to select EGR strategy: 1 = PFE; (0 = Sonic)

20C1  A1DBB642      L20C1 ld    REG_42,#$B6DB
                    ;* if  ???   then
20C5  B3FE0730            ldb   REG_30,$07[REG_FE]      ; ROM $9E61 number of engine cylinders per revolution
20C9  3B3004              jbs   REG_30,BIT_03,L20D0		; 8 cylinders???
20CC  A155D542            ld    REG_42,#$D555
20D0  C376C042      L20D0 st    REG_42,$C0[REG_76]

                    ;* if  ???   then
20D4  A301EE0730          ld    REG_30,$07EE[Zero]		; filtered EVP saved in KAM 
20D9  8BF3380130          cmp   REG_30,$0138[REG_F2]	; ROM $8F92 limit low
20DE  D107                jnh   L20E7
20E0  8BF33A0130          cmp   REG_30,$013A[REG_F2]	; ROM $8F94 limit high
20E5  D309                jnc   L20F0
20E7  A180A230      L20E7 ld    REG_30,#$A280			; default EVP 
20EB  C301EE0730          st    REG_30,$07EE[Zero]		; filtered EVP saved in KAM 

                    ;* Flush all pending HSI input data
20F0  1109          L20F0 clrb  Interrupt_Pending		; throw away any pending HSI data
20F2  320A06        L20F2 jbc   IO_Status,BIT_02,L20FB	; jmp if NO HSI data ready
20F5  B00D00              ldb   Zero,HSI_Data_Hold		; read data (increments to next avail HSI event)
20F8  FF                  nop							; pause
20F9  27F7                sjmp  L20F2					; loop until all HSI data is cleared
                    ;*
20FB  B00B90        L20FB ldb   REG_90,HSI_Sample
20FE  B1A108              ldb   Interrupt_Mask,#$A1		; 1010 0001 - HSI0, HSO 1, and HSO 2
2101  B1870C              ldb   HSI_Data_Mask,#$87		; 1000 0111 HSI line select
                    ;* if 
2104  9BF84A00            cmpb  Zero,$4A[REG_F8]		; ROM $947A KIHP = 00 ( is there a knock sensor )
2108  D703                jne   L210D
210A  B1850C              ldb   HSI_Data_Mask,#$85		; 1000 0101 - drops line 1
                    ;* if  ???   then
210D  9BFE0C00      L210D cmpb  Zero,$0C[REG_FE]		; ROM $9E66(HP_CID) = 00 ( is there a CID sensor )
2111  DF03                je    L2116
2113  91200C              orb   HSI_Data_Mask,#$20		; 0010 0000 - adds line 5
                    ;* if  ???   then
2116  9BF24700      L2116 cmpb  Zero,$47[REG_F2]		; ROM $8EA1 - VSTYPE (are we tracking vehcle speed) 
211A  DF03                je    L211F
211C  91400C              orb   HSI_Data_Mask,#$40		; 0100 0000 - adds line 6 (BOO?)
                    ;* set up HSO events to tickle console every 5Ms
211F  450300060E    L211F add   HSO_Time_Hold,Master_IO_Timer_Lo,#$0003 ; change output in 3 state times
2124  B12A0D              ldb   HSO_Command_Hold,#$2A		; kick off event - 0010 1010
                    ;* if  ???   then
2127  9BF81A00            cmpb  Zero,$1A[REG_F8]		; ROM address $944A CCDSW = 0 = Calibration Switch to select Computer Controlled Dwell. (1 = Computer Controlled Dwell; 0 = TFI Controlled Dwell)
212B  DF0A                je    L2137					; always jmps in this ROM (TFI controlled DWELL not eec)

212D  A1962292            ld    REG_92,#$2296			; address in data table - SPOUT(channel 5)?
2131  91084C              orb   REG_4C,#$08				; set IMMEDIATE flag = A flag that indicates that the output is to be placed in the  hardware output carousel as soon as possible
2134  EF8602              lcall L23BD					; send HSO command ands lots of other stuff

                    ;* if  ???   then
2137  9BF81900      L2137 cmpb  Zero,$19[REG_F8]		; ROM address $9449 = 0 HP_HIDRES = Hardware present - High Data Rate Electronic Spark - used to time fuel pulses and spark pulse widths
213B  DF0A                je    L2147					; always jmps in this ROM?

213D  A19E2292            ld    REG_92,#$229E			; address in data table - SPOUT(channel 5)?
2141  91084C              orb   REG_4C,#$08				; set IMMEDIATE flag = A flag that indicates that the output is to be placed in the hardware output carousel as soon as possible
2144  EF7602              lcall L23BD					; send HSO command ands lots of other stuff

2147  FB            L2147 ei
2148  F0                  ret
                    ;* End Reset Subroutine
                    ;*
                    ;*
                    ;************************************************************
                    ;* Jump here from RESET
                    ; EEC main loop - cycles thru these routines
                    ; Runs subroutines in table starting at index 0
                    ; REG_9A - is current routine offset
                    ;************************************************************
2149  112A          L2149 clrb  REG_2A				; clear VIP_mode_flag : all bits
214B  A18C0410            ld    Stack_Ptr,#$048C	; set stack pointer
214F  2EE1                scall L2032				;  - sets REG_9A to zero

2151  99A49A        L2151 cmpb  REG_9A,#$A4			; loop termination check
2154  DB1C                jc    L2172				; DEAD - HANG LOOP
2156  AC9A30              ldbze REG_30,REG_9A		; routine #
2159  658A2130            add   REG_30,#$218A		; add to start of subroutine address table
215D  C95121              push  #$2151				; return address L2151
2160  CA30                push  [REG_30]			; subroutine address
;
; These RAM pointers are reset for EVERY function call!!
;
2162  A1800172            ld    REG_72,#$0180		; RAM table pointers 
2166  A17E0274            ld    REG_74,#$027E		; bug? should be $0280 to span RAM addresses
216A  A17A0376            ld    REG_76,#$037A		; bug? should be $0380 to span RAM addresses
216E  75029A              addb  REG_9A,#$02			; increment to next routine address
2171  F0                  ret						; jump to computed routine
 
2172  27FE          L2172 sjmp  L2172               ;***** hang for watchdog - we should never get here
;
;*****************************************************************
; Cycling Routine at 2151, Last routine offset in each of 3 loops
;*  Update loop selection and restart loop
;*****************************************************************
;
2174  3E2A03        L2174 jbs   REG_2A,BIT_06,L217A	; jump if VIP_mode_flag : NO_START set
2177  312A04              jbc   REG_2A,BIT_01,L217E	; jump if VIP_mode_flag:(Vehile Speed Control Self Test?)VSCST clear
217A  B1529A        L217A ldb   REG_9A,#$52			; set routine to Loop B if 'no start' set or VSCST set
217D  F0                  ret

217E  352A04        L217E jbc   REG_2A,BIT_05,L2185	; jump if normal strategy (RUNNING) - not self test mode
2181  B1749A              ldb   REG_9A,#$74			; set routine to Loop C if 'no start' clr and 'running' set and VSCST clr
2184  F0                  ret

2185  B1009A        L2185 ldb   REG_9A,#$00			; set routine to Loop A if 'no start' clr and VSCST clr and 'running' clr
2188  F0                  ret

2189  FF                  byte  $FF
;
; ******* Background Polled subroutine address table - len = $A4 **********************
;
; Loop A - normal operation - no self tests 
;
;      VIP_mode_flag : not NO_START (start)
;	&& VIP_mode_flag : not VSCST(Vehile Speed Control Self Test?)
;	&& VIP_mode_flag : not 'RUNNING self tests' (normal operation)
;
218A  B1                  byte  $B1	; L84B1	- copy calibration ptrs from 2022 to 00F0 and check for console			
218B  84                  byte  $84
218C  5D                  byte  $5D	; L235D - Validate KAM signature and initialize if invalid
218D  23                  byte  $23
218E  52                  byte  $52	; L5852 - Update Dwell
218F  58                  byte  $58
2190  86                  byte  $86	; L3786 - Set RPM Flags
2191  37                  byte  $37
2192  2E                  byte  $2E	; L222E - read A-D channels to Table
2193  22                  byte  $22
2194  4E                  byte  $4E	; L384E - reads raw AD values and updates values
2195  38                  byte  $38
2196  F3                  byte  $F3	; L37F3 - Update WOT flag
2197  37                  byte  $37
2198  F4                  byte  $F4	; L4EF4 - 
2199  4E                  byte  $4E
219A  5A                  byte  $5A	; L3D5A - Update heated windshield flag
219B  3D                  byte  $3D
219C  E4                  byte  $E4	; L3CE4 - Update (MPH) vehicle speed values
219D  3C                  byte  $3C
219E  AC                  byte  $AC	; L3DAC - 14 ; Update RPM?
219F  3D                  byte  $3D
21A0  DD                  byte  $DD	; L63DD - 15 ; Update A/C cutout and idle slowdown flag
21A1  63                  byte  $63
21A2  D4                  byte  $D4	; L65D4 - 18
21A3  65                  byte  $65
21A4  FE                  byte  $FE	; L68FE	- 1A ; Update Timers
21A5  68                  byte  $68
21A6  8F                  byte  $8F	; L848F - 1C
21A7  84                  byte  $84
21A8  CA                  byte  $CA	; L4CCA - 1E ; update fuel comsumption for DOL
21A9  4C                  byte  $4C
21AA  7C                  byte  $7C	; L3E7C - 20
21AB  3E                  byte  $3E
21AC  30                  byte  $30	; L8530 - 22 ; EVP something
21AD  85                  byte  $85
21AE  BA                  byte  $BA	; L40BA - 24 ; Update EGR stuff?
21AF  40                  byte  $40
21B0  41                  byte  $41	; L4141 - 26 ; Check for RPM and Speed limiters
21B1  41                  byte  $41
21B2  A1                  byte  $A1	; L41A1 - 28 ; Update closed loop flags
21B3  41                  byte  $41
21B4  00                  byte  $00	; L4700 - 2A ; Adaptive something
21B5  47                  byte  $47
21B6  D7                  byte  $D7	; L4AD7 - 2C
21B7  4A                  byte  $4A
21B8  EE                  byte  $EE	; L50EE - 2E ; Update fuel pump enable
21B9  50                  byte  $50
21BA  36                  byte  $36	; L5136 - 30 ; EVP something - large function
21BB  51                  byte  $51
21BC  D9                  byte  $D9	; L54D9 - 32 ; EGR stuff
21BD  54                  byte  $54
21BE  C3                  byte  $C3	; L55C3 - 34 ; Update spark advance
21BF  55                  byte  $55
21C0  17                  byte  $17	; L6D17 - 36
21C1  6D                  byte  $6D
21C2  8C                  byte  $8C	; L648C - 38 - update ect cooling fans
21C3  64                  byte  $64
21C4  91                  byte  $91	; L6191 - 3A
21C5  61                  byte  $61
21C6  B5                  byte  $B5	; L62B5 - 3C
21C7  62                  byte  $62
21C8  35                  byte  $35	; L6335 - 3E - Update Canister Purge timing
21C9  63                  byte  $63
21CA  66                  byte  $66	; L6566 - 40
21CB  65                  byte  $65
21CC  B0                  byte  $B0	; L58B0 - 42 - Update idle speed
21CD  58                  byte  $58
21CE  C4                  byte  $C4	; L5EC4 - 44 - SCCS stuff checks VBAT
21CF  5E                  byte  $5E
21D0  7B                  byte  $7B	; L6A7B - 46 - Update shift light
21D1  6A                  byte  $6A
21D2  DD                  byte  $DD	; L6ADD - 48
21D3  6A                  byte  $6A
21D4  A1                  byte  $A1	; L65A1 - 4A - Update Air Management
21D5  65                  byte  $65
21D6  2E                  byte  $2E	; L732E - 4C - Diagnostics
21D7  73                  byte  $73
21D8  49                  byte  $49	; L6E49 - 4E - diagnostic Self Tests
21D9  6E                  byte  $6E

21DA  74                  byte  $74	; L2174 - 50 - loop A (retarts loop)
21DB  21                  byte  $21

;
; Loop B - engine off self tests (and engine on cruise controls self test?)
; On demand EEC-IV self tests engine off
;    NO_START 
; || !(NO_START) && VSCST(Vehile Speed Control Self Test?)
;
21DC  B1                  byte  $B1	; L84B1	- 52 - copy calibration ptrs from 2022 to 00F0 and check for console
21DD  84                  byte  $84
21DE  86                  byte  $86	; L3786 - Set RPM Flags
21DF  37                  byte  $37
21E0  2E                  byte  $2E	; L222E - Read A-D table and save A-D values at table addresses
21E1  22                  byte  $22
21E2  4E                  byte  $4E	; L384E - reads raw AD values and updates values
21E3  38                  byte  $38
21E4  E4                  byte  $E4	; L3CE4 - Update (MPH) vehicle speed values
21E5  3C                  byte  $3C
21E6  AC                  byte  $AC	; L3DAC ; Update RPM
21E7  3D                  byte  $3D
21E8  D4                  byte  $D4	; L65D4
21E9  65                  byte  $65
21EA  FE                  byte  $FE	; L68FE - 60 ; Update Timers
21EB  68                  byte  $68
21EC  8F                  byte  $8F	; L848F
21ED  84                  byte  $84
21EE  BA                  byte  $BA	; L40BA ; Update EGR stuff?
21EF  40                  byte  $40
21F0  D7                  byte  $D7	; L4AD7
21F1  4A                  byte  $4A
21F2  EE                  byte  $EE	; L50EE ; Update fuel pump enable
21F3  50                  byte  $50
21F4  E7                  byte  $E7	; L5EE7 - 6A - Update Vehicle Speed Control(VSC)SCCS
21F5  5E                  byte  $5E
21F6  49                  byte  $49	; L6E49 - 6C - diagnostic Self Tests
21F7  6E                  byte  $6E
21F8  87                  byte  $87	; L5587 - 6E - Update EGR stuff
21F9  55                  byte  $55
21FA  CA                  byte  $CA	; L63CA - 70 - Update Canister Purge
21FB  63                  byte  $63

21FC  74                  byte  $74	; L2174 - 72 - loop B (retarts loop)
21FD  21                  byte  $21

;
; Loop C - engine running self tests
; On demand EEC-IV self tests engine running
;    !NO_START 
; && !VSCST(Vehile Speed Control Self Test?)
; && RUNNING self tests
;
21FE  B1                  byte  $B1	; L84B1	- copy calibration ptrs from 2022 to 00F0 and check for console
21FF  84                  byte  $84
2200  2E                  byte  $2E	; L222E - Read A-D table and save A-D values at table addresses
2201  22                  byte  $22
2202  4E                  byte  $4E	; L384E - reads raw AD values and updates values
2203  38                  byte  $38
2204  F3                  byte  $F3	; L37F3 - 7A - Update WOT flag
2205  37                  byte  $37
2206  E4                  byte  $E4	; L3CE4 - Update (MPH) vehicle speed values
2207  3C                  byte  $3C
2208  52                  byte  $52	; L5852 - Update Dwell
2209  58                  byte  $58
220A  AC                  byte  $AC	; L3DAC - 80 - Update RPM
220B  3D                  byte  $3D
220C  D4                  byte  $D4	; L65D4
220D  65                  byte  $65
220E  FE                  byte  $FE	; L68FE ; Update Timers
220F  68                  byte  $68
2210  8F                  byte  $8F	; L848F
2211  84                  byte  $84
2212  CA                  byte  $CA	; L4CCA ; update fuel comsumption for DOL
2213  4C                  byte  $4C
2214  7C                  byte  $7C	; L3E7C
2215  3E                  byte  $3E
2216  BA                  byte  $BA	; L40BA ; Update EGR stuff?
2217  40                  byte  $40
2218  5B                  byte  $5B	; L4B5B - 8E - NOT IN LOOP 1 or 2
2219  4B                  byte  $4B
221A  F4                  byte  $F4	; L4EF4 - 90 
221B  4E                  byte  $4E
221C  EE                  byte  $EE	; L50EE ; Update fuel pump enable
221D  50                  byte  $50
221E  B0                  byte  $B0	; L58B0 - check idle speed???
221F  58                  byte  $58
2220  C4                  byte  $C4	; L5EC4 - SCCS stuff checks VBAT
2221  5E                  byte  $5E
2222  3F                  byte  $3F	; L823F - 98 - Check HEGO sensors
2223  82                  byte  $82
2224  28                  byte  $28	; L8228 - 9A
2225  82                  byte  $82
2226  49                  byte  $49	; L6E49 - 9C - diagnostic Self Tests
2227  6E                  byte  $6E
2228  87                  byte  $87	; L5587 - 9E - Update EGR stuff
2229  55                  byte  $55
222A  CA                  byte  $CA	; L63CA - Update Canister Purge
222B  63                  byte  $63
222C  74                  byte  $74	; L2174 - loop C (retarts loop)
222D  21                  byte  $21


;
;*****************************************************************
; Cycling Routine at 2151, routine offset 8
;*  Read A-D table and save A-D values at table addresses
;*****************************************************************
;
222E  A15F2230      L222E ld    REG_30,#$225F		; table start address

2232  FB            L2232 ei						; enable interrupts
2233  56300004            addb  AD_Command,Zero,[REG_30] ; select AD channel
2237  DE22                jlt   L225B				; loop exit on neg - no more channels NOTE ei left on
2239  330AFD        L2239 jbc   IO_Status,BIT_03,L2239	; wait for AD to finish
223C  FA                  di						; disable interrupts - why?
223D  FF                  nop
223E  510F0434            andb  REG_34,AD_Lo,#$0F	; mask off channel
2242  9A3034              cmpb  REG_34,[REG_30]		; check correct channel
2245  D7EB                jne   L2232				; if != try read again
2247  51F00434            andb  REG_34,AD_Lo,#$F0	; mask off upper bits
224B  B00535              ldb   REG_35,AD_Hi		; read hi data byte
224E  0730                inc   REG_30				; incr to address
2250  B23132              ldb   REG_32,[REG_30]+	; read address lo
2253  B23133              ldb   REG_33,[REG_30]+	; read address high
2256  C23234              st    REG_34,[REG_32]		; save AD value to address
2259  27D7                sjmp  L2232				; loop

225B  914029        L225B orb   REG_29,#$40
225E  F0                  ret

                    ;************************************************************
                    ;*  A-D table 3 byte entries
                    ;*    byte 1 - is A-D port number
                    ;*    byte 2&3 - is the address to save the 16 bit result to
                    ;************************************************************
225F  00                  byte  $00	; AD Channel 00 saves to $0120
2260  2001                word  $0120	; TAR - Throttle position sensor rate                

2262  01                  byte  $01	; AD Channel 01 saves to $0110
2263  1001                word  $0110	; VCAL Voltage Calibration Level                

2265  02                  byte  $02	; AD Channel 02 saves to $010C
2266  0C01                word  $010C	; KEYPWR - Voltage level (weak battery) *** REFERENCE VOLTAGE ***see $793D               

2268  03                  byte  $03	; AD Channel 03 saves to $010E
2269  0E01                word  $010E	; OCC - Open Circuit Check (voltage level for supply side of actuators)              

226B  04                  byte  $04	; AD Channel 04 saves to $0118
226C  1801                word  $0118	; SCCS speed control system             

226E  05                  byte  $05	; AD Channel 05 saves to $011E
226F  1E01                word  $011E	; Exhaust Gas Oxygen sensor 2            

					; AD Channel 06 is the MAF saved elsewhere to $124

2271  07                  byte  $07	; AD Channel 07 saves to $0122 - *** TP *** see 794D
2272  2201                word  $0122	; Throttle position sensor                

2274  08                  byte  $08	; AD Channel 08 saves to $0112
2275  1201                word  $0112	; ECT Engine Coolant Temperature                

2277  09                  byte  $09	; AD Channel 09 saves to $0114
2278  1401                word  $0114	; ACT air charge temperature                

227A  0A                  byte  $0A	; AD Channel 0A saves to $011A
227B  1A01                word  $011A	; NDS/A3C - auto trans shift position(neutral/drive)NDS            

227D  0B                  byte  $0B	; AD Channel 0B saves to $011C
227E  1C01                word  $011C	; Exhaust Gas Oxygen sensor 1               

2280  0C                  byte  $0C	; AD Channel 0C saves to $0116
2281  1601                word  $0116	; EGR valve position (EVP)              

2283  FF                  byte  $FF	; end of table marker


;*******************************
; PulseWidthModulation tables
;*******************************
;
; subroutine?? table used at $2680 - REG_92
; seems to have data as well
2284  5823                word  $2358
; Table field desciptions
; offset 0 & 1 - routine address for ???
; offset 2 - index for this function in $02C5 table (A)
; offset 3 - HSO command to send ?
; offset 4
; offset 5 - index for this function in $02C5 table (B)
; offset 6 & 7 - routine address for ???
;
; ON  - HSO Command 59 - 0101 1001    : KNOCK THRESHOLD ON rising edge event?
;
2286  F924                word  $24F9 00 59 0B 5D 6D11	: $6D11 is adds (WINDOW_DELTA = Knock window width, clock ticks) time to $02C5 entry 24 bit time REG_80/81/82
;
; OFF _ HSO command C9 - 1100 1001    : KNOCK THRESHOLD OFF falling edge event?
;
228E  0D25                word  $250D 00 C9 0B 5D 6CD8  : $6CD8 is function that conditionally sets new R80/81/82 time based on last PIP time
; 
; ON  - HSO Command 55 - 0101 0101	: SPOUT ON rising edge event?
;
2296  F924                word  $24F9 00 55 0C 03 2C88  : $2C88 adds SPOUT_LOW_TIME to R80/81/82 entry time
; 
; OFF - HSO Command C5 - 1100 0101	: SPOUT OFF falling edge event?	
;
229E  0D25                word  $250D 00 C5 0C 03 2C61	: $2C61 save zero flag in 2C5 entry or add PIP & ?? time to R80/81/82
;
; ???********************* 22 bytes per cylinder entry ? Injector timimg table
; notice that the chnl column is missing channel 5 & 9 in the above table
; Offset 0x03 - HSO command to send
; offset 0x04 - count of ?  up tp 12 and reset to 0 ?
; Offset 0x05 - offset into $02C5 scheduling table
; offset 0x06 - bit mask for setting
; offset 0x07 - bit mask for clearing
; offset 0x08 - injector cylinder number
; offset 0x0A - bit mask
;
;      0 1  2 3  4  5  6 7  8 9  A B
22A6  5A32 0016 0A 0F 01FE 0100 4000    
22B2  7332 0006 0C 0F 01FE 0100     - cylinder 1 : HSO - 6

22BC  5A32 0017 0A 1B 02FD 0200 8000    
22C8  7332 0007 0C 1B 02FD 0200 	- cylinder 2 : HSO - 7

22D2  5A32 0010 0A 25 04FB 0300 0100    
22DE  7332 0000 0C 25 04FB 0300 	- cylinder 3 : HSO - 0

22E8  5A32 0011 0A 2F 08F7 0400 0200    
22F4  7332 0001 0C 2F 08F7 0400 	- cylinder 4 : HSO - 1

22FE  5A32 0014 0A 39 10EF 0500 1000    
230A  7332 0004 0C 39 10EF 0500 	- cylinder 5 : HSO - 4

2314  5A32 0012 0A 43 20DF 0600 0400    
2320  7332 0002 0C 43 20DF 0600 	- cylinder 6 : HSO - 2

232A  5A32 0013 0A 4D 40BF 0700 0800    
2336  7332 0003 0C 4D 40BF 0700 	- cylinder 7 : HSO - 3

2340  5A32 0018 0A 57 807F 0800 0001    
234C  7332 0008 0C 57 807F 0800 	- cylinder 8 : HSO - 8

2356  0700

;******************************************************************
; table at $02C5 format - $0A byte entries ( two 5 byte entries - one for on and one for off)
; 
; Low to High transition side
; offset 0 - link field or FF if not in use (index of another $02C5 entry)
; offset 1 - saves zero here to stop? ($2C61) index of corresponding $2284 entry
; offset 2,3,4 - 24 bit IO time for HSO event
;
; High to Low transition side
; offset 5 - link field index to another $02C5 entry 
; offset 6 - index to corresponding $2284 table
; offset 7,8,9 - time
;
;******************************************************************
; table routine 0
;******************************************************************
;
2358  C77E0100            stb   zero,$01[REG_7e]
235C  F0                  ret
;
;*****************************************************************
; Cycling Routine at 2151, routine offset 2
; Validate KAM signature and initialize if invalid
;*****************************************************************
;
235D  A15A0722      L235D ld    REG_22,#$075A
2361  717F28              andb  REG_28,#$7F				; clr REG_28 bit 7 - clr KAM_ERROR
; check KAM signature
2364  B1AA42              ldb   REG_42,#$AA
2367  B1C630              ldb   REG_30,#$C6
236A  B17532              ldb   REG_32,#$75
236D  9B22A642            cmpb  REG_42,$A6[REG_22]		; $0700 KAMQA == #$AA
2371  D70F                jne   L2382
2373  9B225630            cmpb  REG_30,$56[REG_22]		; $07B0 KAMQB == #$C6
2377  D709                jne   L2382
2379  9B238800            cmpb  REG_32,$0088[REG_22]	; $07E2 KAMQC == #$75
      32
237E  D702                jne   L2382
2380  203A                sjmp  L23BC					; exit - signature is OK - KAMvalid

; Signature bad - KAM corrupted
2382  918028        L2382 orb   REG_28,#$80				; set REG_28 bit 7 - KAM_ERROR
2385  C722A642            stb   REG_42,$A6[REG_22]		; $0700 = #$AA
2389  C7225630            stb   REG_30,$56[REG_22]		; $07B0 = #$C6
238D  C723880032          stb   REG_32,$0088[REG_22]	; $07E2 = #$75
2392  9140D8              orb   REG_D8,#$40				; set VIP_KAM

2395  EF0854              lcall L77A0					; clear table $07C4 to $07D9 KAM?

2398  A180A238            ld    REG_38,#$A280			; default EVP value
239C  C301EE0738          st    REG_38,$07EE[Zero]		; EPTZER - Rolling average of the EPT sensor at Idle, counts. 
	
23A1  EF2F62              lcall L85D3					; init tables $703 and $759 to $80 for $56 bytes

23A4  A1040032            ld    REG_32,#$0004
23A8  A1E40730            ld    REG_30,#$07E4

23AC  C23100        L23AC st    Zero,[REG_30]+			; zero 4 words at 07E4 - 07EC - clear Idle Speed KAM IPSIBR cells
23AF  E032FA              djnz  REG_32,L23AC

23B2  C301EC0700          st    Zero,$07EC[Zero]		; set ISKSUM checksum to zero
23B7  C7226600            stb   Zero,$66[REG_22]		; $07C0 - KAM_FLAGS
23BB  F0                  ret

23BC  F0            L23BC ret
;
;***************************************************************
; Send HSO command for 2284 PWM table ** NO REFERENCES TO 2C5 table **
;   sends injector pulses via HSO outputs
;   also HSO 5 and HSO 9
;
; Input Parameter Registers:
; REG_92 + 3 = HSO Command to send
; REG_92 points to 2284 PWM entry
;
; REG_4C - flag bits for ?
;
; REG_80 - 24 bit time to fire event
;
;***************************************************************
;
23BD  B392037D      L23BD ldb   REG_7D,$03[REG_92]	; <<<<<<<<<<<<<<<<<HSO command to send from REG_92 table
23C1  718F4C              andb  REG_4C,#$8F			; clears flags 4,5,6
;
23C4  488C0684            sub   REG_84,Master_IO_Timer_Lo,REG_8C ; update master reference time, difference in R8C
23C8  64848C              add   REG_8C,REG_84		; R84 is IO time since last update
23CB  B4008E              addcb REG_8E,Zero			; REG_8C/8D/8E is 24 bit master reference time			

23CE  3B4C34              jbs   REG_4C,BIT_03,L2405	; IMMEDIATE - flag = A flag that indicates that the output is to be placed in the  hardware output carousel as soon as possible
23D1  394C26              jbs   REG_4C,BIT_01,L23FA ; FLAG_4D - flag

23D4  488C8084            sub   REG_84,REG_80,REG_8C; time until event needs to fire Lo 16
23D8  B08286              ldb   REG_86,REG_82		; time until event needs to fire Hi 8
23DB  B88E86              subcb REG_86,REG_8E		; time until event needs to fire Hi 8
23DE  3F8624              jbs   REG_86,BIT_07,L2405	; neg delta? event time has passed already?
23E1  D70C                jne   L23EF				; jump if time delta > 65535 IO times
23E3  890C0084            cmp   REG_84,#$000C		; time delta < #$000C?
23E7  D31C                jnc   L2405				; jmp if REG_84 > $000C
23E9  89460484            cmp   REG_84,#$0446		; time delta < #$0446?
23ED  D30B                jnc   L23FA				; jmp if REG_84 > $0446

23EF  3F4C65        L23EF jbs   REG_4C,BIT_07,L2457	; test flag bit 7 = NO_QUEUE
23F2  71204C              andb  REG_4C,#$20			; clear all flag bits except 5 = LATE_OUTPUT
23F5  91404C              orb   REG_4C,#$40			; set flag bit 6 = QUEUED
23F8  2063                sjmp  L245D				; schedule a routine for execution in 2284/2C5 table

23FA  3A4C16        L23FA jbs   REG_4C,BIT_02,L2413
23FD  9B9204CF            cmpb  REG_CF,$04[REG_92]	; compare CAROUSEL to ROM 2284 table entry pointer offset 4 - count??
2401  D310                jnc   L2413				; jmp if REG_CF(CAROUSEL) > 04[REG_92]
2403  27EA                sjmp  L23EF				; jmp back to schedule a task

2405  91284C        L2405 orb   REG_4C,#$28			; set flag bits 0,5
2408  B08E82              ldb   REG_82,REG_8E
240B  450D008C80          add   REG_80,REG_8C,#$000D ; EEC32 time + 0x0D
2410  B40082              addcb REG_82,Zero

2413  300A05        L2413 jbc   IO_Status,BIT_00,L241B ; jmp on *NO* HSO output overflow

; HSO has overflowed!
2416  B10CCF              ldb   REG_CF,#$0C			; reset CAROUSEL(sum of ?) to 12
2419  27D4                sjmp  L23EF				; jmp back to schedule a task

; set up HSO entry in h/w
241B  490100800E    L241B sub   HSO_Hold_Time,REG_80,#$0001	; <<<<<< set output change time
2420  B07D0D              ldb   HSO_Command_Hold,REG_7D		; <<<<<< command to send - from REG_92 entry[3]
2423  3B4C17              jbs   REG_4C,BIT_03,L243D	; IMMEDIATE flag = A flag that indicates that the output is to be placed in the  hardware output carousel as soon as possible
2426  3A4C14              jbs   REG_4C,BIT_02,L243D ; BYPASS_LIMIT
2429  0184                clr   REG_84				; clrs REG_85 too
242B  51078184            andb  REG_84,REG_81,#$07	; time ? 0000 0111  0000 0000
;
; REG_84 is three bits of the time for the last event ? weird?
;
242F  B385B40386          ldb   REG_86,$03B4[REG_84] ; increment SLICE[ REG_50 ]
2434  1786                incb  REG_86
2436  C785B40386          stb   REG_86,$03B4[REG_84]

243B  17CF                incb  REG_CF				; CAROUSEL

243D  71714C        L243D andb  REG_4C,#$71			; masks flags 0111 0001
2440  3E7D13              jbs   REG_7D,BIT_06,L2456	; return
2443  510F7D86            andb  REG_86,REG_7D,#$0F
2447  AD0184              ldbze REG_84,#$01
244A  098684              shl   REG_84,REG_86
244D  808444              or    REG_44,REG_84
2450  3C7D03              jbs   REG_7D,BIT_04,L2456	; return
2453  848444              xor   REG_44,REG_84
2456  F0            L2456 ret

2457  B1104C        L2457 ldb   REG_4C,#$10			; flags = bit 4 only
245A  CC00                pop   Zero				; throw away callers return address
245C  F0                  ret						; return to callers - caller
;
;**************************************************************
;
; PWM schedule subroutine for timed execution
; REG_92 - this is a pointer to one of the two sides ( on side and off side ) of the two event entries at $2284 table
;		$2284 table $2286(ON), $228E(OFF), $2296(ON), $229E(OFF)
;               and $22A6 table are valid too (ie 22B6)
;
;        - this pointer defines a PWM ON or OFF event. The volatile info (time etc) are saved in the $02C5 table in spots
;               reserved for each ROM table entry ( ROM offset 5 points to $02C5 table entry)
;
; REG_80/81/82 24 bit time for event to execute (call events execute proc)
;
;**************************************************************
;
; check if this functions entry is currently scheduled
245D  AF92057E      L245D ldbze REG_7E,$05[REG_92]			; get 2C5 RAM table offset for this ROM 2284 table entry @ REG_92 + 5

; so REG_7E points(offset) to ROM PWM event description (injectorX/SPOUT/KNOCK)
2461  577FC5020088        addb  REG_88,Zero,$02C5[REG_7E]	; REG_88 is 1st byte(link) of $02C5 entry at index REG_7E
2467  DE1A                jlt   L2483						; jmp to activate if N==1 ie FF - NOT currently scheduled

; link is currently scheduled for execution
; unlink entry from current execution time list
2469  B1FF8A              ldb   REG_8A,#$FF					; 1st thing - flag as out of service = FF
246C  C77FC5028A          stb   REG_8A,$02C5[REG_7E]		; link = FF means deactivated

2471  577FCA02008A        addb  REG_8A,Zero,$02CA[REG_7E]	; REG_8A is link from following entry OFF side ????(+5)
2477  C789C5028A          stb   REG_8A,$02C5[REG_88]		; update link????
247C  DA05                jle   L2483						; jump if end (no valid forward entry)
247E  C78BC50288          stb   REG_88,$02C5[REG_8A]		; entry is valid so update link???

; populate entry - 2284 ROM offset and new 24 bit activation time
2483  4984229288    L2483 sub   REG_88,REG_92,#$2284		; convert from ROM table pointer to *ROM* table offset
2488  C77FC60288          stb   REG_88,$02C6[REG_7E]		; save *ROM* OFFSET in this 2C5 table entry [1]
248D  C37FC70280          st    REG_80,$02C7[REG_7E]		; save TimeLo16
2492  C77FC90282          stb   REG_82,$02C9[REG_7E]		; save TimeHi8
; get head of the? list
2497  AF920288            ldbze REG_88,$02[REG_92]			; load 2C5 offset to list head? from 2284 table pointer( always 0?)
249B  5789C502008A        addb  REG_8A,Zero,$02C5[REG_88]	; REG_8A is link from REG_88 entry

24A1  200A                sjmp  L24AD						; insert into list by activation time

; insert entry in 2C5 list by activation time
24A3  55058A88      L24A3 addb  REG_88,REG_8A,#$05			; flip to other 'side' of entry ???
24A7  578BCA02008A        addb  REG_8A,Zero,$02CA[REG_8A]	; traverse link + 5

24AD  D212          L24AD jgt   L24C1						; jmp if valid 'link' to next entry - if N==0 && Z==0 then jmp to next entry
; end of list - insert at end of list
24AF  C77FCA028A          stb   REG_8A,$02CA[REG_7E]		; save in other 'side' link?
24B4  C789C5027E          stb   REG_7E,$02C5[REG_88]
24B9  65C5027E            add   REG_7E,#$02C5				; convert 2C5 offset to address
24BD  C67E88              stb   REG_88,[REG_7E]
24C0  F0                  ret

24C1  9B8BC60200    L24C1 cmpb  Zero,$02C6[REG_8A]			; (ROM offset?)offset 1 (0 value means time/entry not valid/active??)
24C6  DFDB                je    L24A3						; jmp if offset link = 0
; this is an active entry - compare event times
24C8  8B8BC70280          cmp   REG_80,$02C7[REG_8A]		; execute time Lo 16 bits
24CD  B08286              ldb   REG_86,REG_82
24D0  BB8BC90286          subcb REG_86,$02C9[REG_8A]		; execute time Hi 8 bits
24D5  3786CB              jbc   REG_86,BIT_07,L24A3			; if new event time is after this entry time then jump
; insert in list before REG_8A entry
24D8  A08A88              ld    REG_88,REG_8A
24DB  AF89C5028A          ldbze REG_8A,$02C5[REG_88]
24E0  C78BC5027E          stb   REG_7E,$02C5[REG_8A]
24E5  75057E              addb  REG_7E,#$05					; index to flip side of entry
24E8  C789C5027E          stb   REG_7E,$02C5[REG_88]
24ED  65C0027E            add   REG_7E,#$02C0				; pointer to base side of entry
24F1  C67E8A              stb   REG_8A,[REG_7E]
24F4  C77E0588            stb   REG_88,$05[REG_7E]
24F8  F0                  ret
;
;*************************************************************
; 2284 execution procs
;*************************************************************
;
; entry vector ON side of entry
24F9  2EC2          L24F9 scall L23BD				; send HSO command and other stuff
24FB  3E4C2A              jbs   REG_4C,BIT_06,L2528	; if QUEUED then return

24FE  65080092            add   REG_92,#$0008		; next routine - entry size of 2284 REG_92 table?
2502  C90925              push  #$2509				; return address
2505  CB92FE              push  $FE[REG_92]			; get new event time subroutine address from ON side 2284 entry
2508  F0                  ret						; jump to computed address

2509  DB25          L2509 jc    L2530				; reschedule the event
250B  2000                sjmp  L250D				; FALL THRU immediately to OFF side event execution
;
; entry vector OFF flip side of entry
250D  2EAE          L250D scall L23BD				; send HSO command and other stuff
250F  3E4C16              jbs   REG_4C,BIT_06,L2528	; if QUEUED then exit

2512  377D0F              jbc   REG_7D,BIT_07,L2524
2515  69080092            sub   REG_92,#$0008		; restore REG_92 pointer to ON side of entry
2519  C92025              push  #$2520				; return address
251C  CB920E              push  $0E[REG_92]			; new event time address from flip side of entry
251F  F0                  ret						; jump to computed address
2520  DB0E          L2520 jc    L2530				; jmp to reschedule event
2522  27D5                sjmp  L24F9				; go immediately to ON event execution
2524  C77E0100      L2524 stb   Zero,$01[REG_7E]	; mark $02C5 entry with zero
2528  F0            L2528 ret

2529  C93025              push  #$2530				; return address
252C  CB9204              push  $04[REG_92]
252F  F0                  ret	
					; jump to computed address
2530  2F2B          L2530 scall L245D				; schedule a routine for execution in 2284/2C5 table
2532  F0                  ret
;
;***********************************************************
; read HSI data
; 
; calculated parameters:
; REG_7A is the time the HSI event occurred in IO state times - lo 16 bits
; REG_7C is the time the HSI event occurred in IO state times - hi 8 bits
;***********************************************************
;
2533  34D801        L2533 jbc   REG_D8,BIT_04,L2537		; jmp if not STO_PENDING
2536  F0                  ret							; return if STO_PENDING

2537  488C0684      L2537 sub   REG_84,Master_IO_Timer_Lo,REG_8C ; update master reference time, difference in R84
253B  64848C              add   REG_8C,REG_84		
253E  B4008E              addcb REG_8E,Zero				; REG_8C/8D/8E is 24 bit master reference time		

2541  B08E7C              ldb   REG_7C,REG_8E			; hi byte last event time 

2544  480E8C84            sub   REG_84,REG_8C,HSI_Time_Hold ; cur time - event time = time since event posted lo 16 bits
2548  65020084            add   REG_84,#$0002			; add a bit of time for ?These calculations?

254C  48848C7A            sub   REG_7A,REG_8C,REG_84	; curTime - timeSinceEvent = IO event time lo 16 bits
2550  B8007C              subcb REG_7C,Zero				; IO event time hi 8 bits

2553  B00D83              ldb   REG_83,HSI_Data_Hold	; read HSI data
2556  B09087              ldb   REG_87,REG_90			; line bit mask
2559  948387              xorb  REG_87,REG_83			; flip data bits
255C  700C87              andb  REG_87,HSI_Data_Mask	; mask out valid data lines
255F  B08390              ldb   REG_90,REG_83			; our HSI data byte
2562  114C                clrb  REG_4C
2564  988700              cmpb  Zero,REG_87				; cmp to no line data
2567  DF4A                je    L25B3					; skip - check for more HSI data
2569  378703              jbc   REG_87,BIT_07,L256F
256C  EF165F              lcall L8485					; handle HSI line 7 data (Ign Diag Mon)

256F  368703        L256F jbc   REG_87,BIT_06,L2575
2572  EFA004              lcall L2A15					; handle HSI line 6 data (VSS counts)

2575  358703        L2575 jbc   REG_87,BIT_05,L257B
2578  EF5304              lcall L29CE					; handle HSI line 5 data (CID)

257B  328703        L257B jbc   REG_87,BIT_02,L2581
257E  EF0F10              lcall L3590					; handle HSI line 2 data (BP/MAP)

2581  318703        L2581 jbc   REG_87,BIT_01,L2587
2584  EF0847              lcall L6C8F					; handle HSI line 1 data (KNK)

2587  308703        L2587 jbc   REG_87,BIT_00,L258D
258A  EF3D02              lcall L27CA					; handle HSI line 0 data - (PIP)

258D  980087        L258D cmpb  REG_87,Zero
2590  DF21                je    L25B3					; jmp no more lines to process - ck for more events
2592  B1870C              ldb   HSI_Data_Mask,#$87		; 1000 0111
2595  9BF84A00            cmpb  Zero,$4A[REG_F8]		; ROM $947A KIHP = 00 ( is there a knock sensor )
2599  D703                jne   L259E					; jmp if we have Knock sensor input
259B  B1850C              ldb   HSI_Data_Mask,#$85		; 1000 0101 - remove knock sensor input line mask bit

259E  9BFE0C00      L259E cmpb  Zero,$0C[REG_FE]		; ROM $9E66(HP_CID) = 00 ( is there a CID sensor )
25A2  DF03                je    L25A7					; jmp if no CID sensor input
25A4  91200C              orb   HSI_Data_Mask,#$20		; 0010 0000 - add in line 5 (CID)

25A7  9BF24700      L25A7 cmpb  Zero,$47[REG_F2]		; ROM $8EA1 VSTYPE (are we tracking vehcle speed) = 01
25AB  DF03                je    L25B0					; jmp if not VSS input
25AD  91400C              orb   HSI_Data_Mask,#$40		; 0100 0000 - add in line 6 (VSS)

25B0  91014E        L25B0 orb   REG_4E,#$01				; set KTS_PENDING
25B3  320A02        L25B3 jbc   IO_Status,BIT_02,L25B8	; HSI data ready
25B6  277B                sjmp  L2533					; loop until HSI stack is empty
25B8  F0            L25B8 ret
;
                    ;************************************************************
                    ;*  High Speed Output Port Output Interrupt #1 Routine
					;*  Software interrupt every 1 msec
                    ;*  This base s/w clock int is used to drive a large table of 
                    ;*  s/w routines
                    ;*  This may be only for creating PWM output signals ???
                    ;*  Input : REG_91 is flags???
                    ;************************************************************
25B9  F2                  pushf
25BA  38D808              jbs   REG_D8,BIT_00,L25C5		; test to reschedule $2A interrupt - STO_HOLDOFF flag

25BD  45A101060E          add   HSO_Time_Hold,Master_IO_Timer_Lo,#$01A1	; = 417 * 12 * 3 clock periods (about 1msec)@15Mhz
25C2  B12A0D              ldb   HSO_Command_Hold,#$2A	; set up HSO command - int enabled, level low, channel 0x0A

25C5  C3740606      L25C5 st    Master_IO_Timer_Lo,$06[REG_74]  ; save current IO time
25C9  C3744810            st    Stack_Ptr,$48[REG_74]	; save stack pointer

25CD  AD7210              ldbze Stack_Ptr,#$72			; temp stack $0072

; subtract REG_CF (CAROUSEL) from SLICEs until zero
25D0  AC9150              ldbze REG_50,REG_91			; index =  SLICE_PTR?
25D3  51078D91            andb  REG_91,REG_8D,#$07		; end index = REG_8D mod 8

25D7  985091        L25D7 cmpb  REG_91,REG_50			; ck if we are at end index yet
25DA  DF15                je    L25F1					; jmp if done to end of this loop
25DC  7B51B403CF          subb  REG_CF,$03B4[REG_50]	; CAROUSEL -= SLICE[ R50 index ]
25E1  DB02                jc    L25E5					; jump if CAROUSEL still positive
25E3  11CF                clrb  REG_CF					; CAROUSEL = 0 (don't allow negative CAROUSEL)
25E5  C751B40300    L25E5 stb   Zero,$03B4[REG_50]		; SLICE[ R50 index ] = 0
25EA  1750                incb  REG_50
25EC  710750              andb  REG_50,#$07				; SLICE index mod 8 (0 to 7 only) wraps
25EF  27E6                sjmp  L25D7					; loop back

25F1  E7ED0D        L25F1 ljmp  L33E1					; long jump to ???Big Routine that Jumps back to $24F4

;
; this int routine sets ** LSO ** lines from REG_46
; this int routine sets ** bidirectional IO lines from REG_47 (EIGHT BITS *NOT* TWO!!!)
25F4  910147        L25F4 orb   REG_47,#$01				; set bidir line 0 to ON 
25F7  A04650              ld    REG_50,REG_46			; load REG_50 with LSO and Bidi output values
25FA  85000050            xor   REG_50,#$0000			; THIS DOES NOTHING! WHY ?????????????????????unused bit toggles??
25FE  B05002              ldb   Low_Speed_Output,REG_50	; write Lo speed output from REG_50 from REG_46
2601  B05103              ldb   BiDirect_Port,REG_51	; write BiDir ports from REG_51 from REG_47 (only bits 0 and 1 ?)
2604  180251              shrb  REG_51,#$02				; shift off the BiDI data lines (leaving unwritten shifted bits)
2607  C7012F0951          stb   REG_51,$092F[Zero]		; $092F is RAM backed output used for EEC IO - set 6 IO lines

; Send Pulse Width Modulation Table rise/fall events
; traverse the 2C5 queue executing the proc field of every proc entry whose time is up
260C  0194                clr   REG_94
260E  0196                clr   REG_96					; initial entry offset

; top of loop
; does not remove or add any queue entries
2610  B1804C        L2610 ldb   REG_4C,#$80				; set NO_QUEUE flag

2613  5795C502007E  L2613 addb  REG_7E,Zero,$02C5[REG_94] ; SLOT - update
2619  D702                jne   L261D					; jump if there is another event to check
261B  2084                sjmp  L26A1					; loop exit when $02C5[REG_94] == 0

261D  117F          L261D clrb  REG_7F
261F  577FC6020092        addb  REG_92,Zero,$02C6[REG_7E] ; add 2284 table offset
2625  D71C                jne   L2643					; valid entry - give it some time
2627  B1FF50              ldb   REG_50,#$FF
262A  C77FC50250          stb   REG_50,$02C5[REG_7E]
262F  577FCA020096        addb  REG_96,Zero,$02CA[REG_7E] ; calc next entry
2635  C795C50296          stb   REG_96,$02C5[REG_94]
263A  DF65                je    L26A1					; loop exit when REG_96 == 0
263C  C797C50294          stb   REG_94,$02C5[REG_96]
2641  27D0                sjmp  L2613					; loop for next time slice routine

2643  1193          L2643 clrb  REG_93

2645  488C0684            sub   REG_84,Master_IO_Timer_Lo,REG_8C ; update master reference time, difference in R84
2649  64848C              add   REG_8C,REG_84			
264C  B4008E              addcb REG_8E,Zero				; REG_8C/8D/8E is 24 bit master reference time

264F  A37FC70280          ld    REG_80,$02C7[REG_7E]	; time to execute this entry
2654  B37FC90282          ldb   REG_82,$02C9[REG_7E]

2659  488C8084            sub   REG_84,REG_80,REG_8C	; REG_84 is time left before we need to execute this entry 
265D  B08286              ldb   REG_86,REG_82
2660  B88E86              subcb REG_86,REG_8E

2663  3F860A              jbs   REG_86,BIT_07,L2670		; (delta negative) time has passed already?
2666  D739                jne   L26A1					; jne means this is some pos amt(>65535) of time before we execute this entry
							; jmp out here implies sorted $02C5 list by execution time(soon stuff first)

2668  89460484            cmp   REG_84,#$0446			; compare (< 65535) time difference
266C  D105                jnh   L2673
266E  2031                sjmp  L26A1					; event too old - don't execute it
2670  91084C        L2670 orb   REG_4C,#$08				; event time has passed IMMEDIATE= A flag that indicates that the output is to be placed in the hardware output carousel as soon as possible	
2673  89420084      L2673 cmp   REG_84,#$0042
2677  D103                jnh   L267C
2679  91024C              orb   REG_4C,#$02				; event time within $0042

267C  65C5027E      L267C add   REG_7E,#$02C5			; index to $02C5 table pointer
2680  65842292            add   REG_92,#$2284			; convert index to 2284 table entry pointer address
2684  C98A26              push  #$268A					; return address
2687  CA92                push  [REG_92]				; push execution proc from 2284 table entry @ REG_92
2689  F0                  ret							; execute computed proc

268A  344C0C        L268A jbc   REG_4C,BIT_04,L2699
268D  5795C502            addb  REG_94,Zero,$02C5[REG_94]
      0094
2693  DF0C                je    L26A1					; exit loop !
2695  65050094            add   REG_94,#$0005			; next $02C5 table entry - size of $02C5 table entry !!!!!!!!!
2699  320A03        L2699 jbc   IO_Status,BIT_02,L269F	; jmp if NO HSI data ready
269C  EF94FE              lcall L2533					; read pending HSI data
269F  276F          L269F sjmp  L2610					; LOOP for next entry


26A1  320A02        L26A1 jbc   IO_Status,BIT_02,L26A6	; jmp if NO HSI data ready
26A4  2E8D                scall L2533					; read HSI data
26A6  114C          L26A6 clrb  REG_4C
26A8  884800              cmp   Zero,REG_48
26AB  DF10                je    L26BD
26AD  374803              jbc   REG_48,BIT_07,L26B3
26B0  EF8B0C              lcall L333E
26B3  354802        L26B3 jbc   REG_48,BIT_05,L26B8
26B6  28EE                scall L27A6
26B8  320A02        L26B8 jbc   IO_Status,BIT_02,L26BD	; jmp if NO HSI data ready
26BB  2E76                scall L2533					; read HSI data
26BD  B301300951    L26BD ldb   REG_51,$0930[Zero]		; FUNNY ADDRESS?????????????more RAM mapped digital inputs?
26C2  190251              shlb  REG_51,#$02				; << 2
26C5  B00352              ldb   REG_52,BiDirect_Port	; read bidirectional port
26C8  710352              andb  REG_52,#$03				; mask off bits 0 and 1
26CB  905251              orb   REG_51,REG_52

26CE  B00B50              ldb   REG_50,HSI_Sample		; sample HSI inputs
26D1  85000050            xor   REG_50,#$0000			; set PSW flags??????????????????????WHY?
26D5  C850                push  REG_50					; save HSI sample
26D7  A374C494            ld    REG_94,$C4[REG_74]		; last time HSI_Sample
26DB  849450              xor   REG_50,REG_94			; these are the bits that changed since last read
26DE  0250                not   REG_50					; changed bits == 0
26E0  A0DE96              ld    REG_96,REG_DE			; what is this???
26E3  849496              xor   REG_96,REG_94			; last time data ???
26E6  609650              and   REG_50,REG_96
26E9  8450DE              xor   REG_DE,REG_50			; REG_DE may be HSI channel channel bit flags
26EC  CF74C4              pop   $C4[REG_74]				; save this time sample for next time
26EF  A00658              ld    REG_58,Master_IO_Timer  ; check lapsed time for ???
26F2  588F5950            subb  REG_50,REG_59,REG_8F	; IO time difference for ?
26F6  990250              cmpb  REG_50,#$02				; lapsed time >= 2
26F9  D31F                jnc   L271A					; jump if less than 2 IO times

; tickle both watchdogs
26FB  954002              xorb  Low_Speed_Output,#$40	; change LSO bit 6 - tickle CPU OK
26FE  B0598F              ldb   REG_8F,REG_59			; update EEC32 time
2701  1705                incb  Watchdog_Timer			; keep the dog at bay
2703  954002              xorb  Low_Speed_Output,#$40	; change LSO bit 6 - tickle CPU OK

2706  AD0950              ldbze REG_50,#$09				; number of byte locations to add up + 1
2709  0154                clr   REG_54					; init sum

; compute new CAROUSEL (sum) from SLICE table entries
270B  E05005        L270B djnz  REG_50,L2713			; test for done adding
270E  B054CF              ldb   REG_CF,REG_54			; move sum to REG_CF = CAROUSEL
2711  2007                sjmp  L271A					; exit loop
2713  7751B30354    L2713 addb  REG_54,$03B3[REG_50]	; add 9 bytes of ???save to CF : SLICE - 1[R50]
2718  27F1                sjmp  L270B					; add byte loop

271A  310903        L271A jbc   Interrupt_Pending,BIT_01,L2720 ; check IO timer overflow pending???
271D  B10208              ldb   Interrupt_Mask,#$02		; accept only IOtimer overflow interrupts if timer overflowed

2720  A3744810      L2720 ld    Stack_Ptr,$48[REG_74]	; restore saved stack pointer
2724  FF                  nop							; what in the world is this????
2725  FF                  nop
2726  FF                  nop
2727  FF                  nop
2728  FA                  di
2729  F3                  popf
272A  F1                  reti

                    ;************************************************************
                    ;*  High Speed Input #0 Interrupt Routine (read HSI data)
                    ;************************************************************
272B  F2                  pushf
272C  910002              orb   Low_Speed_Output,#$00	; what in the world is this? Wasted instruction?
272F  C3744810            st    Stack_Ptr,$48[REG_74]	; save stack pointer
2733  AD7210              ldbze Stack_Ptr,#$72			; temp stack pointer
2736  320A02              jbc   IO_Status,BIT_02,L273B	; jmp if NO HSI data ready
2739  2DF8                scall L2533					; read HSI data
273B  27E3          L273B sjmp  L2720					; jump to restore old stack ptr and return 

                    ;************************************************************
                    ;*  Master I/O Timer Overflow Interrupt Routine
                    ;************************************************************
273D  F2                  pushf
273E  0712                inc   REG_12					; incr high word I/O Timer
2740  D703                jne   L2745
2742  91044F              orb   REG_4F,#$04				; flag 32 bit overflow - CLKEXT_OVR
2745  B0128E        L2745 ldb   REG_8E,REG_12			; save 32 bit time to 8C-8F
2748  A0068C              ld    REG_8C,Master_IO_Timer_Lo
274B  FA                  di							; disable interrupts
274C  B1A108              ldb   Interrupt_Mask,#$A1		; what in the world is this? reset mask?? 1010 0001
274F  F3                  popf							; does this restore an INT MASK like in 8096?

                    ;   fall through to return instruction below
                    ;************************************************************
                    ;**** above routine falls through to this return
                    ;****   following interrupts are ignored by this routine
                    ;****
                    ;**** A/D End of Conversion Interrupt Routine
                    ;**** High Speed Input Port Input Data Available Routine
                    ;**** External Interrupt Routine
                    ;**** High Speed Input #1 Interrupt Routine
                    ;************************************************************
2750  F1                  reti
                    ;************************************************************
                    ;*  Software interrupt rescheduling and console tickle check
                    ;*  High Speed Output Port Output Interrupt #2 Routine
                    ;************************************************************

		; $0823 IOTimer periods = 12 * 200ns = 2.4ms * $823 = 5 Milliseconds
		; give console a time slice every 5Ms
        ; this routine checks the IO Time at $C11A to see if $D009 SB called

2751  F2                  pushf							; push flag should clear the PSW including the int bit 9 and te mask?!?
2752  FA                  di							; interrupts off AGAIN?
2753  FF                  nop							; why???

2754  47741A0050          add   REG_50,Zero,$1A[REG_74]		; *THIS* interrupt time
2759  DF21                je    L277C					; zero means set no more console tickles 
275B  48065052            sub   REG_52,REG_50,Master_IO_Timer_Lo
275F  37531A              jbc   REG_53,BIT_07,L277C		; skip if saved time > current time
2762  300A05              jbc   IO_Status,BIT_00,L276A	; jmp if NO HSO output overflow
2765  912048              orb   REG_48,#$20				; flag that console tickling has stopped?
2768  2012                sjmp  L277C					; skip creating new HSO event
276A  65230850      L276A add   REG_50,#$0823			; interval for next s/w interrupt - 5 Ms
276E  D702                jne   L2772
2770  0750                inc   REG_50					; avoid zero as a time - zero means s/w ints are off
2772  C3741A50      L2772 st    REG_50,$1A[REG_74]		; save last s/w int time
2776  A0500E              ld    HSO_Time_Hold,REG_50	; set interrupt time
2779  B10F0D              ldb   HSO_Command_Hold,#$0F	; set new software interrupt

277C  A301000D50    L277C ld    REG_50,$0D00[Zero]		; CONSOLE_STATUS check
2781  47011AC10052        add   REG_52,Zero,$C11A[Zero]	; note 'ROM' address, 16 bit IO time for next console call
2787  DF19                je    L27A2					; exit if zero
2789  992A51              cmpb  REG_51,#$2A				; $0D01 == $2A then console?
278C  D714                jne   L27A2					; exit if no console
278E  8B011AC100          cmp   Zero,$C11A[Zero]
2793  DF0D                je    L27A2					; how is this different than the test above?
2795  680652              sub   REG_52,Master_IO_Timer_Lo
2798  375307              jbc   REG_53,BIT_07,L27A2		; if positive exit - time not passed yet

279B  FA                  di
279C  FF                  nop
279D  F3                  popf
279E  C909D0              push  #$D009					; console routine at $D009???
27A1  F1                  reti							; reti ?? SB ret ???(is this evidence the reti does not pop stack)

27A2  FA            L27A2 di							; they are already disabled?!?
27A3  FF                  nop							; why???
27A4  F3                  popf							; restore flags and int bit 9
27A5  F1                  reti
;
;***************************************************************
; Reschedule s/w int ($0F)
;***************************************************************
;
27A6  380A19        L27A6 jbs   IO_Status,BIT_00,L27C2	; s/w int or HSO output overflow
27A9  A3741A50            ld    REG_50,$1A[REG_74]		; time of last s/w int
27AD  65230850            add   REG_50,#$0823			; #2083 wait for next s/w interval - 5msec
27B1  D702                jne   L27B5
27B3  0750                inc   REG_50					; avoid zero - means no int scheduled
27B5  C3741A50      L27B5 st    REG_50,$1A[REG_74]		; save new time
27B9  A0500E              ld    HSO_Time_Hold,REG_50	; set time
27BC  B10F0D              ldb   HSO_Command_Hold,#$0F	; set s/w interrupt type
27BF  71DF48              andb  REG_48,#$DF
27C2  F0            L27C2 ret
;
;***************************************************************
; data table used at $3E5D
;***************************************************************
;
27C3  FF                  byte  FF
27C4  0019                byte  00, 19
27C6  AB10800C            byte  AB, 10, 80, 0C
;
;***************************************************************
; handle HSI line 0 data (PIP)
; REG_7A is the HSI event time lo 16 bits
; REG_7C is the HSI event time hi 8 bits
;***************************************************************
;
27CA  B10604        L27CA ldb   AD_Command,#$06			; send cmd to read A-D channel 6 (MAF)
27CD  71FE87              andb  REG_87,#$FE				; mask out HSI line 0 data
27D0  A3764654            ld    REG_54,$46[REG_76]		; minimum PIP time to update RPM - MNPIP8 - RPM LIMITER
27D4  4B74507A50          sub   REG_50,REG_7A,$50[REG_74]  ; new PIP HSI event time lo 16 - HSI event time lo 16 bits
27D9  B07C52              ldb   REG_52,REG_7C
27DC  BB745252            subcb REG_52,$52[REG_74]	    ; new PIP HSI time hi 8 - HSI event time hi 8 bits
27E0  389002              jbs   REG_90,BIT_00,L27E5		; jump if line 0 = 1 - rising edge of PIP?
27E3  2135                sjmp  L291A

27E5  3C2D23        L27E5 jbs   REG_2D,BIT_04,L280B		; REG_2D bit 4 flag prevents RPM update - FIRST_PIP

; This is the first PIP signal
27E8  91102D              orb   REG_2D,#$10				; set bit 4 - FIRST_PIP
27EB  A1A62256            ld    REG_56,#$22A6			; 2284+22 this is the base of the 22 byte long entrys

27EF  89562356      L27EF cmp   REG_56,#$2356			; loop for all 8 $22A6 ROM PWM entrys
27F3  DB14                jc    L2809					; done - exit loop
27F5  AF560558            ldbze REG_58,$05[REG_56]		; index into $02C5 table
27F9  C759C2027C          stb   REG_7C,$02C2[REG_58]	; 24 bit *FIRST* PIP HSI 0 event time
27FE  C359C3027A          st    REG_7A,$02C3[REG_58]
2803  65160056            add   REG_56,#$0016			; next entry (22 bytes)
2807  27E6                sjmp  L27EF					; loop for all entries

2809  202C          L2809 sjmp  L2837

; not first PIP signal
; check if PIP is so short(high RPM) we should skip PIPs
280B  985200        L280B cmpb  Zero,REG_52				; new PIP time hi 8 ????
280E  D709                jne   L2819					; jmp if PIP time > $00FFFF
2810  885054              cmp   REG_54,REG_50		   	; new PIP time lo 16 : cmp MNPIP8 - rev limiter
2813  D104                jnh   L2819					; minimum time needed?
2815  71FE90              andb  REG_90,#$FE				; clear last PIP edge - SKIPS A PIP!!!! - PIP_HIGH <<<<< CAUSES SKIPPED PIP EDGES!!
2818  F0                  ret

2819  910C4E        L2819 orb   REG_4E,#$0C				; sets bits 2 & 3 in REG_4E - 3 = New RPM flag
281C  910228              orb   REG_28,#$02				; set PTPFLG  - PIP occurred after 50 msec
281F  9BFE0C00            cmpb  Zero,$0C[REG_FE]		; ROM $9E66(HP_CID) = 00 ( is there a CID sensor )
2823  D709                jne   L282E
2825  3E2E06              jbs   REG_2E,BIT_06,L282E		; jmp if SYNFLG - Flag indicating whether AE fuel is synchronous (set = 1) or asynchronous (set = 0). Initialized to 0
2828  3A2503              jbs   REG_25,BIT_02,L282E		; jmp if MHPFD_NEG
282B  71FB2D              andb  REG_2D,#$FB				; clr DOUBLE_EDGE
282E  71FE4F        L282E andb  REG_4F,#$FE				; clr pending flag
2831  322D03              jbc   REG_2D,BIT_02,L2837		; jmp if DOUBLE_EDGE
2834  91014F              orb   REG_4F,#$01				; set pending flag

2837  91804E        L2837 orb   REG_4E,#$80				; set new PIP received flag
283A  C376BABA            st    REG_BA,$BA[REG_76]		; $334 - DT23S - Previous PIP period before DT12S
283E  A050BA              ld    REG_BA,REG_50			; load new PIP time lo 16 bits-IOtime since last PIP event
2841  B052BC              ldb   REG_BC,REG_52			; load new PIP time hi 8 bits
2844  9BF81900            cmpb  Zero,$19[REG_F8]		; ROM $9449 - HP_HIDRES = Hardware present - High Data Rate Electronic Spark
2848  D703                jne   L284D
284A  EF4404              lcall L2C91
284D  9800BC        L284D cmpb  REG_BC,Zero				; PIP time hi 8 bits
2850  D710                jne   L2862
2852  8B7648BA            cmp   REG_BA,$48[REG_76]		; PIP time lo 16 bits
2856  D90A                jh    L2862
2858  B3FC3350            ldb   REG_50,$33[REG_FC]		; ROM $9AB1 - OUTINJ - Calibration switch to select between sequential and simultaneous injections (OUTINJ = 1 for sequential, OUTINJ = 2 for simultaneous)
285C  395003              jbs   REG_50,BIT_01,L2862
285F  71F72E              andb  REG_2E,#$F7				; clr SIMULTANEOUS
2862  C374507A      L2862 st    REG_7A,$50[REG_74]		; update 'last; PIP HSI event time lo 16 bits
2866  C774527C            stb   REG_7C,$52[REG_74]		; update 'last; PIP HSI event time hi 8 bits
286A  39CA0C              jbs   REG_CA,BIT_01,L2879		; jmp if DECLFLG
286D  17B3                incb  REG_B3					; PPCTR
286F  9BFC53B3            cmpb  REG_B3,$53[REG_FC]		; ROM $9AD1 - PIPNUM - Number of steps to Ramp Fuel, unitless
2873  D104                jnh   L2879
2875  B3FC53B3            ldb   REG_B3,$53[REG_FC]		; ROM $9AD1 - PIPNUM - Number of steps to Ramp Fuel, unitless
2879  17B4          L2879 incb  REG_B4					; PIPCNT
287B  D702                jne   L287F
287D  15B4                decb  REG_B4					; PIPCNT = Number of PIPs which have occurred
287F  179C          L287F incb  REG_9C					; ANPIP1
2881  D702                jne   L2885
2883  159C                decb  REG_9C					; ANPIP1
2885  179D          L2885 incb  REG_9D					; ANPIP2
2887  D702                jne   L288B
2889  159D                decb  REG_9D					; ANPIP2
288B  352A0A        L288B jbc   REG_2A,BIT_05,L2898		; jump if normal strategy - not self test mode
288E  A3727650            ld    REG_50,$76[REG_72]		; incr $01F6 - VCB_PIP_CNT
2892  0750                inc   REG_50
2894  C3727650            st    REG_50,$76[REG_72]		; VCB_PIP_CNT

2898  7520D1        L2898 addb  REG_D1,#$20
289B  9BF81900            cmpb  Zero,$19[REG_F8]		; ROM $9449 - HP_HIDRES = Hardware present - High Data Rate Electronic Spark
289F  D703                jne   L28A4
28A1  EF6542              lcall L6B09

28A4  330AFD        L28A4 jbc   IO_Status,BIT_03,L28A4	; busy wait for A-D complete
28A7  51F00450            andb  REG_50,AD_Lo,#$F0		; mask out channel number leaving count bits only
28AB  B00551              ldb   REG_51,AD_Hi
28AE  C372A450            st    REG_50,$A4[REG_72]		; save analog value  (raw MAF counts) $124

28B2  304F03              jbc   REG_4F,BIT_00,L28B8		; PIP_DOUBLE
28B5  EF5C43              lcall L6C14
28B8  717F4F        L28B8 andb  REG_4F,#$7F				; clr Knock Occurred flag
28BB  334F09              jbc   REG_4F,BIT_03,L28C7		; Knock detected
28BE  91804F              orb   REG_4F,#$80				; set Knock Occurred flag
28C1  399003              jbs   REG_90,BIT_01,L28C7
28C4  71F74F              andb  REG_4F,#$F7				; clr Knock detected

28C7  A1962292      L28C7 ld    REG_92,#$2296			; funny 2284 table + 0x0012 injector event table
28CB  9BF81900            cmpb  Zero,$19[REG_F8]		; ROM $9449 - HP_HIDRES - Hardware present - High Data Rate Electronic Spark
28CF  DF07                je    L28D8
28D1  3AA12E              jbs   REG_A1,BIT_02,L2902		; UNDSP = Run/Underspeed Flag.  (1 = Underspeed (or CRANK), 0 = Run)
28D4  2976                scall L2A4C
28D6  202A                sjmp  L2902

28D8  32A116        L28D8 jbc   REG_A1,BIT_02,L28F1		; UNDSP = Run/Underspeed Flag.  (1 = Underspeed (or CRANK), 0 = Run)
28DB  392D06              jbs   REG_2D,BIT_01,L28E4		; UNDSP_TRANS
28DE  91084C              orb   REG_4C,#$08				; IMMEDIATE = flag that indicates that the output is to be placed in the hardware output carousel as soon as possible
28E1  EFD9FA              lcall L23BD					; send HSO command ands lots of other stuff REG_92=2296

28E4  71FB2D        L28E4 andb  REG_2D,#$FB				; DOUBLE_EDGE 1111 1011
28E7  A1008050            ld    REG_50,#$8000
28EB  C3740450            st    REG_50,$04[REG_74]
28EF  2011                sjmp  L2902
28F1  384F0E        L28F1 jbs   REG_4F,BIT_00,L2902
28F4  312D09              jbc   REG_2D,BIT_01,L2900
28F7  91084C              orb   REG_4C,#$08				; IMMEDIATE = flag that indicates that the output is to be placed in the hardware output carousel as soon as possible
28FA  EFFCFB              lcall L24F9
28FD  71FD2D              andb  REG_2D,#$FD
2900  294A          L2900 scall L2A4C

2902  B1FF50        L2902 ldb   REG_50,#$FF
2905  C7721150            stb   REG_50,$11[REG_72]		; INJ_PIP = ?? = Counter which counts the number of PIPs between injections??
2909  91202F              orb   REG_2F,#$20
290C  A07A52              ld    REG_52,REG_7A
290F  EF2504              lcall L2D37
2912  EF4605              lcall L2E5B
2915  EFB006              lcall L2FC8
2918  20B3                sjmp  L29CD
291A  342D0C        L291A jbc   REG_2D,BIT_04,L2929		; REG_2D bit 4 effect RPM update
291D  080254              shr   REG_54,#$02
2920  885054              cmp   REG_54,REG_50
2923  D104                jnh   L2929
2925  910190              orb   REG_90,#$01				; set PIP_HIGH
2928  F0                  ret

2929  A0BA58        L2929 ld    REG_58,REG_BA			; PIP time lo 16 bits
292C  080158              shr   REG_58,#$01
292F  C376BCBE            st    REG_BE,$BC[REG_76]
2933  A050BE              ld    REG_BE,REG_50
2936  9BFE0C00            cmpb  Zero,$0C[REG_FE]		; ROM $9E66(HP_CID) = 00 ( is there a CID sensor )
293A  D762                jne   L299E
293C  71FDEB              andb  REG_EB,#$FD
293F  3AA157              jbs   REG_A1,BIT_02,L2999		; UNDSP = Run/Underspeed Flag.  (1 = Underspeed (or CRANK), 0 = Run)
2942  48BE5852            sub   REG_52,REG_58,REG_BE
2946  DA48                jle   L2990
2948  0150                clr   REG_50
294A  8C5850              divu  REG_50,REG_58
294D  8BFE0E50            cmp   REG_50,$0E[REG_FE]		; ROM $9E68
2951  D13D                jnh   L2990
2953  9102EB              orb   REG_EB,#$02
2956  9BFC2AD1            cmpb  REG_D1,$2A[REG_FC]		; ROM $9AA8 NUMCYL = Number of cylinders in the engine
295A  DF02                je    L295E
295C  203B                sjmp  L2999
295E  91502E        L295E orb   REG_2E,#$50
2961  A376C252            ld    REG_52,$C2[REG_76]
2965  C376C452            st    REG_52,$C4[REG_76]
2969  C376C2BE            st    REG_BE,$C2[REG_76]
296D  A376C050            ld    REG_50,$C0[REG_76]
2971  6CBE50              mulu  REG_50,REG_BE
2974  8CC050              divu  REG_50,REG_C0
2977  DD05                jv    L297E
2979  C0BE50              st    REG_50,REG_BE
297C  2003                sjmp  L2981
297E  A058BE        L297E ld    REG_BE,REG_58
2981  A3FC2E50      L2981 ld    REG_50,$2E[REG_FC]		; ROM $9AAC
2985  8BFC2A50            cmp   REG_50,$2A[REG_FC]		; ROM $9AA8 NUMCYL = Number of cylinders in the engine
2989  DF03                je    L298E
298B  71EF2E              andb  REG_2E,#$EF
298E  11D1          L298E clrb  REG_D1
2990  ACD158        L2990 ldbze REG_58,REG_D1
2993  8BFC2A58            cmp   REG_58,$2A[REG_FC]		; ROM $9AA8 NUMCYL = Number of cylinders in the engine
2997  D305                jnc   L299E
2999  11D1          L2999 clrb  REG_D1
299B  712F2E              andb  REG_2E,#$2F
299E  C99F6C        L299E push  #$6C9F
29A1  C9C82F              push  #$2FC8
29A4  9BF81900            cmpb  Zero,$19[REG_F8]		; ROM $9449 - HP_HIDRES - Hardware present - High Data Rate Electronic Spark
29A8  DF01                je    L29AB
29AA  F0                  ret

29AB  A19E2292      L29AB ld    REG_92,#$229E			; funny table 2284 + 0x001A
29AF  32A10D              jbc   REG_A1,BIT_02,L29BF		; UNDSP = Run/Underspeed Flag.  (1 = Underspeed (or CRANK), 0 = Run)
29B2  312D04              jbc   REG_2D,BIT_01,L29B9
29B5  71FD2D        L29B5 andb  REG_2D,#$FD
29B8  F0                  ret

29B9  91084C        L29B9 orb   REG_4C,#$08				; IMMEDIATE = flag that indicates that the output is to be placed in the hardware output carousel as soon as possible
29BC  E7FEF9              ljmp  L23BD					; send HSO command ands lots of other stuff
29BF  304F08        L29BF jbc   REG_4F,BIT_00,L29CA
29C2  A1962292            ld    REG_92,#$2296			; funny table 2284 + 0x0012
29C6  2884                scall L2A4C
29C8  27EB                sjmp  L29B5
29CA  392DEC        L29CA jbs   REG_2D,BIT_01,L29B9
29CD  F0            L29CD ret
;
;********************************************************
; handle HSI line 5 data - CID sync to #1 cylinder
; set flag bits in REG_2A
;********************************************************
;
29CE  71DF87        L29CE andb  REG_87,#$DF			; clr REG_87 bit 5 - CID INT 
29D1  9BFE0D00            cmpb  Zero,$0D[REG_FE]	; ROM $9E67(HP_CIDSEL) = 00
29D5  D716                jne   L29ED			; jmp never
29D7  3D9017              jbs   REG_90,BIT_05,L29F1	; jmp if HSI data Line 5(CID) = on
29DA  B3FE0750            ldb   REG_50,$07[REG_FE]	; ROM $9E5A+7 = 9E61 value = $08=ENGCYL=Number of cylinders per engine revolution
29DE  190450              shlb  REG_50,#$04			; 8 * 16 = 128
29E1  9850D1              cmpb  REG_D1,REG_50		; compare REG_D1 : $80
29E4  DF06                je    L29EC
29E6  B050D1              ldb   REG_D1,REG_50
29E9  712F2E              andb  REG_2E,#$2F			; clr bits 4,6,7 - SYNC_UP_FUEL, SYNFLG, FUEL_IN_SYNC
29EC  F0            L29EC ret

29ED  359001        L29ED jbc   REG_90,BIT_05,L29F1	; HSI data line 5
29F0  F0                  ret

29F1  B0D150        L29F1 ldb   REG_50,REG_D1
29F4  11D1                clrb  REG_D1				; SYNCTR
29F6  3AA106              jbs   REG_A1,BIT_02,L29FF	; UNDSP = Run/Underspeed Flag.  (1 = Underspeed (or CRANK), 0 = Run)
29F9  9BFC2A50            cmpb  REG_50,$2A[REG_FC]		; ROM $9AA8 NUMCYL = Number of cylinders in the engine
29FD  DF04                je    L2A03
29FF  712F2E        L29FF andb  REG_2E,#$2F			; clr bits 4,6,7 - SYNC_UP_FUEL, SYNFLG, FUEL_IN_SYNC
2A02  F0                  ret

2A03  91502E        L2A03 orb   REG_2E,#$50			; set BITS 4 AND 6 - SYNC_UP_FUEL, SYNFLG
2A06  A3FC2E50            ld    REG_50,$2E[REG_FC]	; ROM $9AAC PIPOUT
2A0A  8BFC2A50            cmp   REG_50,$2A[REG_FC]		; ROM $9AA8 NUMCYL = Number of cylinders in the engine
2A0E  D701                jne   L2A11
2A10  F0                  ret

2A11  71EF2E        L2A11 andb  REG_2E,#$EF			; clr bit 4 SYNC_UP_FUEL
2A14  F0                  ret
;
;*******************************************************
; handle HSI line 6 data (VSS)
; Vehilce Speed sender counts
; records time of LAST ring click - not the time of first click in this interval
;*******************************************************
;
2A15  71BF87        L2A15 andb  REG_87,#$BF			; masked input line data - 1101 1111
2A18  369016              jbc   REG_90,BIT_06,L2A31	; jmp(ret) if falling edge of click (we clock on rising edge only)

2A1B  17B2                incb  REG_B2				; count of VSS ring clicks between backgound loop calculations
2A1D  C7743D00            stb   Zero,$3D[REG_74]	; zero 3D+27E=$2BB (timer - time since last click) for 'timed out'
2A21  3AC405              jbs   REG_C4,BIT_02,L2A29	; 0000 0100 - jmp if interval start flag

2A24  9104C4              orb   REG_C4,#$04			; 0000 0100 - set new interval start
2A27  11B2                clrb  REG_B2				; clear ring click count

2A29  C374407A      L2A29 st    REG_7A,$40[REG_74]	; save last event time lo 16 to 40+27E=$2BE MPHTIME1
2A2D  C774427C            stb   REG_7C,$42[REG_74]	; save last event time hi  8 to 42+27E=$2C0

2A31  F0            L2A31 ret
;
;*******************************************************
;
;*******************************************************
;
2A32  D002                jnst  L2A36			; this is table data

2A34  E00168        L2A34 word $01E0, $0168, $2AAB, $4000, $5555	(480, 360, 10923, 16384, 21845)
2A37  01AB                clr   REG_AB
2A39  2A00                scall L2C3B
2A3B  405555E0            and   REG_E0,REG_55,REG_55
2A3F  5004AFF8            andb  REG_F8,REG_AF,AD_Lo
2A43  48509BF8            sub   REG_F8,REG_9B,REG_50
2A47  4850D9F6            sub   REG_F6,REG_D9,REG_50
2A4B  F0                  ret


2A3E            L2A3E:    djnz    REG_50,L2A45
2A41  AF        L2A41:    LDZBW   REG_50,REG_48[REG_F8]	; $ROM$9430[REG_48]
2A45  9B        L2A45:    cmpb    REG_50,REG_48[REG_F8]
                          jgtu    L2A41
                          ret





2A4C  ACDC50        L2A4C ldbze REG_50,REG_DC			; PIP COUNTER
2A4F  364F21              jbc   REG_4F,BIT_06,L2A73		; Knock Enabled
2A52  374F1E              jbc   REG_4F,BIT_07,L2A73		; Knock Occurred
2A55  98E100              cmpb  Zero,REG_E1				; TIP RET
2A58  D719                jne   L2A73
2A5A  B3512B02            ldb   REG_52,$022B[REG_50]	; $022B - SparkAdvance[ cylinder 1-8 ]
      52
2A5F  78E252              subb  REG_52,REG_E2			; RETINC
2A62  DD06                jv    L2A6A
2A64  9BF83052            cmpb  REG_52,$30[REG_F8]		; ROM $9460 RETLIM = Maximum degrees of retard control
2A68  D604                jge   L2A6E
2A6A  B3F83052      L2A6A ldb   REG_52,$30[REG_F8]		; ROM $9460 RETLIM = Maximum degrees of retard control
2A6E  C7512B02      L2A6E stb   REG_52,$022B[REG_50]	; $022B - SparkAdvance[ cylinder 1-8 ]
      52
2A73  2FC9          L2A73 scall L2A3E
2A75  C4DC50              stb   REG_50,REG_DC
2A78  364F0C              jbc   REG_4F,BIT_06,L2A87		; Knock Enabled
2A7B  374F09              jbc   REG_4F,BIT_07,L2A87		; Knock Occurred
2A7E  B3F84854            ldb   REG_54,$48[REG_F8]		; ROM $9478 KNKCYL
2A82  990154              cmpb  REG_54,#$01
2A85  D703                jne   L2A8A
2A87  352D12        L2A87 jbc   REG_2D,BIT_05,L2A9C
2A8A  9800E1        L2A8A cmpb  REG_E1,Zero
2A8D  D70D                jne   L2A9C
2A8F  362D0A              jbc   REG_2D,BIT_06,L2A9C
2A92  B3F832E1            ldb   REG_E1,$32[REG_F8]		; ROM $9462 tip_in_retard_max = 0
2A96  C374ACAA            st    REG_AA,$AC[REG_74]		; Throttle position
2A9A  2011                sjmp  L2AAD
2A9C  B0E152        L2A9C ldb   REG_52,REG_E1
2A9F  77F83352      L2A9F addb  REG_52,$33[REG_F8]		; ROM $9463 - TIPINC - Advance per PIP following a Tip-in retard.(Must be a positive number; units are degrees)
2AA3  DA02                jle   L2AA7
2AA5  1152                clrb  REG_52
2AA7  C4E152        L2AA7 stb   REG_52,REG_E1
2AAA  364F15              jbc   REG_4F,BIT_06,L2AC2		; Knock Enabled
2AAD  2F8F          L2AAD scall L2A3E
2AAF  9BF81900            cmpb  Zero,$19[REG_F8]		; ROM $9449 - HP_HIDRES - Hardware present - High Data Rate Electronic Spark
2AB3  DF02                je    L2AB7
2AB5  2F87                scall L2A3E
2AB7  57512B02      L2AB7 addb  REG_52,REG_E1,$022B[REG_50]	; $022B - SparkAdvance[ cylinder 1-8 ]
      E152
2ABD  D503                jnv   L2AC2
2ABF  B18052              ldb   REG_52,#$80
2AC2  1652          L2AC2 extb  REG_52
2AC4  44C25254            add   REG_54,REG_52,REG_C2
2AC8  C3741C54            st    REG_54,$1C[REG_74]		; $029a	SAFTOT = Total spark advance, including knock and tip-in retard, deg BTDC

2ACC  BFF80C52            ldbse REG_52,$0C[REG_F8]		; ROM $943C - SPLCLP - Lower limit spark clip for rotor registry
2AD0  885254              cmp   REG_54,REG_52
2AD3  D605                jge   L2ADA
2AD5  A05254              ld    REG_54,REG_52
2AD8  200C                sjmp  L2AE6
2ADA  AFF80D52      L2ADA ldbze REG_52,$0D[REG_F8]		; ROM $943D - SPUCLP - Upper limit spark clip for rotor registry
2ADE  885254              cmp   REG_54,REG_52
2AE1  DA03                jle   L2AE6
2AE3  A05254              ld    REG_54,REG_52
2AE6  9BF81900      L2AE6 cmpb  Zero,$19[REG_F8]		; ROM $9449 - HP_HIDRES - Hardware present - High Data Rate Electronic Spark
2AEA  DF62                je    L2B4E
2AEC  FE6DC0FF            mul   REG_54,#$FFC0
      54
2AF1  1152                clrb  REG_52
2AF3  375709              jbc   REG_57,BIT_07,L2AFF
2AF6  1752                incb  REG_52
2AF8  0354                neg   REG_54
2AFA  A40056              addc  REG_56,Zero
2AFD  0256                not   REG_56
2AFF  8D0A0054      L2AFF divu  REG_54,#$000A
2B03  305202              jbc   REG_52,BIT_00,L2B08
2B06  0354                neg   REG_54
2B08  65040654      L2B08 add   REG_54,#$0604
2B0C  89440054            cmp   REG_54,#$0044
2B10  DB06                jc    L2B18
2B12  A1440054            ld    REG_54,#$0044
2B16  200A                sjmp  L2B22
2B18  89040754      L2B18 cmp   REG_54,#$0704
2B1C  D104                jnh   L2B22
2B1E  A1040754            ld    REG_54,#$0704
2B22  C3741E54      L2B22 st    REG_54,$1E[REG_74]		; 029C - SAPW - Spark Angle Pulse Width, msec.
2B26  6DAB6A54            mulu  REG_54,#$6AAB
2B2A  758055              addb  REG_55,#$80
2B2D  A40056              addc  REG_56,Zero
2B30  C374CA56            st    REG_56,$CA[REG_74]
2B34  AFFE0750            ldbze REG_50,$07[REG_FE]		; ROM $9E61 - ENGCYL - Number of cylinders per engine revolution (NUMCYL/2); or number of PIPs per engine revolution
2B38  A351342A            ld    REG_50,$2A34[REG_50]
      50
2B3D  6CBA50              mulu  REG_50,REG_BA			; PIP time lo 16 bits
2B40  A3745054            ld    REG_54,$50[REG_74]		; $50[REG_74] - last saved PIP IO event time lo 16 bits
2B44  B3745256            ldb   REG_56,$52[REG_74]		; $52[REG_74] - last saved PIP IO event time hi 8 bits
2B48  910428              orb   REG_28,#$04
2B4B  E7E600              ljmp  L2C34
2B4E  AFFE0756      L2B4E ldbze REG_56,$07[REG_FE]		; ROM $9E61 - ENGCYL - Number of cylinders per engine revolution (NUMCYL/2); or number of PIPs per engine revolution
2B52  A3572E2A            ld    REG_56,$2A2E[REG_56]
      56
2B57  45280056            add   REG_52,REG_56,#$0028
      52
2B5C  685452              sub   REG_52,REG_54
2B5F  0150                clr   REG_50
2B61  090156              shl   REG_56,#$01
2B64  8C5650              divu  REG_50,REG_56
2B67  D506                jnv   L2B6F
2B69  A3740458            ld    REG_58,$04[REG_74]
2B6D  2017                sjmp  L2B86
2B6F  C05850        L2B6F st    REG_50,REG_58
2B72  A3740450            ld    REG_50,$04[REG_74]
2B76  6BF84650            sub   REG_50,$46[REG_F8]		; ROM $9476 -  SPKLIM = Maximum allowable advance in spark timing between spout outputs, Beta
2B7A  885850              cmp   REG_50,REG_58
2B7D  D103                jnh   L2B82
2B7F  A05058              ld    REG_58,REG_50
2B82  C3740458      L2B82 st    REG_58,$04[REG_74]
2B86  384F0E        L2B86 jbs   REG_4F,BIT_00,L2B97
2B89  4C58BA50            mulu  REG_50,REG_BA,REG_58	; PIP time lo 16 bits
2B8D  A3745054            ld    REG_54,$50[REG_74]		; $50[REG_74] - last saved PIP IO event time lo 16 bits
2B91  B3745256            ldb   REG_56,$52[REG_74]		; $52[REG_74] - last saved PIP IO event time hi 8 bits
2B95  206A                sjmp  L2C01
2B97  49004058      L2B97 sub   REG_50,REG_58,#$4000
      50
2B9C  090150              shl   REG_50,#$01
2B9F  B376BE52            ldb   REG_52,$BE[REG_76]
2BA3  375236              jbc   REG_52,BIT_07,L2BDC
2BA6  A3FE1052            ld    REG_52,$10[REG_FE]		; ROM $9E6A - TRSRPM = Minimum RPM to enable transient spark routine
2BAA  8852AE              cmp   REG_AE,REG_52			; REG_AE = engine RPM * 4
2BAD  D911                jh    L2BC0
2BAF  6BFE1252            sub   REG_52,$12[REG_FE]		; ROM 9E6C - TRSRPH = Hysteresis for TRSRPM
2BB3  D308                jnc   L2BBD
2BB5  8852AE              cmp   REG_AE,REG_52			; REG_AE = engine RPM * 4
2BB8  DB03                jc    L2BBD
2BBA  71EF26              andb  REG_26,#$EF
2BBD  34261C        L2BBD jbc   REG_26,BIT_04,L2BDC
2BC0  911026        L2BC0 orb   REG_26,#$10				; MAF input range error?
2BC3  A376BC54            ld    REG_54,$BC[REG_76]
2BC7  6CC054              mulu  REG_54,REG_C0
2BCA  0D0154              shll  REG_54,#$01
2BCD  4856BA56            sub   REG_56,REG_BA,REG_56	; REG_BA - PIP time lo 16 bits
2BD1  0154                clr   REG_54
2BD3  0C0154              shrl  REG_54,#$01
2BD6  8F76BC54            divu  REG_54,$BC[REG_76]
2BDA  D503                jnv   L2BDF
2BDC  A0C054        L2BDC ld    REG_54,REG_C0
2BDF  6C5450        L2BDF mulu  REG_50,REG_54
2BE2  A0C050              ld    REG_50,REG_C0
2BE5  080150              shr   REG_50,#$01
2BE8  645052              add   REG_52,REG_50
2BEB  69004052            sub   REG_52,#$4000
2BEF  090152              shl   REG_52,#$01
2BF2  4CBE5250            mulu  REG_50,REG_52,REG_BE
2BF6  1156                clrb  REG_56
2BF8  477450BE            add   REG_54,REG_BE,$50[REG_74]	; $50[REG_74] - last saved PIP IO event time lo 16 bits
      54
2BFD  B7745256            addcb REG_56,$52[REG_74]		; $52[REG_74] - last saved PIP IO event time hi 8 bits
2C01  0D0150        L2C01 shll  REG_50,#$01
2C04  758051              addb  REG_51,#$80
2C07  A40052              addc  REG_52,Zero
2C0A  910428              orb   REG_28,#$04
2C0D  322D11              jbc   REG_2D,BIT_02,L2C21
2C10  89A10152            cmp   REG_52,#$01A1
2C14  D306                jnc   L2C1C
2C16  8BF816BA            cmp   REG_BA,$16[REG_F8]		; REG_BA - PIP time lo 16 bits : ROM $9446
2C1A  DB03                jc    L2C1F
2C1C  71FB2D        L2C1C andb  REG_2D,#$FB
2C1F  2013          L2C1F sjmp  L2C34
2C21  48BE5250      L2C21 sub   REG_50,REG_52,REG_BE
2C25  89F40150            cmp   REG_50,#$01F4
2C29  DA09                jle   L2C34
2C2B  8BF814BA            cmp   REG_BA,$14[REG_F8]		; REG_BA - PIP time lo 16 bits : ROM $9444
2C2F  D103                jnh   L2C34
2C31  91042D              orb   REG_2D,#$04
2C34  C3745C52      L2C34 st    REG_52,$5C[REG_74]		; $027E+5C=$02DA = $02C5-$15 right in the middle of our table!
2C38  2834                scall L2C6E
2C3A  A1C8027E            ld    REG_7E,#$02C8
2C3E  9B7E0100            cmpb  Zero,$01[REG_7E]
2C42  D619                jge   L2C5D
2C44  91012D              orb   REG_2D,#$01
2C47  4B7E0280            sub   REG_50,REG_80,$02[REG_7E]
      50
2C4C  37510D              jbc   REG_51,BIT_07,L2C5C
2C4F  91084C              orb   REG_4C,#$08				; IMMEDIATE = flag that indicates that the output is to be placed in the hardware output carousel as soon as possible
2C52  AF7E0192            ldbze REG_92,$01[REG_7E]		; funny 2284 table offset
2C56  65842292            add   REG_92,#$2284
2C5A  CA92                push  [REG_92]
2C5C  F0            L2C5C ret							; jump with existing return

2C5D  EF99F8        L2C5D lcall L24F9
2C60  F0                  ret

; 2284 proc - save zero flag in 2C5 entry or add PIP & ?? time to R80/81/82
2C61  382D07        L2C61 jbs   REG_2D,BIT_00,L2C6B		; 2282 entry proc - jump if SPOUT_PENDING
2C64  C77E0100            stb   Zero,$01[REG_7E]
2C68  CC00                pop   Zero
2C6A  F0                  ret

2C6B  71FE2D        L2C6B andb  REG_2D,#$FE				; clr SPOUT_PENDING
2C6E  A3745080      L2C6E ld    REG_80,$50[REG_74]		; $2CE=LAST_HI_PIP = last saved PIP IO event time lo 16 bits = time of the latest PIP up-edge
2C72  B3745282            ldb   REG_82,$52[REG_74]		; $52[REG_74] - last saved PIP IO event time hi 8 bits
2C76  67745C80            add   REG_80,$5C[REG_74]		; time - but what kind?
2C7A  B40082              addcb REG_82,Zero
2C7D  304F0F              jbc   REG_4F,BIT_00,L2C8F		; jump if no PIP_DOUBLE
2C80  64BE80              add   REG_80,REG_BE			; REG_BE = HFDLTA = Latest elapsed time from PIP_UP_EDGE to PIP_DOWN_EDGE, clock ticks
2C83  B40082              addcb REG_82,Zero
2C86  2007                sjmp  L2C8F
;
; 2284 proc - add SPOUT_LOW_TIME to R80/81/82 entry time
2C88  6774CA80      L2C88 add   REG_80,$CA[REG_74]		; 248 - SPOUT_LOW_TIME - duty cycle low time for rise edge event
2C8C  B40082              addcb REG_82,Zero
2C8F  F8            L2C8F clrc
2C90  F0                  ret

2C91  9BF81A00      L2C91 cmpb  Zero,$1A[REG_F8]		; ROM $944A -  CCDSW = Calibration Switch to select Computer Controlled Dwell. (1 = Computer Controlled Dwell;0 = TFI Controlled Dwell)
2C95  D705                jne   L2C9C
2C97  A0BE52              ld    REG_52,REG_BE
2C9A  2080                sjmp  L2D1C
2C9C  4D4428BA      L2C9C mulu  REG_54,REG_BA,#$2844	; REG_BA - PIP time lo 16 bits
      54
2CA1  A05658              ld    REG_58,REG_56
2CA4  8B74C656            cmp   REG_56,$C6[REG_74]		; 244 PPERENG
2CA8  D322                jnc   L2CCC
2CAA  A3F82050            ld    REG_50,$20[REG_F8]		; ROM $9450 -  PACSLO = Slope for linear equation describing PIP period and percent of PIP period for acceleration, (Units = Beta/second)
2CAE  6C5650              mulu  REG_50,REG_56
2CB1  0C0450              shrl  REG_50,#$04
2CB4  885200              cmp   Zero,REG_52
2CB7  D70F                jne   L2CC8
2CB9  4B74C850            sub   REG_58,REG_50,$C8[REG_74] ; 246 - POFFENG
      58
2CBE  DB02                jc    L2CC2
2CC0  0158                clr   REG_58
2CC2  8BF82258      L2CC2 cmp   REG_58,$22[REG_F8]		; ROM $9452 -  PACLIM = Maximum limit of PIP acceleration in percent of PIP period, Beta
2CC6  D104                jnh   L2CCC
2CC8  A3F82258      L2CC8 ld    REG_58,$22[REG_F8]		; ROM $9452 -  PACLIM = Maximum limit of PIP acceleration in percent of PIP period, Beta
2CCC  C374BA58      L2CCC st    REG_58,$BA[REG_74]
2CD0  A1008050            ld    REG_50,#$8000
2CD4  6BF82450            sub   REG_50,$24[REG_F8]		; ROM $9454
2CD8  685850              sub   REG_50,REG_58
2CDB  6CBA50              mulu  REG_50,REG_BA			; REG_BA - PIP time lo 16 bits
2CDE  0D0150              shll  REG_50,#$01
2CE1  6B74BC52            sub   REG_52,$BC[REG_74]		; 23A - DWLBST
2CE5  DB02                jc    L2CE9
2CE7  0152                clr   REG_52
2CE9  A05258        L2CE9 ld    REG_58,REG_52
2CEC  0150                clr   REG_50
2CEE  8CBA50              divu  REG_50,REG_BA			; REG_BA - PIP time lo 16 bits
2CF1  D503                jnv   L2CF6
2CF3  BDFF50              ldbse REG_50,#$FF
2CF6  A05054        L2CF6 ld    REG_54,REG_50
2CF9  8BF82C56            cmp   REG_56,$2C[REG_F8]		; ROM $945C -  DWLTSW = Switch point for change of maximum permitted DWELL,sec
2CFD  D10D                jnh   L2D0C
2CFF  A3F82650            ld    REG_50,$26[REG_F8]		; ROM $9456 max_low_speed_dwell
2D03  6CBA50              mulu  REG_50,REG_BA			; REG_BA - PIP time lo 16 bits
2D06  8BF82654      L2D06 cmp   REG_54,$26[REG_F8]		; ROM $9456 max_low_speed_dwell
2D0A  D110                jnh   L2D1C
2D0C  A3F82850      L2D0C ld    REG_50,$28[REG_F8]		; ROM $9458 max_high_speed_dwell
2D10  6CBA50              mulu  REG_50,REG_BA			; REG_BA - PIP time lo 16 bits
2D13  8BF82854            cmp   REG_54,$28[REG_F8]		; ROM $9458 max_high_speed_dwell
2D17  D103                jnh   L2D1C	
2D19  A05852              ld    REG_52,REG_58
2D1C  C374CA52      L2D1C st    REG_52,$CA[REG_74]
2D20  4852BA52            sub   REG_52,REG_BA,REG_52	; REG_BA - PIP time lo 16 bits
2D24  C374BE52            st    REG_52,$BE[REG_74]
2D28  F0                  ret
;
;****************************************************************
;
2D29  330AFD        L2D29 jbc   IO_Status,BIT_03,L2D29	; busy wait for A-D complete
2D2C  51F00454            andb  REG_54,AD_Lo,#$F0		; mask off analog lo bits
2D30  B00555              ldb   REG_55,AD_Hi
2D33  C372A454            st    REG_54,$A4[REG_72]		; save A-D reading (raw MAF counts?) $0124

2D37  4B76AE52      L2D37 sub   REG_50,REG_52,$AE[REG_76]
      50
2D3C  C376AE52            st    REG_52,$AE[REG_76]
2D40  C376B850            st    REG_50,$B8[REG_76]
2D44  EF8000              lcall L2DC7					; call read MAF/calibrate/lookup in transfer function
2D47  352F7C              jbc   REG_2F,BIT_05,L2DC6
2D4A  C3763600            st    Zero,$36[REG_76]
2D4E  A376B050            ld    REG_50,$B0[REG_76]
2D52  C376B650            st    REG_50,$B6[REG_76]
2D56  AF763952            ldbze REG_52,$39[REG_76]
2D5A  6C5250              mulu  REG_50,REG_52
2D5D  0C0750              shrl  REG_50,#$07
2D60  6774D650            add   REG_50,$D6[REG_74]
2D64  DB06                jc    L2D6C
2D66  8B762C50            cmp   REG_50,$2C[REG_76]
2D6A  D104                jnh   L2D70
2D6C  A3762C50      L2D6C ld    REG_50,$2C[REG_76]
2D70  C374D850      L2D70 st    REG_50,$D8[REG_74]
2D74  A05054              ld    REG_54,REG_50
2D77  312644              jbc   REG_26,BIT_01,L2DBE
2D7A  0152                clr   REG_52
2D7C  0D0850              shll  REG_50,#$08
2D7F  A374DA58            ld    REG_58,$DA[REG_74]		; ARCHFG = Filtered air charge according to filling model
2D83  8C5850              divu  REG_50,REG_58
2D86  DD0A                jv    L2D92
2D88  A3F60252            ld    REG_52,$02[REG_F6]		; ROM $93AA -  FKARCH = Manifold filling model slow filter constant
2D8C  8BF60650            cmp   REG_50,$06[REG_F6]		; ROM $93AE -  FILFRC = Fraction to select slow transient vs fast.  transient filter
2D90  D104                jnh   L2D96
2D92  A3F60452      L2D92 ld    REG_52,$04[REG_F6]		; ROM $93AC -  FKARC1 = Fast filter constant for manifold filling
2D96  115A          L2D96 clrb  REG_5A
2D98  685854              sub   REG_54,REG_58
2D9B  DB04                jc    L2DA1
2D9D  175A                incb  REG_5A
2D9F  0354                neg   REG_54
2DA1  89010054      L2DA1 cmp   REG_54,#$0001
2DA5  D905                jh    L2DAC
2DA7  A05850              ld    REG_50,REG_58
2DAA  2012                sjmp  L2DBE
2DAC  6C5254        L2DAC mulu  REG_54,REG_52
2DAF  0356                neg   REG_56
2DB1  D702                jne   L2DB5
2DB3  0556                dec   REG_56
2DB5  385A02        L2DB5 jbs   REG_5A,BIT_00,L2DBA
2DB8  0356                neg   REG_56
2DBA  44585650      L2DBA add   REG_50,REG_56,REG_58

2DBE  C374DA50      L2DBE st    REG_50,$DA[REG_74]		; ARCHFG = Filtered air charge according to filling model
2DC2  C376B000            st    Zero,$B0[REG_76]
2DC6  F0            L2DC6 ret
;
;***********************************************************************
; call read MAF/calibrate/lookup in transfer function
;
2DC7  A372A450      L2DC7 ld    REG_50,$A4[REG_72]		; $124 -  (raw MAF counts)
2DCB  6D002850            mulu  REG_50,#$2800			; MAF transfer function max calibrated count is about 4C4A ~$5000
2DCF  8F729050            divu  REG_50,$90[REG_72]		; $110 - div by zero (VCAL) regulated 2.5V
                                                        ; REG_50 MAF range is 0-$5000 for 0-5Volts
2DD3  D503                jnv   L2DD8
2DD5  BDFF50              ldbse REG_50,#$FF				; clamp max MAF voltage to $FFFF (this is a very hi clip voltage)
2DD8  C374D050      L2DD8 st    REG_50,$D0[REG_74]		; is this the voltage calibrated MAF voltage?
2DDC  A376B452            ld    REG_52,$B4[REG_76]	    ; MAF transfer function table pointer
2DE0  8A5250              cmp   REG_50,[REG_52]			; table max MAF voltage
2DE3  D706                jne   L2DEB
2DE5  A3520254            ld    REG_54,$02[REG_52]		; function value = max Air flow
2DE9  2036                sjmp  L2E21					; end table look up

2DEB  D30B          L2DEB jnc   L2DF8
2DED  69040052      L2DED sub   REG_52,#$0004			; back up in MAF transfer function table to the right value
2DF1  8A5250              cmp   REG_50,[REG_52]
2DF4  D9F7                jh    L2DED					; loop
2DF6  200D                sjmp  L2E05

2DF8  65040052      L2DF8 add   REG_52,#$0004			; jmp ahead in the MAF transfer function to the right value
2DFC  8A5250              cmp   REG_50,[REG_52]
2DFF  D3F7                jnc   L2DF8					; loop
2E01  69040052            sub   REG_52,#$0004
; interpolate
2E05  A25358        L2E05 ld    REG_58,[REG_52]+		; interpolate larger MAF
2E08  A25354              ld    REG_54,[REG_52]+		; larger air flow
2E0B  6A5258              sub   REG_58,[REG_52]			; MAF difference
2E0E  6A5350              sub   REG_50,[REG_52]+		; MAF delta to interpolate
2E11  6A5254              sub   REG_54,[REG_52]			; air flow difference
2E14  6C5054              mulu  REG_54,REG_50			; 
2E17  8C5854              divu  REG_54,REG_58
2E1A  665354              add   REG_54,[REG_52]+		; REG_54 is interpolated air flow
2E1D  69040052            sub   REG_52,#$0004
2E21  C376B452      L2E21 st    REG_52,$B4[REG_76]		; STORE Updated MAF transfer func table address - ptr to last interpolation pair for speed?

2E25  A374D250            ld    REG_50,$D2[REG_74]		; old MAF value
2E29  C374D254            st    REG_54,$D2[REG_74]		; MAF not in Kg/Hr
2E2D  0152                clr   REG_52
2E2F  645450              add   REG_50,REG_54			; add old and new MAF values
2E32  A5000052            addc  REG_52,#$0000
2E36  0C0150              shrl  REG_50,#$01				; avg - div by 2
2E39  6F76B850            mulu  REG_50,$B8[REG_76]		; ???
2E3D  0D0950              shll  REG_50,#$09				; times 512
2E40  6701B00350          add   REG_50,$03B0[Zero]		; cksum
2E45  C301B00350          st    REG_50,$03B0[Zero]		; cksum
2E4A  A40052              addc  REG_52,Zero
2E4D  6776B052            add   REG_52,$B0[REG_76]
2E51  D303                jnc   L2E56
2E53  BDFF52              ldbse REG_52,#$FF
2E56  C376B052      L2E56 st    REG_52,$B0[REG_76]		; 
2E5A  F0                  ret	
;
;**********************************************************
;
2E5B  0152          L2E5B clr   REG_52					; start port = 0
2E5D  A353940354    L2E5D ld    REG_54,$0394[REG_52]	; BGFUL1 -  = Background Fuel Pulsewidth for bank "n" (n = 1,2)
2E62  35E72D              jbc   REG_E7,BIT_05,L2E92		; FFULFLG = Foreground Fuel Flag (1 = compute fuel pulsewidth in foreground using the latest integrated air charge, 0 = use background computed fuel pulsewidth).

; compute fuel pulsewidth in foreground using the latest integrated air charge
2E65  A374DA54            ld    REG_54,$DA[REG_74]		; ARCHFG = Filtered air charge according to filling model
2E69  6F53980354          mulu  REG_54,$0398[REG_52]	; FFULM1 - foreground  fuel  intermediate  values
2E6E  8F762654            divu  REG_54,$26[REG_76]		; ARCHG_BG = The value of air charge that was used to compute the intermediate values for the foreground fuel calculation and additionally, the air charge value that is divided into the latest air charge to  scale the new fuel pulsewidth
2E72  D503                jnv   L2E77
2E74  BDFF54              ldbse REG_54,#$FF				; clamp overflow
2E77  A3539C0356    L2E77 ld    REG_56,$039C[REG_52]	; FFULC1 = The value that is added in the foreground fuel pulsewidth
2E7C  37570B              jbc   REG_57,BIT_07,L2E8A		; is value negative?
2E7F  0356                neg   REG_56
2E81  685654              sub   REG_54,REG_56
2E84  DB0C                jc    L2E92
2E86  0154                clr   REG_54
2E88  2008                sjmp  L2E92
2E8A  645654        L2E8A add   REG_54,REG_56
2E8D  D303                jnc   L2E92
2E8F  BDFF54              ldbse REG_54,#$FF

; use background computed fuel pulsewidth
2E92  6D73CB54      L2E92 mulu  REG_54,#$CB73				; clock time conversion factor
2E96  A05650              ld    REG_50,REG_56
2E99  015A                clr   REG_5A
2E9B  98BC00              cmpb  Zero,REG_BC
2E9E  D731                jne   L2ED1
2EA0  0C0A54              shrl  REG_54,#$0A
2EA3  8CBA54              divu  REG_54,REG_BA				; REG_BA - PIP time lo 16 bits
2EA6  8BFC2E54            cmp   REG_54,$2E[REG_FC]			; ROM $9AAC PIPOUT = The number of PIP periods between the start of consecutive injections
2EAA  D310                jnc   L2EBC
2EAC  A3FC2E54            ld    REG_54,$2E[REG_FC]			; ROM $9AAC PIPOUT = The number of PIP periods between the start of consecutive injections
2EB0  0554                dec   REG_54
2EB2  4CBA5458            mulu  REG_58,REG_54,REG_BA		; REG_BA - PIP time lo 16 bits
2EB6  0C0658              shrl  REG_58,#$06
2EB9  A05850              ld    REG_50,REG_58
2EBC  015A          L2EBC clr   REG_5A
2EBE  A3720E58            ld    REG_58,$0E[REG_72]			; PWOFF = Injector pulsewidth offset (clock ticks).
2EC2  0D0558              shll  REG_58,#$05
2EC5  8CBA58              divu  REG_58,REG_BA				; REG_BA - PIP time lo 16 bits
2EC8  4458545A            add   REG_5A,REG_54,REG_58
2ECC  D303                jnc   L2ED1
2ECE  ADFF5A              ldbze REG_5A,#$FF
2ED1  0154          L2ED1 clr   REG_54
2ED3  4B530602            sub   REG_56,REG_50,$0206[REG_52]	; PulseWidth - Injector Pulse Width in ms for REG_52 - port 0 or 2
      5056
2ED9  DB02                jc    L2EDD
2EDB  0356                neg   REG_56
2EDD  8F53060254    L2EDD divu  REG_54,$0206[REG_52]		; PulseWidth - Injector Pulse Width in ms for REG_52 - port 0 or 2
2EE2  89991954            cmp   REG_54,#$1999
2EE6  D103                jnh   L2EEB
2EE8  918048              orb   REG_48,#$80
2EEB  C353060250    L2EEB st    REG_50,$0206[REG_52]		; PulseWidth - Injector Pulse Width in ms for REG_52 - port 0 or 2

2EF0  372E13              jbc   REG_2E,BIT_07,L2F06			; FUEL_IN_SYNC = Fuel synchronized with PIP
2EF3  31520A              jbc   REG_52,BIT_01,L2F00
2EF6  3E2F02              jbs   REG_2F,BIT_06,L2EFB			; NEW_IDELAY = Flag controlled by EOS. If set (1) this flag triggers injector delay calculation in the background loop; if clear (0), no injector delay calculation is done
2EF9  209E          L2EF9 sjmp  L2F99

2EFB  71BF2F        L2EFB andb  REG_2F,#$BF					; NEW_IDELAY
2EFE  2006                sjmp  L2F06

2F00  372FF6        L2F00 jbc   REG_2F,BIT_07,L2EF9			; NEW_IDELAY1
2F03  717F2F              andb  REG_2F,#$7F
2F06  A3F42454      L2F06 ld    REG_54,$24[REG_F4]			; ROM $8FFA = Indicates which edge of the fuel pulse is the reference edge for fuel timing, INJDLY.  (0 = start edge)
2F0A  6C5A54              mulu  REG_54,REG_5A
2F0D  015A                clr   REG_5A
2F0F  A3720058            ld    REG_58,$00[REG_72]			; INJDLY = Injector delay in degrees
2F13  315202              jbc   REG_52,BIT_01,L2F18
2F16  1552                decb  REG_52
2F18  65800258      L2F18 add   REG_58,#$0280				; 640 degrees?
2F1C  0D0158              shll  REG_58,#$01
2F1F  8FFC2C58            divu  REG_58,$2C[REG_FC]			; ROM $9AAA - DEGPIP = Engine degrees per PIP period, deg. (90 deg = 8 cyl;120 deg = 6; 180 = 4 cyl)
2F23  685458              sub   REG_58,REG_54
2F26  DB04                jc    L2F2C
2F28  67FC2A58            add   REG_58,$2A[REG_FC]			; ROM $9AA8 -  NUMCYL = Number of cylinders.
2F2C  372E5C        L2F2C jbc   REG_2E,BIT_07,L2F8B			; FUEL_IN_SYNC = Fuel synchronized with PIP
2F2F  3B2F57              jbs   REG_2F,BIT_03,L2F89			; NLMT_FLG = Engine Speed Limiter Flag - (1 = limit engine speed by turning off the fuel; 0 = normal engine speed)
2F32  AF536E02            ldbze REG_54,$026E[REG_52]
      54
2F37  AFFE0750            ldbze REG_50,$07[REG_FE]			; ROM $9E61 -  ENGCYL = Number of PIPs per engine revolution, or Number of cylinders/2
2F3B  6F51BE2F54          mulu  REG_54,$2FBE[REG_50]
2F40  6F51BE2F58          mulu  REG_58,$2FBE[REG_50]
2F45  0C0654              shrl  REG_54,#$06
2F48  0C0658              shrl  REG_58,#$06
2F4B  685458              sub   REG_58,REG_54
2F4E  B80056              subcb REG_56,Zero
2F51  D602                jge   L2F55
2F53  0358                neg   REG_58
2F55  A3FC2A5A      L2F55 ld    REG_5A,$2A[REG_FC]			; ROM $9AA8 -  NUMCYL = Number of cylinders.
2F59  09075A              shl   REG_5A,#$07
2F5C  88585A              cmp   REG_5A,REG_58
2F5F  DB04                jc    L2F65
2F61  0358                neg   REG_58
2F63  1556                decb  REG_56
2F65  89001058      L2F65 cmp   REG_58,#$1000
2F69  D104                jnh   L2F6F
2F6B  A1001058            ld    REG_58,#$1000
2F6F  305602        L2F6F jbc   REG_56,BIT_00,L2F74
2F72  0358                neg   REG_58
2F74  645458        L2F74 add   REG_58,REG_54
2F77  A351BE2F            ld    REG_50,$2FBE[REG_50]
      50
2F7C  080650              shr   REG_50,#$06
2F7F  015A                clr   REG_5A
2F81  8C5058              divu  REG_58,REG_50
2F84  C7536E02            stb   REG_58,$026E[REG_52]
      58
2F89  200E          L2F89 sjmp  L2F99
2F8B  342E0B        L2F8B jbc   REG_2E,BIT_04,L2F99
2F8E  C774F058            stb   REG_58,$F0[REG_74]
2F92  C774F158            stb   REG_58,$F1[REG_74]
2F96  91802E              orb   REG_2E,#$80
2F99  71F72E        L2F99 andb  REG_2E,#$F7
2F9C  B1025A              ldb   REG_5A,#$02
2F9F  9BFC335A            cmpb  REG_5A,$33[REG_FC]			; ROM $9AB1 -  OUTINJ = Calibration switch to select between sequential and simultaneous injections (OUTINJ = 1 for sequential, OUTINJ = 2 for simultaneous)
2FA3  DF03                je    L2FA8
2FA5  37A10B              jbc   REG_A1,BIT_07,L2FB3			; jump if not CRANKING
2FA8  91082E        L2FA8 orb   REG_2E,#$08
2FAB  C774EE00            stb   Zero,$EE[REG_74]
2FAF  C774EF00            stb   Zero,$EF[REG_74]
2FB3  880052        L2FB3 cmp   REG_52,Zero
2FB6  D709                jne   L2FC1
2FB8  AFFE1652            ldbze REG_52,$16[REG_FE]			; ROM $9E70 number_of_HEGOs
2FBC  315202              jbc   REG_52,BIT_01,L2FC1
2FBF  269C                sjmp  L2E5D						; loop

2FC1  F0            L2FC1 ret
;
;****
;
2FC2  0080                skip  REG_80
2FC4  805500              or    Zero,REG_55
2FC7  40

2FC8  BDFF56        L2FC8 ldbse REG_56,#$FF


2FCB  0756          L2FCB inc   REG_56
2FCD  B3576A0254          ldb   REG_54,$026A[REG_56]
2FD2  1554                decb  REG_54
2FD4  DF02                je    L2FD8
2FD6  20E2                sjmp  L30BA
2FD8  91202E        L2FD8 orb   REG_2E,#$20
2FDB  B301BE03            ldb   REG_54,$03BE[Zero]
      54
2FE0  37A119              jbc   REG_A1,BIT_07,L2FFC		; jump if not CRANKING
2FE3  9BFC3400            cmpb  Zero,$34[REG_FC]		; ROM $9AB2 - EDSEL = Switch for selective Crank Fuel Timing at Falling- Edge of PIP
2FE7  D705                jne   L2FEE
2FE9  309005              jbc   REG_90,BIT_00,L2FF1		; jmp if not PIP_HIGH
2FEC  2009                sjmp  L2FF7
2FEE  309006        L2FEE jbc   REG_90,BIT_00,L2FF7		; jmp if not PIP_HIGH
2FF1  B3FC3054      L2FF1 ldb   REG_54,$30[REG_FC]		; ROM $9AAE - CRKPIP = Number of PIPs between injector outputs during Crank
2FF5  2005                sjmp  L2FFC
2FF7  B10154        L2FF7 ldb   REG_54,#$01
2FFA  20BE                sjmp  L30BA
2FFC  3B2E35        L2FFC jbs   REG_2E,BIT_03,L3034
2FFF  AF576C02            ldbze REG_52,$026C[REG_56]
      52
3004  1752                incb  REG_52
3006  9BFC3252            cmpb  REG_52,$32[REG_FC]		; ROM $9AB0 - 8 - number of cylinders
300A  D302                jnc   L300E
300C  1152                clrb  REG_52
300E  C7576C0252    L300E stb   REG_52,$026C[REG_56]	; REG_52 is cylinder sequence #?
3013  45E301F45A          add   REG_5A,REG_F4,#$01E3	; TABLE $91B9 - Load Injector firing order (injector to fire vs .)
3018  64525A              add   REG_5A,REG_52			; ROM ptr to injector to fire from sequence number
301B  AE5A50              ldbze REG_50,[REG_5A]			; REG_50 is cylinder number
301E  45DA01F45A          add   REG_5A,REG_F4,#$01DA	; TABLE $91B0 - Injector Output Port(cylinder # to bank)
3023  64505A              add   REG_5A,REG_50			; Ptr to port from cylinder number
3026  B25A50              ldb   REG_50,[REG_5A]			; port to fire (0 or 2)
3029  385605              jbs   REG_56,BIT_00,L3031
302C  315005              jbc   REG_50,BIT_01,L3034		; test port - jmp on port = 0
302F  2089          L302F sjmp  L30BA
3031  3150FB        L3031 jbc   REG_50,BIT_01,L302F
3034  0152          L3034 clr   REG_52
3036  342E6C              jbc   REG_2E,BIT_04,L30A5
3039  AF576C02            ldbze REG_52,$026C[REG_56]
      52
303E  B3FC325A            ldb   REG_5A,$32[REG_FC]		; ROM $9AB0 - 8 - number of cylinders
3042  99025A              cmpb  REG_5A,#$02
3045  D70A                jne   L3051
3047  305207              jbc   REG_52,BIT_00,L3051
304A  AFFE0752            ldbze REG_52,$07[REG_FE]		; ROM $9E5A+7 = 9E61 value = $08=ENGCYL=Number of cylinders per engine revolution
304E  080152              shr   REG_52,#$01
3051  090552        L3051 shl   REG_52,#$05
3054  ACD150              ldbze REG_50,REG_D1
3057  685250              sub   REG_50,REG_52
305A  DB04                jc    L3060
305C  67FC2A50            add   REG_50,$2A[REG_FC]		; ROM $9AA8 NUMCYL = Number of cylinders in the engine
3060  AF576E0252    L3060 ldbze REG_52,$026E[REG_56]
3065  685052              sub   REG_52,REG_50
3068  DB04                jc    L306E
306A  67FC2A52            add   REG_52,$2A[REG_FC]		; ROM $9AA8 NUMCYL = Number of cylinders in the engine
306E  993052        L306E cmpb  REG_52,#$30
3071  D108                jnh   L307B
3073  750254              addb  REG_54,#$02
3076  B11852              ldb   REG_52,#$18
3079  202A                sjmp  L30A5
307B  385605        L307B jbs   REG_56,BIT_00,L3083
307E  91802F              orb   REG_2F,#$80
3081  2003                sjmp  L3086
3083  91402F        L3083 orb   REG_2F,#$40
3086  992052        L3086 cmpb  REG_52,#$20
3089  DB1A                jc    L30A5
308B  389002              jbs   REG_90,BIT_00,L3090		; jmp if PIP_HIGH
308E  1554                decb  REG_54
3090  991052        L3090 cmpb  REG_52,#$10
3093  DB10                jc    L30A5
3095  752052              addb  REG_52,#$20
3098  1554                decb  REG_54
309A  385605              jbs   REG_56,BIT_00,L30A2
309D  717F2F              andb  REG_2F,#$7F
30A0  2003                sjmp  L30A5
30A2  71BF2F        L30A2 andb  REG_2F,#$BF
30A5  C45952        L30A5 stb   REG_52,REG_59
30A8  91042E              orb   REG_2E,#$04
30AB  985400              cmpb  Zero,REG_54
30AE  DE03                jlt   L30B3
30B0  B10154              ldb   REG_54,#$01
30B3  C7576A0254    L30B3 stb   REG_54,$026A[REG_56]
30B8  2007                sjmp  L30C1

30BA  C7576A0254    L30BA stb   REG_54,$026A[REG_56]
30BF  20A4                sjmp  L3165

30C1  B3576C0258    L30C1 ldb   REG_58,$026C[REG_56]
30C6  C856          L30C6 push  REG_56
30C8  AF576C0254          ldbze REG_54,$026C[REG_56]
30CD  64F454              add   REG_54,REG_F4
30D0  B355E30154          ldb   REG_54,$01E3[REG_54]	; ROM $91B9 - FN1329 = Injector firing order used for correcting Inj_Fank to correct the firing order. Output = fuel  injector to  be fired. X-input = INJ_BANK Y-input = Null
30D5  352A0A              jbc   REG_2A,BIT_05,L30E2		; jump if normal strategy - not self test mode
30D8  9B749454            cmpb  REG_54,$94[REG_74]		; VCUTOUT?
30DC  D704                jne   L30E2
30DE  CC56                pop   REG_56
30E0  2083                sjmp  L3165
30E2  30E70A        L30E2 jbc   REG_E7,BIT_00,L30EF		; FOFFLG = Alternate injector fire enable flag; 1 = fire  alternate injectors
30E5  9502E7              xorb  REG_E7,#$02				; FGFFLG = Toggle flag for alternate Injector Firing, = 1 No firing on this injector
30E8  39E704              jbs   REG_E7,BIT_01,L30EF		; FGFFLG = Toggle flag for alternate Injector Firing, = 1 No firing on this injector
30EB  CC56                pop   REG_56
30ED  2076                sjmp  L3165
; cylinder # in REG_54
30EF  790154        L30EF subb  REG_54,#$01				; entry number - 1
30F2  5D165492            mulub REG_92,REG_54,#$16		; convert cylinder to 2284 table entry offset
30F6  65A62292            add   REG_92,#$22A6			; convert offset to entry pointer
; pick up cylinder # from 2284 entry
30FA  479208F454          add   REG_54,REG_F4,$08[REG_92]	; 8FDE + 0001, 0002, 0003 etc so 8FD7, 8FD8, 8FD9
                                                                
; REG_54 is cylinder number					; ROM 8FDE + 01DA=91B8=Map: Injector Output Port []
30FF  AF55DA0154          ldbze REG_54,$01DA[REG_54]	; load port # from cylinder #

3104  8B55060200          cmp   Zero,$0206[REG_54]		; ?PulseWidth - Injector Pulse Width in ms for REG_54 - port 0 or 2
      
3109  DF17                je    L3122
310B  32A108              jbc   REG_A1,BIT_02,L3116		; UNDSP = Run/Underspeed Flag.  (1 = Underspeed (or CRANK), 0 = Run)
310E  A08C80              ld    REG_80,REG_8C			; 24 bit time?
3111  B08E82              ldb   REG_82,REG_8E
3114  2008                sjmp  L311E
3116  2882          L3116 scall L319A
3118  A05080              ld    REG_80,REG_50			; 24 bit time?
311B  B05282              ldb   REG_82,REG_52
311E  28A4          L311E scall L31C4
3120  2010                sjmp  L3132
3122  AF92057E      L3122 ldbze REG_7E,$05[REG_92]		; $02C5 table???
3126  65C5027E            add   REG_7E,#$02C5
312A  C37EFE8C            st    REG_8C,$FE[REG_7E]		; 24 bit time? - set time for this injector to fire
312E  C77EFD8E            stb   REG_8E,$FD[REG_7E]

3132  CC56          L3132 pop   REG_56
3134  71DF2E              andb  REG_2E,#$DF
3137  332E2B              jbc   REG_2E,BIT_03,L3165
313A  B3576C02            ldb   REG_54,$026C[REG_56]	; 2C5 table?
      54
313F  1754                incb  REG_54
3141  9BFC3254            cmpb  REG_54,$32[REG_FC]		; ROM $9AB0 - 8 - number of cylinders
3145  D302                jnc   L3149
3147  1154                clrb  REG_54					; wrap cylinder count
3149  C7576C0254    L3149 stb   REG_54,$026C[REG_56]
314E  30540A              jbc   REG_54,BIT_00,L315B

; tickle both watchdogs
3151  954002              xorb  Low_Speed_Output,#$40	; change LSO bit 6 - tickle CPU OK
3154  1705                incb  Watchdog_Timer
3156  1705                incb  Watchdog_Timer			; do two of these really do any good? Special delay?
3158  954002              xorb  Low_Speed_Output,#$40	; change LSO bit 6 - tickle CPU OK

315B  985458        L315B cmpb  REG_58,REG_54
315E  DF05                je    L3165
3160  91202E              orb   REG_2E,#$20				; SYNFLG = Flag indicating synchronous fuel, if set = 1; asynchronous if set = 0 It is initialized to 0.
3163  2761                sjmp  L30C6					; LOOP

3165  322E05        L3165 jbc   REG_2E,BIT_02,L316D		; NEW_IBETA
3168  C7577002            stb   REG_59,$0270[REG_56]	; IBETA1 - IBETA2 table
      59
316D  71DB2E        L316D andb  REG_2E,#$DB
3170  3B2E0E              jbs   REG_2E,BIT_03,L3181
3173  B3FE1650            ldb   REG_50,$16[REG_FE]		; ROM $9E70 number_of_HEGOs
3177  38500F              jbs   REG_50,BIT_00,L3189
317A  38560C              jbs   REG_56,BIT_00,L3189
317D  264C                sjmp  L2FCB					; LOOP

317F  2008                sjmp  L3189					; how does execution get here?
3181  B374EC50      L3181 ldb   REG_50,$EC[REG_74]
3185  C774ED50            stb   REG_50,$ED[REG_74]
3189  F0            L3189 ret

318A  B3920754      L318A ldb   REG_54,$07[REG_92]		; $02C5 table ???
318E  73721254            andb  REG_54,$12[REG_72]
3192  C7721254            stb   REG_54,$12[REG_72]
3196  71EF4F              andb  REG_4F,#$EF				; REG_4F bit 4 - clear PENDING
3199  F0                  ret
;
;**********************************************************************
;
319A  A3920850      L319A ld    REG_50,$08[REG_92]		; 22 byte entry pointer? field 0001, 0002, 0003,...
319E  45DA01F45A          add   REG_5A,REG_F4,#$01DA	; TABLE $91B0 - Injector Output Port(cylinder to bank#)
31A3  64505A              add   REG_5A,REG_50			; $92B0 + cylinder #
31A6  AE5A50              ldbze REG_50,[REG_5A]			; load port (0 or 2) from ROM table
31A9  315002              jbc   REG_50,BIT_01,L31AE		; jmp if port == 0 (not 2)
31AC  1550                decb  REG_50					; change port 2 into 1
31AE  B351700251    L31AE ldb   REG_51,$0270[REG_50]	; byte from ?table indexed by port 0 or 1
31B3  1150                clrb  REG_50
31B5  6CBA50              mulu  REG_50,REG_BA			; REG_BA - PIP time lo 16 bits
31B8  0C0D50              shrl  REG_50,#$0D				; R50 = R50 * 8192
31BB  67745050            add   REG_50,$50[REG_74]		; $50[REG_74] - last saved PIP IO event time lo 16 bits
31BF  B7745252            addcb REG_52,$52[REG_74]		; $52[REG_74] - last saved PIP IO event time hi 8 bits
31C3  F0                  ret
;
;**********************************************************************
;
31C4  71F72D        L31C4 andb  REG_2D,#$F7				; NO_FUEL_SAVE
31C7  AF92057E            ldbze REG_7E,$05[REG_92]		; offset into $02C5 scheduling table
31CB  65C5027E            add   REG_7E,#$02C5
31CF  352E0C              jbc   REG_2E,BIT_05,L31DE		; BASE_FUEL
31D2  B3920650            ldb   REG_50,$06[REG_92]		; inj timer entry - bit mask for setting
31D6  93721050            orb   REG_50,$10[REG_72]		; INJ_BASE
31DA  C7721050            stb   REG_50,$10[REG_72]		; INJ_BASE
31DE  B3920750      L31DE ldb   REG_50,$07[REG_92]		; inj timer entry - bit mask for clearing
31E2  73721150            andb  REG_50,$11[REG_72]		; INJ_PIP = ?? = Counter which counts the number of PIPs between injections??
31E6  C7721150            stb   REG_50,$11[REG_72]		; INJ_PIP = ?? = Counter which counts the number of PIPs between injections??
31EA  A12A0050            ld    REG_50,#$002A
31EE  43920A4400          and   Zero,REG_44,$0A[REG_92]	; INJ1_STATE : inj timer entry - bit mask
31F3  DF42                je    L3237
31F5  677E0250            add   REG_50,$02[REG_7E]
31F9  B37E0452            ldb   REG_52,$04[REG_7E]
31FD  B40052              addcb REG_52,Zero
3200  885080              cmp   REG_80,REG_50
3203  B08286              ldb   REG_86,REG_82
3206  B85286              subcb REG_86,REG_52
3209  37861E              jbc   REG_86,BIT_07,L322A
320C  352E0B              jbc   REG_2E,BIT_05,L321A		; BASE_FUEL
320F  91082D              orb   REG_2D,#$08				; set NO_FUEL_SAVE flag
3212  C37EFE80            st    REG_80,$FE[REG_7E]		; schedule event time Lo 16
3216  C77EFD82            stb   REG_82,$FD[REG_7E]		; schedule event time Hi 8
321A  A37E0280      L321A ld    REG_80,$02[REG_7E]
321E  B37E0482            ldb   REG_82,$04[REG_7E]
3222  28A9                scall L32CD
3224  71F72D              andb  REG_2D,#$F7				; clear NO_FUEL_SAVE flag
3227  E733F2              ljmp  L245D					; schedule a routine for execution in 2284/2C5 table

322A  B3920650      L322A ldb   REG_50,$06[REG_92]
322E  93721250            orb   REG_50,$12[REG_72]
3232  C7721250            stb   REG_50,$12[REG_72]
3236  F0                  ret

3237  677EFE50      L3237 add   REG_50,$FE[REG_7E]
323B  B37EFD52            ldb   REG_52,$FD[REG_7E]
323F  B40052              addcb REG_52,Zero
3242  885080              cmp   REG_80,REG_50
3245  B08286              ldb   REG_86,REG_82
3248  B85286              subcb REG_86,REG_52
324B  378606              jbc   REG_86,BIT_07,L3254
324E  A05080              ld    REG_80,REG_50
3251  B05282              ldb   REG_82,REG_52
3254  114C          L3254 clrb  REG_4C
3256  739207E0            andb  REG_E0,$07[REG_92]

; top of loop
325A  EF60F1        L325A lcall L23BD					; send HSO command ands lots of other stuff
325D  344F02              jbc   REG_4F,BIT_04,L3262		; pending flag
3260  2F28                scall L318A					; ???
3262  364C01        L3262 jbc   REG_4C,BIT_06,L3266		; QUEUED flag
3265  F0                  ret							; exit

3266  2865          L3266 scall L32CD					; 
3268  67720E80            add   REG_80,$0E[REG_72]		; PWOFF = Injector pulsewidth offset (clock ticks)
326C  B40082              addcb REG_82,Zero
326F  650C0092            add   REG_92,#$000C			; change to *off* side of inj pulse entry ???
3273  B3920654            ldb   REG_54,$06[REG_92]
3277  73721254            andb  REG_54,$12[REG_72]		; INJ_PENDING
327B  DF29                je    L32A6
327D  91104F              orb   REG_4F,#$10				; set PENDING flag
3280  2F18                scall L319A					; ???
3282  73721154            andb  REG_54,$11[REG_72]		; INJ_PIP = ?? = Counter which counts the number of PIPs between injections??
3286  DF06                je    L328E
3288  68BA50              sub   REG_50,REG_BA			; REG_BA - PIP time lo 16 bits
328B  B80052              subcb REG_52,Zero
328E  452A008084    L328E add   REG_84,REG_80,#$002A
3293  B08286              ldb   REG_86,REG_82
3296  B40086              addcb REG_86,Zero
3299  885084              cmp   REG_84,REG_50
329C  B85286              subcb REG_86,REG_52
329F  3F8604              jbs   REG_86,BIT_07,L32A6
32A2  2829                scall L32CD					; ???
32A4  2EE4                scall L318A					; ???
32A6  EF14F1        L32A6 lcall L23BD					; send HSO command ands lots of other stuff
32A9  364C04              jbc   REG_4C,BIT_06,L32B0		; QUEUED
32AC  71EF4F              andb  REG_4F,#$EF				; clr PENDING flag
32AF  F0                  ret							; exit

32B0  C37EFE80      L32B0 st    REG_80,$FE[REG_7E]
32B4  C77EFD82            stb   REG_82,$FD[REG_7E]
32B8  344F0C              jbc   REG_4F,BIT_04,L32C7
32BB  A05080              ld    REG_80,REG_50
32BE  B05282              ldb   REG_82,REG_52
32C1  690C0092            sub   REG_92,#$000C			; change back to *on* side of inj pulse entry ???
32C5  2793                sjmp  L325A					; LOOP

32C7  077E          L32C7 inc   REG_7E
32C9  C67E00              stb   Zero,[REG_7E]
32CC  F0                  ret
;
;*********************************************************
; REG_92 is pointer to injector timer queue entry
;*********************************************************
;
32CD  0154          L32CD clr   REG_54						; default pulsewidth = 0 msecs
32CF  A3920856            ld    REG_56,$08[REG_92]			; 0001, 0002, 0003 etc CYLINDER NUMBER from queue entry
32D3  45DA01F45A          add   REG_5A,REG_F4,#$01DA		; TABLE $91B0 - Injector Output Port(cylinder to bank)
32D8  64565A              add   REG_5A,REG_56				; ptr to EGO bank for this cylinder
32DB  AE5A50              ldbze REG_50,[REG_5A]				; REG_50 = load port 0 or 2 for this cylinder

32DE  B3920656            ldb   REG_56,$06[REG_92]			; setting mask in queue entry
32E2  73721056            andb  REG_56,$10[REG_72]			; $0190 - INJ_BASE
32E6  DF18                je    L3300						; jmp for zero pulsewidth

32E8  97721056            xorb  REG_56,$10[REG_72]			; $0190 - INJ_BASE
32EC  C7721056            stb   REG_56,$10[REG_72]			; $0190 - INJ_BASE
32F0  3B2D08              jbs   REG_2D,BIT_03,L32FB			; NO_FUEL_SAVE - ???

32F3  C37EFE80            st    REG_80,$FE[REG_7E]			; 24 bit time for ???
32F7  C77EFD82            stb   REG_82,$FD[REG_7E]			; R7E=02E0

32FB  A351060254    L32FB ld    REG_54,$0206[REG_50]		; ** PulseWidth ** - Injector Pulse Width in ms for REG_50 - port 0 or 2

; Update total fuel consumption for DOL
3300  0156          L3300 clr   REG_56
3302  0D0154              shll  REG_54,#$01					; PulseWidth * 2
3305  645480              add   REG_80,REG_54				; add PulseWidth * 2
3308  B45682              addcb REG_82,REG_56
330B  65960150            add   REG_50,#$0196				; add port 0 or 2 to $196 = LBMF_INJ1
330F  A25050              ld    REG_50,[REG_50]
3312  A3920854            ld    REG_54,$08[REG_92]			; 0001, 0002, 0003 etc CYLINDER NUMBER from queue entry
3316  090154              shl   REG_54,#$01
3319  65980154            add   REG_54,#$0198				; add port 0 or 2 to $196 = LBMF_INJ1
331D  C25450              st    REG_50,[REG_54]
3320  0152                clr   REG_52
3322  6774CC50            add   REG_50,$CC[REG_74]			; $024A - Fuel Sum Low for DOL since last sum period start
3326  B774CE52            addcb REG_52,$CE[REG_74]			; $024C - Fuel Sum High for DOL since last sum period start
332A  D506                jnv   L3332
332C  BDFF50              ldbse REG_50,#$FF					; clamp overflow
332F  B17F52              ldb   REG_52,#$7F
3332  C374CC50      L3332 st    REG_50,$CC[REG_74]			; $024A - Fuel Sum Low for DOL since last sum period start
3336  C774CE52            stb   REG_52,$CE[REG_74]			; $024C - Fuel Sum High for DOL since last sum period start
333A  717F4C              andb  REG_4C,#$7F					; clear NO_QUEUE
333D  F0                  ret
;
;*********************************************************

333E  717F48        L333E andb  REG_48,#$7F					; clear CHANGE_FUELPW
3341  1156                clrb  REG_56
3343  A19C2292            ld    REG_92,#$229C				; $22A6 - $000A - 92 start value ??????????????????
3347  B3FC3257            ldb   REG_57,$32[REG_FC]			; ROM $9AB0 - 8 - NUMOUT = Number of injector output ports
334B  985657        L334B cmpb  REG_57,REG_56
334E  D902                jh    L3352
3350  208E                sjmp  L33E0						; exit

3352  65160092      L3352 add   REG_92,#$0016				; incr to next timer table entry (size = 22 bytes)
3356  1756                incb  REG_56
3358  4392FE4400          and   Zero,REG_44,$FE[REG_92]
335D  DFEC                je    L334B
335F  539206E050          andb  REG_50,REG_E0,$06[REG_92]	; bit mask for setting? and INJ_MODE?
3364  985000              cmpb  Zero,REG_50
3367  D71B                jne   L3384

3369  A3920854            ld    REG_54,$08[REG_92]			; inj timer table entry REG_92 offset 8 is cylinder number
336D  45DA01F45A          add   REG_5A,REG_F4,#$01DA		; TABLE $91B0 - Injector Output Port(Inj port 0/2 from cyl#)				
3372  64545A              add   REG_5A,REG_54				; REG_5A may be a pointer to the bank # for entry REG_92 cyl
3375  AE5A50              ldbze REG_50,[REG_5A]				; bank to fire for this cylinder
3378  A05054              ld    REG_54,REG_50
337B  65060250            add   REG_50,#$0206				; two entry table FUELPW pulse width for port 0(port 2 @ $0208)
337F  A25050              ld    REG_50,[REG_50]				; lookup what?
3382  2002                sjmp  L3386

3384  0150          L3384 clr   REG_50

3386  0152          L3386 clr   REG_52
3388  0D0150              shll  REG_50,#$01
338B  AF92057E            ldbze REG_7E,$05[REG_92]			; offset into $02C5 scheduling table
338F  67720E50            add   REG_50,$0E[REG_72]			; PWOFF = Injector pulsewidth offset (clock ticks)
3393  B40052              addcb REG_52,Zero
3396  477FC3025080        add   REG_80,REG_50,$02C3[REG_7E]	; schedule event time Lo 16
339C  B37FC20282          ldb   REG_82,$02C2[REG_7E]		; schedule event time Hi 8
33A1  B45282              addcb REG_82,REG_52
33A4  A3920850            ld    REG_50,$08[REG_92]			; inj timer table entry REG_92 offset 8 is cylinder number
33A8  090150              shl   REG_50,#$01
33AB  65980150            add   REG_50,#$0198				; LBMF_INJ2
33AF  65960154            add   REG_54,#$0196				; LBMF_INJ1
33B3  A25454              ld    REG_54,[REG_54]
33B6  1152                clrb  REG_52
33B8  4A50545A            sub   REG_5A,REG_54,[REG_50]
33BC  C25054              st    REG_54,[REG_50]
33BF  B80052              subcb REG_52,Zero
33C2  6774CC5A            add   REG_5A,$CC[REG_74]			; $024A - Fuel Sum Low for DOL since last sum period start
33C6  B774CE52            addcb REG_52,$CE[REG_74]			; $024C - Fuel Sum High for DOL since last sum period start
33CA  D506                jnv   L33D2
33CC  B17F52              ldb   REG_52,#$7F					; clamp add overflow
33CF  BDFF5A              ldbse REG_5A,#$FF
33D2  C374CC5A      L33D2 st    REG_5A,$CC[REG_74]			; $024A - Fuel Sum Low for DOL since last sum period start
33D6  C774CE52            stb   REG_52,$CE[REG_74]			; $024C - Fuel Sum High for DOL since last sum period start
33DA  C94B33              push  #$334B
33DD  E77DF0              ljmp  L245D						; schedule a routine for execution in 2284/2C5 table
33E0  F0            L33E0 ret
;
;****************************************************************
; update low seed controls - EGR, MIL/STO output, SCCS, CP, Idle Speed(ISC)
;
33E1  B10604        L33E1 ldb   AD_Command,#$06			; request AD channel 6 conversion
; EGR stuff
33E4  71FB46              andb  REG_46,#$FB				; LSO output line 2 OFF (EGR vacuum regulator)
33E7  9800D3              cmpb  REG_D3,Zero
33EA  DF2B                je    L3417					; EGR stuff done
33EC  B374A652            ldb   REG_52,$A6[REG_74]		; EGRPER
33F0  B374A554            ldb   REG_54,$A5[REG_74]		; EGRCNT
33F4  991052              cmpb  REG_52,#$10
33F7  DB08                jc    L3401
33F9  7774A452            addb  REG_52,$A4[REG_74]		; EGRPER
33FD  B374A354            ldb   REG_54,$A3[REG_74]		; EGRCNT
3401  980054        L3401 cmpb  REG_54,Zero
3404  DF06                je    L340C
3406  910446              orb   REG_46,#$04				; LSO output line 2 ON (EGR vacuum regulator)
3409  790854              subb  REG_54,#$08
340C  791052        L340C subb  REG_52,#$10
340F  C774A652            stb   REG_52,$A6[REG_74]		; EGRPER
3413  C774A554            stb   REG_54,$A5[REG_74]		; EGRcnt

; Idle speed control
3417  71F746        L3417 andb  REG_46,#$F7				; LSO output line 3 OFF (Idle Speed Control-bypass air)
341A  4400B850            add   REG_50,REG_B8,Zero		; REG_B8 ISCDTY
341E  DF0D                je    L342D
3420  7851B7              subb  REG_B7,REG_51			; add to REG_B7(IFREQ) Reg_51=???
3423  DB0A                jc    L342F
3425  7580B7              addb  REG_B7,#$80				; sub to REG_B7
3428  910846              orb   REG_46,#$08				; LSO output line 3 ON (Idle Speed Control-bypass air)
342B  2002                sjmp  L342F
342D  11B7          L342D clrb  REG_B7					; REG_B7 is just right

; DOL update
342F  890100C6      L342F cmp   REG_C6,#$0001			; Data Output Link count??? Fuel calc ???
3433  D107                jnh   L343C					; jump if DOL count <= 1
3435  05C6                dec   REG_C6					; decr DOL count
3437  950246              xorb  REG_46,#$02				; LSO output line 1 TOGGLE (Data Output Link)Signal bit change?
343A  2004                sjmp  L3440
343C  A10100C6      L343C ld    REG_C6,#$0001			; set DOL count

; STO update
3440  33D66E        L3440 jbc   REG_D6,BIT_03,L34B1		; STO flag?
3443  30D80B              jbc   REG_D8,BIT_00,L3451		; STO holdoff?
3446  9110D8              orb   REG_D8,#$10				; STO pending
3449  717F08              andb  Interrupt_Mask,#$7F		; int mask clr interrupt for HSI line 0 (PIP?)
344C  71FED8              andb  REG_D8,#$FE				; clr STO holdoff?
344F  20DD                sjmp  L352E					; jump past STO stuff

3451  34D815        L3451 jbc   REG_D8,BIT_04,L3469		; jmp if no STO pending
3454  71EFD8              andb  REG_D8,#$EF				; clr STO pending
3457  918008              orb   Interrupt_Mask,#$80		; int mask for HSI line 0 (PIP?)
345A  B3761056            ldb   REG_56,$10[REG_76]		; STO shift count (leftmost 1 bit at start)
345E  E05643              djnz  REG_56,L34A4			; decr output bit count and jmp if some bits left to output
3461  71F7D6              andb  REG_D6,#$F7				; clr REG_D6 bit 3 STO working
3464  3A2B4D              jbs   REG_2B,BIT_02,L34B4		; jump if Self Test Output trigger set - to turn off STO
3467  20BE                sjmp  L3527

3469  488C0684      L3469 sub   REG_84,Master_IO_Timer_Lo,REG_8C ; update master reference time, difference in R84
346D  64848C              add   REG_8C,REG_84
3470  B4008E              addcb REG_8E,Zero				; REG_8C/8D/8E is 24 bit master reference time

3473  B08E54              ldb   REG_54,REG_8E			; Hi 8 bits of current time
3476  B3760F55            ldb   REG_55,$0F[REG_76]		; STO high time
347A  B05556              ldb   REG_56,REG_55			; STO high time
347D  488CDA50            sub   REG_50,REG_DA,REG_8C	; current master time - REG_DA(STO time)
3481  B85456              subcb REG_56,REG_54			; R56 = STO time - current time (hi bytes)
3484  D71C                jne   L34A2
3486  89E30450            cmp   REG_50,#$04E3
348A  D916                jh    L34A2					; jump if time remaining till STO > $04E3
; we are very close to STO bit time end
348C  44508C0E            add   HSO_Time_Hold,REG_8C,REG_50	; set HSO time
3490  B12A0D              ldb   HSO_Command_Hold,#$2A		; set HSO command to $2A

3493  67760ADA            add   REG_DA,$0A[REG_76]		; IO time for each trouble code bit at selected output speed
3497  B7760E55            addcb REG_55,$0E[REG_76]		; IO time for each trouble code bit at selected output speed
349B  C7760F55            stb   REG_55,$0F[REG_76]		; STO high 8 bits time
349F  9101D8              orb   REG_D8,#$01				; set bit 0 of REG_D8 flag STO_HOLDOFF (time to change to next bit???)

34A2  208A          L34A2 sjmp  L352E

; we are still shifting out error code
34A4  C7761056      L34A4 stb   REG_56,$10[REG_76]		; bits remaining to be output
34A8  A3760C52            ld    REG_52,$0C[REG_76]		; STO_SHIFT - shifted trouble code
34AC  080152              shr   REG_52,#$01				; next output bit??? RIGHT SHIFT??? SB left shift!
34AF  2070                sjmp  L3521					; set STO hi/lo based on REG_52 bit 0

; handle STO/MIL lamp trouble codes output

34B1  322B7A        L34B1 jbc   REG_2B,BIT_02,L352E		; jump over STO if Self Test Output trigger clr
34B4  3DD611        L34B4 jbs   REG_D6,BIT_05,L34C8		; jump if bit to output is set (STO_CODE)
; off bit
34B7  0152                clr   REG_52					; flag to select STO off - REG_52 = 0 - sets STO off
34B9  37D602              jbc   REG_D6,BIT_07,L34BE		; jump if STO ON
34BC  0752                inc   REG_52					; REG_52 = $01 - sets STO on
34BE  36D602        L34BE jbc   REG_D6,BIT_06,L34C3		; jump if STO OFF
34C1  0152                clr   REG_52					; REG_52 = 0 - sets STO off
34C3  713FD6        L34C3 andb  REG_D6,#$3F				; clear STO on and OFF
34C6  2056                sjmp  L351E					; jmp to set STO line hi/lo
; on bit
34C8  71DFD6        L34C8 andb  REG_D6,#$DF				; clear REG_D6 bit 5 STO_CODE
34CB  9108D6              orb   REG_D6,#$08				; set REG_D6 bit 3 working
34CE  A0D452              ld    REG_52,REG_D4		<<<<<<<<; Self Test Trouble code
34D1  B11056              ldb   REG_56,#$10				; 16 bit trouble code?
34D4  31D90D              jbc   REG_D9,BIT_01,L34E4		; jmp if GOOSE???
34D7  71FDD9              andb  REG_D9,#$FD				; clear REG_D9 bit 1 GOOSE???

; strip off leading zero bits in trouble code REG_D4
34DA  0901D4        L34DA shl   REG_D4,#$01				; REG_D4 << 1 next bit of trouble code
34DD  DB03                jc    L34E2					; leftmost 1 bit just shifted out
34DF  E056F8              djnz  REG_56,L34DA			; decr 16 bit count of left most 1 bit

34E2  1756          L34E2 incb  REG_56					; 'backup' to leftmost one bit
34E4  C7761056      L34E4 stb   REG_56,$10[REG_76]		; trouble code bit position (bit position of first != 0 bit)

; select MIL lamp interval time in REG_50 and REG_54
34E8  A1CD2D50            ld    REG_50,#$2DCD			; STO slow time
34EC  B10354              ldb   REG_54,#$03				; hi 8 bits of slow time
34EF  34D606              jbc   REG_D6,BIT_04,L34F8		; STO fast flag

34F2  A1230850            ld    REG_50,#$0823			; STO fast time
34F6  1154                clrb  REG_54					; hi 8 bits of fast time
34F8  342C06        L34F8 jbc   REG_2C,BIT_04,L3501		; STO very fast flag

34FB  A1410350            ld    REG_50,#$0341			; STO very fast time
34FF  1154                clrb  REG_54					; hi 8 bits of very fast time

3501  488C0684      L3501 sub   REG_84,Master_IO_Timer_Lo,REG_8C ; update master reference time, difference in R84
3505  64848C              add   REG_8C,REG_84
3508  B4008E              addcb REG_8E,Zero				; REG_8C/8D/8E is 24 bit master reference time

350B  C3760A50            st    REG_50,$0A[REG_76]		; $0384 STO timer value lo 16 bits
350F  C7760E54            stb   REG_54,$0E[REG_76]		; $0388 STO timer value hi 8 bits
; compute time to change STO
3513  44508CDA            add   REG_DA,REG_8C,REG_50	; REG_DA is lo 16 time for this next bit
3517  B48E54              addcb REG_54,REG_8E
351A  C7760F54            stb   REG_54,$0F[REG_76]		; $0F[REG_76] is hi 8 time for this next bit

351E  71FB2B        L351E andb  REG_2B,#$FB				; clear Self Test Output trigger - allow next bit to queue up
; 
3521  912046        L3521 orb   REG_46,#$20		<<<<<<<<; LSO output line 5 (STO) ON (MIL)
3524  385203              jbs   REG_52,BIT_00,L352A		; test bit zero of trouble code flg
3527  71DF46        L3527 andb  REG_46,#$DF		<<<<<<<<; LSO output line 5 (STO) OFF (MIL)

352A  C3760C52      L352A st    REG_52,$0C[REG_76]		; STO_SHIFT leave this STO bit outputing for this amt of time


352E  71DF2F        L352E andb  REG_2F,#$DF
3531  3FA10D              jbs   REG_A1,BIT_07,L3541		; jump if CRANKING
3534  370903              jbc   Interrupt_Pending,BIT_07,L353A	; int pending test
3537  380B07              jbs   HSI_Sample,BIT_00,L3541	; HSI bit 0 - PIP
353A  A3740652      L353A ld    REG_52,$06[REG_74]		; we get here if there is no PIP interrupt pending?
353E  EFE8F7              lcall L2D29					; call ?

; Speed control system (SCCS)
3541  E09B2B        L3541 djnz  REG_9B,L356F			; SCCS Count
3544  33C40C              jbc   REG_C4,BIT_03,L3553
3547  B3743A9B            ldb   REG_9B,$3A[REG_74]
354B  71FE46              andb  REG_46,#$FE				; LSO output line 0 OFF (Speed Control Vacuum)
354E  911046              orb   REG_46,#$10				; LSO output line 4 ON (Speed Control Vent)
3551  200F                sjmp  L3562
3553  B3743B9B      L3553 ldb   REG_9B,$3B[REG_74]

3557  36C405        L3557 jbc   REG_C4,BIT_06,L355F		; SCCS vacuum active
355A  950146              xorb  REG_46,#$01				; LSO output line 0 TOGGLE (Speed Control Vacuum)
355D  2003                sjmp  L3562
355F  951046        L355F xorb  REG_46,#$10				; LSO output line 4 TOGGLE (Speed Control Vent)

3562  9508C4        L3562 xorb  REG_C4,#$08				; ???
3565  989B00              cmpb  Zero,REG_9B				; SCCS Count
3568  D705                jne   L356F
356A  B10A9B              ldb   REG_9B,#$0A				; SCCS Count
356D  27E8                sjmp  L3557					; LOOP

; canister purge timing (CP)
356F  71FD47        L356F andb  REG_47,#$FD				; output line 1 OFF (canister purge)
3572  5B72AB8D50          subb  REG_50,REG_8D,$AB[REG_72]	; $12B canister purge start period
3577  9B72AD50            cmpb  REG_50,$AD[REG_72]		; $12D canister purge on time
357B  D30D                jnc   L358A
357D  9B72AE50            cmpb  REG_50,$AE[REG_72]		; $12E canister purge period
3581  D30A                jnc   L358D
3583  C772AB8D            stb   REG_8D,$AB[REG_72]		; $12B canister purge start period
3587  36E903              jbc   REG_E9,BIT_06,L358D		; jump if canister purge enabled clear
358A  910247        L358A orb   REG_47,#$02				; output line 1 ON (canister purge)
358D  E764F0        L358D ljmp  L25F4
;
;********************************************************
; handle HSI line 2 data MAP (BP)s
;********************************************************
;
3590  71FB87        L3590 andb  REG_87,#$FB				; this data is not used in this routine - calling routine?

3593  4B74027A50          sub   REG_50,REG_7A,$02[REG_74] ; time of last read
3598  C3728A50            st    REG_50,$8A[REG_72]		; delta time since last BP read
359C  C374027A            st    REG_7A,$02[REG_74]		; update last time read

35A0  B0B650              ldb   REG_50,REG_B6			; incr input count in REG_B6
35A3  1750                incb  REG_50					; why not just incb REG_B6?
35A5  C4B650              stb   REG_50,REG_B6

35A8  91404E              orb   REG_4E,#$40				; new BP pulse recieved
35AB  F0                  ret
;
;********************************************************
; Interpolate data table var size = byte
; works for any size table with a single independent var
; handles 8 bit signed and unsigned tables
;********************************************************
;
35AC  9120EE        L35AC orb   REG_EE,#$20				; set only bit 5(signed input var)
35AF  2006                sjmp  L35B7
;
; REG_32 - points to table
; REG_34 - independent variable - ECT
; result in REG_38
;
35B1  9120EE        L35B1 orb   REG_EE,#$20				; set bit 5 - signed dependent var(signed input var)
;********************************************************
35B4  9110EE        L35B4 orb   REG_EE,#$10				; set bit 4 - signed independent var(signed output var)

;********************************************************
35B7  9B320234      L35B7 cmpb  REG_34,$02[REG_32]	; find temp in table temp
35BB  3DEE04              jbs   REG_EE,BIT_05,L35C2	; test bit flag
35BE  DB0A                jc    L35CA
35C0  2002                sjmp  L35C4
35C2  D606          L35C2 jge   L35CA
35C4  65020032      L35C4 add   REG_32,#$0002
35C8  27ED                sjmp  L35B7

35CA  71DFEE        L35CA andb  REG_EE,#$DF			; (mask flag bit 5) pull out advance above and below temp and interpolate
35CD  B23336              ldb   REG_36,[REG_32]+
35D0  B23338              ldb   REG_38,[REG_32]+
35D3  7A3236              subb  REG_36,[REG_32]
35D6  7A3334              subb  REG_34,[REG_32]+
35D9  7A3238              subb  REG_38,[REG_32]
35DC  3CEE04              jbs   REG_EE,BIT_04,L35E3	; test flag bit 4
35DF  DB09                jc    L35EA
35E1  2002                sjmp  L35E5
35E3  D605          L35E3 jge   L35EA
35E5  9120EE        L35E5 orb   REG_EE,#$20
35E8  1338                negb  REG_38
35EA  7C3438        L35EA mulub REG_38,REG_34
35ED  9C3638              divub REG_38,REG_36
35F0  35EE02              jbc   REG_EE,BIT_05,L35F5	; test flag bit 5
35F3  1338                negb  REG_38
35F5  763238        L35F5 addb  REG_38,[REG_32]		; add interpolate delta to base
35F8  1139                clrb  REG_39
35FA  71DFEE              andb  REG_EE,#$DF			; clear bit 5
35FD  71EFEE              andb  REG_EE,#$EF			; clear bit 4
3600  F0                  ret
                    ;*
                    ;************************************************************
                    ;* routine ???
                    ;************************************************************
3601  9120EE        L3601 orb   REG_EE,#$20	; signed input ?
3604  2006                sjmp  L360C
                    ;************************************************************
                    ;* routine ???
                    ;************************************************************
3606  9120EE        L3606 orb   REG_EE,#$20	; signed input ?
3609  9110EE              orb   REG_EE,#$10	; signed output ?
                    ;************************************************************
                    ;* Table interpolation routine
                    ;
					; for 16 bit data
                    ; input REG_32
                    ; indep var REG_34
                    ; result in REG_38 word
                    ;************************************************************
360C  8B320434      L360C cmp   REG_34,$04[REG_32]
3610  3DEE04              jbs   REG_EE,BIT_05,L3617
3613  DB0A                jc    L361F
3615  2002                sjmp  L3619
3617  D606          L3617 jge   L361F
3619  65040032      L3619 add   REG_32,#$0004
361D  27ED                sjmp  L360C

361F  71DFEE        L361F andb  REG_EE,#$DF
3622  A23336              ld    REG_36,[REG_32]+
3625  A23338              ld    REG_38,[REG_32]+
3628  6A3236              sub   REG_36,[REG_32]
362B  6A3334              sub   REG_34,[REG_32]+
362E  6A3238              sub   REG_38,[REG_32]
3631  3CEE04              jbs   REG_EE,BIT_04,L3638
3634  DB09                jc    L363F
3636  2002                sjmp  L363A
3638  D605          L3638 jge   L363F
363A  9120EE        L363A orb   REG_EE,#$20
363D  0338                neg   REG_38
363F  6C3438        L363F mulu  REG_38,REG_34
3642  8C3638              divu  REG_38,REG_36
3645  35EE02              jbc   REG_EE,BIT_05,L364A
3648  0338                neg   REG_38
364A  663238        L364A add   REG_38,[REG_32]
364D  71DFEE              andb  REG_EE,#$DF
3650  71EFEE              andb  REG_EE,#$EF
3653  F0                  ret
                    ;*
                    ;************************************************************
                    ;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                    ;          
                    ; Filter AD (sensor) value
                    ; 
                    ;*  routine
                    ;*    loads  $32, $34, $36   from 3 parameters passed
                    ;
                    ;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                    ;************************************************************
3654  283F          L3654 scall L3695
3656  A23C32              ld    REG_32,[REG_3C]		; this is the OLD AD sensor value
3659  283A                scall L3695
365B  A23C34              ld    REG_34,[REG_3C]		; this is the NEW AD sensor value
                ; entry point
365E  2835          L365E scall L3695
3660  A23C36              ld    REG_36,[REG_3C]		; REG_3C is address of filter value 
; entry point for filtering
; REG_32 is OLD AD sensor value
; REG_34 is new AD sensor value
; REG_36 is manged filtering factor
3663  2853          L3663 scall L36B8				; GET FILTERING VALUE
3665  B10242        L3665 ldb   REG_42,#$02
3668  2004                sjmp  L366E
                ; entry point
		; INPUTS:
		; R32 - old AD value (final(tablelookup)form)
		; R34 - new AD value
		; R36 - ROM funny format value used to scale difference
		; 
		; OUTPUTS:
		; R3E - output in final form (suitable for table lookup)
366A  284C          L366A scall L36B8			; GET FILTERING VALUE - divs funny ROM value ???? result in R36
366C  1142                clrb  REG_42			; new value is unsigned flag?
;
; Update sensor value R32 with new value R34 by scaling the difference with a funny ROM value R36
;
366E  4832343C      L366E sub   REG_3C,REG_34,REG_32 ; CALC DIFFERENCE - R32 is old sensor value ie RB0 for old ECT - sensor diff?
3672  314204              jbc   REG_42,BIT_01,L3679	; jump if called from 366A entry point
3675  DB08                jc    L367F			; jump if R34 > R32
3677  2002                sjmp  L367B			; jump if R34 <= R32

3679  D604          L3679 jge   L367F			; jmp if difference is NOT negative

367B  1742          L367B incb  REG_42			; funny way to set bit 0

367D  033C                neg   REG_3C			; convert a negative diff to ABS value
367F  6C363C        L367F mulu  REG_3C,REG_36	; calc scaled diff - R3C = R3C(sensor diff) * R36(mangled funny ROM)rslt=R3c/3E
3682  033E                neg   REG_3E			; neg scaled diff Hi 16 bits
3684  D706                jne   L368C			; jmp if scaled diff > $0000FFFF
3686  033C                neg   REG_3C			; neg scaled diff LO 16 bits
3688  DF07                je    L3691			; jmp - scaled diff is ZERO
368A  053E                dec   REG_3E			; any fraction to next hole num

368C  384202        L368C jbs   REG_42,BIT_00,L3691	; jump to get correct way to add back scaled difference 

368F  033E                neg   REG_3E
3691  64323E        L3691 add   REG_3E,REG_32	; add scaled diff to base = old AD value
3694  F0                  ret					; REG_3E has final AD value 

                    ;*
                    ;************************************************************
                    ;* Pull Filter params off of stack
                    ;*
                    ;*  Get caller's next parameter - incr return address beyond it
                    ;*     return in  Word $3C
                    ;*  If positive, returned as is.
                    ;*  If negative, return:
                    ;*     parameter bits 0-11
                    ;*   + contents ($00E0 + parameter bits 8-15 div by 8 (trunc even) )
                    ;************************************************************
3695  CC38          L3695 pop   REG_38                      ;$38 = this our return addr
3697  CC3A                pop   REG_3A                      ;$3A = caller's return addr
3699  B23B3C              ldb   REG_3C,[REG_3A]+            ;$3C = 1st byte of parameter (LSB)
369C  B23B3D              ldb   REG_3D,[REG_3A]+            ;$3D = 2nd byte of parameter (MSB)
369F  C83A                push  REG_3A                      ; restore modified caller addres ( + 2 )
36A1  C838                push  REG_38                      ; restore our return address - unchanged	
36A3  373D11              jbc   REG_3D,BIT_07,L36B7         ; return if REG_3D is positive(addr not filter factor) 
36A6  AC3D38              ldbze REG_38,REG_3D				; convert REG_3D to 16 bit address
36A9  710F3D              andb  REG_3D,#$0F					; mask out filter base
36AC  180338              shrb  REG_38,#$03                 ; $38 = ($00 | MSB of param) divided by 8
36AF  71FE38              andb  REG_38,#$FE                 ; truncate to even for word store
36B2  6739E000            add   REG_3C,$00E0[REG_38]	    ; look up ROM filter factor and add to base
      3C
36B7  F0            L36B7 ret
                    ;*
                    ;************************************************************
                    ;*  routine scale filtering difference by factor
                    ; inputs:
                    ;         REG_CA
                    ;         REG_36 - funny ROM value
                    ;         REG_3E,3F if REG_CA bit 0 == 1
                    ;                   else $5E[REG_74] is the input(background time in msec)
                    ; outputs:
                    ;         REG_36 = R3E * 65536 / (R36 + R3E)
                    ;
                    ;************************************************************
36B8  38CA04        L36B8 jbs   REG_CA,BIT_00,L36BF	; test bit 0
36BB  AF745E3E            ldbze REG_3E,$5E[REG_74]		; $27E+$5E=$2DC = BACKGROUND_LOOP_TIMER

36BF  71FECA        L36BF andb  REG_CA,#$FE		; clr bit 0

36C2  013C                clr   REG_3C			; clear Lo 16 bits of the 32 in REG_3C/3D/3E/3F
36C4  643E36              add   REG_36,REG_3E	; add for divisor
36C7  D303                jnc   L36CC
36C9  BDFF36              ldbse REG_36,#$FF		; if too big clip value to $FFFF
36CC  8C363C        L36CC divu  REG_3C,REG_36	; REG_36 always ZERO!!!! R3C,R3D,R3E,R3F/R36
36CF  D503                jnv   L36D4			; never???
36D1  BDFF3C              ldbse REG_3C,#$FF		; always?(div by small(zero) produces max(FFFF) result?
36D4  A03C36        L36D4 ld    REG_36,REG_3C
36D7  F0                  ret
                    ;************************************************************
                    ; Interpolate 2 var data table
					; REG_30 is parameter A
					; REG_32 is parameter B
                    ; REG_38 is the table pointer
					; REG_34 is table width (4,7,A etc)
                    ; result in REG_3B
                    ;************************************************************
 
36D8  91802D              orb   REG_2D,#$80		; SIGNED table
                    ;************************************************************
 
36DB  1131          L36DB clrb  REG_31			; (6 refs) scale by 16
36DD  090430              shl   REG_30,#$04		; param A << 4
36E0  1133                clrb  REG_33
36E2  090432              shl   REG_32,#$04		; param B << 4
36E5  2003                sjmp  L36EA
		    ; Interpolate 2 var data table
		    ; REG_38 is the table pointer
36E7  91802D        L36E7 orb   REG_2D,#$80		; ( 2refs) SIGNED table
                    ;************************************************************
					; Trilinear interpolation
36EA  5C333436      L36EA mulub REG_36,REG_34,REG_33 (17 refs)
36EE  743136              addb  REG_36,REG_31
36F1  D302                jnc   L36F5
36F3  1737                incb  REG_37
36F5  643638        L36F5 add   REG_38,REG_36	; REG_38 is table data base pointer
36F8  B23931              ldb   REG_31,[REG_38]+
36FB  B23833              ldb   REG_33,[REG_38]
36FE  281F                scall L371F			; two var interpolation
3700  643438              add   REG_38,REG_34
3703  B23833              ldb   REG_33,[REG_38]
3706  0538                dec   REG_38
3708  B23831              ldb   REG_31,[REG_38]
370B  B03B34              ldb   REG_34,REG_3B
370E  280F                scall L371F			; two var interpolation
3710  B03B33              ldb   REG_33,REG_3B
3713  B03431              ldb   REG_31,REG_34
3716  B03230              ldb   REG_30,REG_32
3719  2804                scall L371F			; two var interpolation
371B  717F2D              andb  REG_2D,#$7F		; clr signed math flag
371E  F0                  ret

371F  372D1A        L371F jbc   REG_2D,BIT_07,L373C	; jmp if unsigned math
3722  BC333A              ldbse REG_3A,REG_33
3725  BC313C              ldbse REG_3C,REG_31
3728  683C3A              sub   REG_3A,REG_3C
372B  AC303C              ldbze REG_3C,REG_30
372E  FE6C3A3C            mul   REG_3C,REG_3A
3732  C03A3C              st    REG_3C,REG_3A
3735  74313B              addb  REG_3B,REG_31
3738  373B0F              jbc   REG_3B,BIT_07,L374A
373B  F0                  ret

373C  5C33303A      L373C mulub REG_3A,REG_30,REG_33
3740  5C313036            mulub REG_36,REG_30,REG_31
3744  68363A              sub   REG_3A,REG_36
3747  74313B              addb  REG_3B,REG_31
374A  6580003A      L374A add   REG_3A,#$0080
374E  F0                  ret

; Table at REG_30
; input value in REG_C8 (REG_C8 may be a byte size counter for ATMR1)
; result is carry set/clr
374F  9BFE04AD      L374F cmpb  REG_AD,$04[REG_FE]	; TCSTRT : ROM $9E5E - CTHIGH
3753  DE07                jlt   L375C
3755  9A30C8              cmpb  REG_C8,[REG_30]
3758  D32A                jnc   L3784
375A  2026                sjmp  L3782

375C  0730          L375C inc   REG_30
375E  9BFE05AD            cmpb  REG_AD,$05[REG_FE]	; ROM $9E5F - CTLOW
3762  DA0E                jle   L3772
3764  9A30C8              cmpb  REG_C8,[REG_30]		; REG_C8 is some kind of timer ATMR1
3767  D31B                jnc   L3784
3769  0730                inc   REG_30
376B  9A30C9              cmpb  REG_C9,[REG_30]		; REG_C9 is some kind of timer ATMR2
376E  D314                jnc   L3784
3770  2010                sjmp  L3782

3772  0730          L3772 inc   REG_30
3774  0730                inc   REG_30
3776  9A30C8              cmpb  REG_C8,[REG_30]		; REG_C8 is some kind of timer ATMR1
3779  D309                jnc   L3784
377B  0730                inc   REG_30
377D  9A30C9              cmpb  REG_C9,[REG_30]		; REG_C9 is some kind of timer ATMR2
3780  D302                jnc   L3784
3782  F8            L3782 clrc
3783  F0                  ret

3784  F9            L3784 setc
3785  F0                  ret

;
;*****************************************************************
; Cycling Routine at 2151, routine offset 6
; Set RPM Flags mode - cranking, underspeed. run
;*****************************************************************
;
3786  71EFE9        L3786 andb  REG_E9,#$EF			; clr CRNK_TRANS
3789  37A121              jbc   REG_A1,BIT_07,L37AD	; jump if not CRANKING
; RPM < 50 here
378C  8BFA1AAE            cmp   REG_AE,$1A[REG_FA]	; REG_AE = engine RPM * 4 = $384 = 900 div 4 = 225 RPM
3790  D114                jnh   L37A6				; jmp if RPM <= 225 
; RPM > 225 here
3792  B10814              ldb   REG_14,#$08
3795  9B74E714            cmpb  REG_14,$E7[REG_74]	; $265 - ECTCNT
3799  D909                jh    L37A4				; jump if 8 > $E7[REG_74]??
379B  9BFA14B4            cmpb  REG_B4,$14[REG_FA]	; ROM 97BC = 8. REG_B4 is PIPCNT : NCNT
379F  D303                jnc   L37A4				; jump if REG_B4 < 8

37A1  717FA1              andb  REG_A1,#$7F			; clr CRANKING
37A4  2040          L37A4 sjmp  L37E6				; set REG_A1 bit 2

; RPM <= 255
37A6  11B4          L37A6 clrb  REG_B4				; REG_B4 is PIP count thingy?
37A8  71EF2F              andb  REG_2F,#$EF			; clr REG_2F bit 4 - PTSCR
37AB  2039                sjmp  L37E6				; set REG_A1 bit 2

; RPM >= 50
37AD  11B4          L37AD clrb  REG_B4				; REG_B4 is PIP count thingy?
37AF  8BFA1CAE            cmp   REG_AE,$1C[REG_FA]	; REG_AE = engine RPM * 4, ROM $97C4-00C8 = 200 (50 RPM)
37B3  DB11                jc    L37C6				; jump if RPM >= 50
; RPM < 50
37B5  9180A1              orb   REG_A1,#$80			; set CRANKING
37B8  9110E9              orb   REG_E9,#$10			; set CRNK_TRANS
37BB  C774E700            stb   Zero,$E7[REG_74]	; $265 - ECTCNT
37BF  01AC                clr   REG_AC				; TCSTRL
37C1  71EF2F              andb  REG_2F,#$EF			; clr PTSCR
37C4  2020                sjmp  L37E6				; set REG_A1 bit 2

; RPM >= 50
37C6  A3FA1630      L37C6 ld    REG_30,$16[REG_FA]	; ROM $97BE UNderspeedRPM = $320 = 800 div 4 = 200
37CA  88AE30              cmp   REG_30,REG_AE		; REG_AE = engine RPM * 4
37CD  D102                jnh   L37D1				; jump if 200 <= RPM
37CF  2015                sjmp  L37E6				; set REG_A1 bit 2

; RPM >= 200 - Underspeed limit low
37D1  67FA1830      L37D1 add   REG_30,$18[REG_FA]	; REG_30 = 200+100. ROM $97C0 UNRPMH = $190 = 400 div 4 = 100
37D5  88AE30              cmp   REG_30,REG_AE		; REG_AE = engine RPM * 4
37D8  DB0A                jc    L37E4				; jmp if 300 >= RPM - ei/return

; RPM >  300 - Underspeed limit high
37DA  FA                  di
37DB  FF                  nop
37DC  32A105              jbc   REG_A1,BIT_02,L37E4	; if not UNDSP then ei/return - UNDSP = Run/Underspeed Flag.  (1 = Underspeed (or CRANK), 0 = Run)
37DF  71FBA1              andb  REG_A1,#$FB			; clr UNDSPEED
37E2  200A                sjmp  L37EE	
37E4  FB            L37E4 ei
37E5  F0                  ret

; Set flags for engine running?(not cranking) RPM < 200,
37E6  FA            L37E6 di
37E7  FF                  nop
37E8  3AA106              jbs   REG_A1,BIT_02,L37F1	; jmp if UNDSP is already set - UNDSP = Run/Underspeed Flag.  (1 = Underspeed (or CRANK), 0 = Run)
37EB  9104A1              orb   REG_A1,#$04			; set REG_A1 bit 2 - UNDSPEED
37EE  91022D        L37EE orb   REG_2D,#$02			; REG_A1 flag changed flag??? - DOUBLE_EDGE
37F1  FB            L37F1 ei
37F2  F0                  ret
;
;*****************************************************************
; Cycling Routine at 2151, routine offset C
; Update throttle vars
;*****************************************************************
;
37F3  717FE9        L37F3 andb  REG_E9,#$7F				; clr CTPTFG
37F6  A372A636            ld    REG_36,$A6[REG_72]		; $0126 - RATCH=Closed TP
37FA  47FA023638          add   REG_38,REG_36,$02[REG_FA] ; ROM $97AA - TP DELTA
37FF  DB3A                jc    L383B					; jmp on NO overflow - clr WOT
3801  8838AA              cmp   REG_AA,REG_38			; REG_AA is Throttle position
3804  D135                jnh   L383B					; TP <= filtered TP + DELTA - clr WOT
3806  67FA0638            add   REG_38,$06[REG_FA]		; ROM $97AE - HYSTS - hyserysis?
380A  DB05                jc    L3811					; jmp on overflow
380C  8838AA              cmp   REG_AA,REG_38			; REG_AA is Throttle position
380F  D903                jh    L3814					; jmp if TP > RATCH + DELTA + HYSTS
3811  3FD039        L3811 jbs   REG_D0,BIT_07,L384D		; jmp if throttle is closed
3814  37D003        L3814 jbc   REG_D0,BIT_07,L381A		; jmp if throttle is not closed

3817  9180E9              orb   REG_E9,#$80				; set CTPTFG
381A  67FA0836      L381A add   REG_36,$08[REG_FA]		; ROM $97B0 WOT_Voltage (WOT breakpoint (TPS voltage - 1))
381E  DB22                jc    L3842
3820  8836AA              cmp   REG_AA,REG_36			; REG_AA is Throttle position
3823  D11D                jnh   L3842
3825  67FA0436            add   REG_36,$04[REG_FA]		; ROM $97AC - HYST2
3829  DB05                jc    L3830
382B  8836AA              cmp   REG_AA,REG_36			; REG_AA is Throttle position
382E  D904                jh    L3834					; jump to set WOT
3830  3FD00F        L3830 jbs   REG_D0,BIT_07,L3842		; jmp if throttle is closed
3833  F0                  ret

3834  B101D0        L3834 ldb   REG_D0,#$01				; throttle == wide open
3837  910124              orb   REG_24,#$01				; set WOT
383A  F0                  ret

383B  B1FFD0        L383B ldb   REG_D0,#$FF				; throttle == closed
383E  71FE24              andb  REG_24,#$FE				; clr WOT
3841  F0                  ret

3842  3FA103        L3842 jbs   REG_A1,BIT_07,L3848		; jump if CRANKING
3845  91102F              orb   REG_2F,#$10				; set PTSCR
3848  11D0          L3848 clrb  REG_D0					; throttle = partly open
384A  71FE24              andb  REG_24,#$FE				; clr WOT
384D  F0            L384D ret
;
;*****************************************************************
; Cycling Routine at 2151, routine offset A
;
; Read in new Analog to Digital channels
;
;*****************************************************************
;
384E  36E619              jbc   REG_E6,BIT_06,L386A		; if REG_E6 bit 6 is clear then do ECT test w/o default value
3851  36C505              jbc   REG_C5,BIT_06,L3859		; if REG_C5 bit 6 is clear then run ECT test
3854  9104C5              orb   REG_C5,#$04				; set REG_C5  bit 2
3857  2030                sjmp  L3889					; jmp to ACT test
;
; update EVP
;
3859  32C52D        L3859 jbc   REG_C5,BIT_02,L3889		; if REG_C5 bit 2 is clear skip EVP update

385C  A180A230            ld    REG_30,#$A280			; default EVP
3860  C301EE0730          st    REG_30,$07EE[Zero]		; filtered EVP saved in KAM 

3865  71FBC5              andb  REG_C5,#$FB				; clr bit 2
3868  201F                sjmp  L3889					; go to ACT test

386A  3EC514        L386A jbs   REG_C5,BIT_06,L3881		; if REG_C5 bit 6 is set then use $0128 as ACT
386D  A3729630            ld    REG_30,$96[REG_72]	<<<<<<  ; raw EVP $0116 
3871  8BF3B20030          cmp   REG_30,$00B2[REG_F2]	; ROM $8F0C contents - MAX raw ECT $F640 (used in self test also)
3876  D911                jh    L3889					; go to ACT test

3878  8BF3B00030          cmp   REG_30,$00B0[REG_F2]	; ROM $8F0A contents - MIN raw ECT $0A00 (used in self test also)
387D  DB06                jc    L3885					; if new ECT is in range use it as new ECT value
387F  2008                sjmp  L3889					; go to ACT test

3881  A372A830      L3881 ld    REG_30,$A8[REG_72]		; some kind of ACT ??? $0128
3885  C372F030      L3885 st    REG_30,$F0[REG_72]		; save new ACT in $0170 ?
;
; update ACT
;
3889  3DC51D        L3889 jbs   REG_C5,BIT_05,L38A9		; if REG_C5 bit 5 is clear skip ACT test
388C  A3729430            ld    REG_30,$94[REG_72]      <<<<    ; input raw AD ACT $0114 word!!
3890  8BF26A30            cmp   REG_30,$6A[REG_F2]		; ROM $8EC4 contents $E9C0 max ACT (used by self test code also)
3894  D913                jh    L38A9					; ACT voltage too high
3896  8BF26830            cmp   REG_30,$68[REG_F2]		; ROM $8EC2 contents $0A00 min ACT (used by self test code also)
389A  D30D                jnc   L38A9					; ACT voltage too low

389C  45B001F0            add   REG_32,REG_F0,#$01B0	; TABLE undocumeted $8DB0 - AD counts to degrees F
      32
38A1  B3729534            ldb   REG_34,$95[REG_72]	<<<<	; input for ACT calc (addr= $0115) byte!!
38A5  2D0D                scall L35B4					; Interpolate Single var Table R32-table,R34-in,R38-out
38A7  200F                sjmp  L38B8					; REG_38 is our new ACT
; ACT sensor is BAD
38A9  39EF05        L38A9 jbs   REG_EF,BIT_01,L38B1		; if REG_EF bit 1 is set then do NOT use ECT as new ACT
38AC  B0B038              ldb   REG_38,REG_B0			; Engine Coolant Temperature - degrees F ?
38AF  2007                sjmp  L38B8					; use ECT as ACT

38B1  35C507        L38B1 jbc   REG_C5,BIT_05,L38BB		; if REG_C5 bit 5 is clr do NOT set ACT from ROM

38B4  B3F67F38            ldb   REG_38,$7F[REG_F6]		; $9427 = $4B ($4B * 4 = 300 degrees)
38B8  B038B1        L38B8 ldb   REG_B1,REG_38			; Set ACT (ACT = REG_B1 * 4)
;
; update ECT
;
38BB  3FC51E        L38BB jbs   REG_C5,BIT_07,L38DC
38BE  A3729230            ld    REG_30,$92[REG_72]	    ; raw AD ECT 16 bit ECT $0112 (AD range is $0000-$FFC0)
38C2  8BF38000            cmp   REG_30,$0080[REG_F2]	; ROM $8EDA - $E9C0 Max VALID SENSOR limit
      30
38C7  D913                jh    L38DC					; invalid ECT temp sensor high - BAD sensor
38C9  8BF27E30            cmp   REG_30,$7E[REG_F2]		; ROM $8ED8 - $0A00 min valid limit
38CD  D30D                jnc   L38DC					; invalid ECT temp sensor low - BAD sensor

38CF  45B001F032          add   REG_32,REG_F0,#$01B0	; TABLE $8DB0 - sensor ADcounts to degrees F
38D4  B3729334            ldb   REG_34,$93[REG_72]	    ; input for table HI BYTE! - ECT in AD counts (addr=$113)
38D8  2CDA                scall L35B4					; AD Count to temp - Interpolate Single var Table R32-table,R34-in,R38-out
38DA  2022                sjmp  L38FE
; invalid sensor reading
38DC  B0B138        L38DC ldb   REG_38,REG_B1			; REG_B1 = ACT (ACT = REG_B1 * 4)(use ACT for ECT ?)
38DF  3FA11C              jbs   REG_A1,BIT_07,L38FE		; jump if CRANKING
38E2  9BFE04AD            cmpb  REG_AD,$04[REG_FE]		; ROM $9E5E CTHIGH
38E6  DE08                jlt   L38F0
38E8  9BFC0EC8            cmpb  REG_C8,$0E[REG_FC]		; (9A7E+E)=(9A8C)=$3C , (REG_C8 may be a byte size counter for ATMR1)
38EC  D310                jnc   L38FE
38EE  2006                sjmp  L38F6

38F0  9BFC0FC8      L38F0 cmpb  REG_C8,$0F[REG_FC]		; (9A7E+F)=(9A8D)=$64, (REG_C8 may be a byte size counter for ATMR1)
38F4  D308                jnc   L38FE

38F6  37C517        L38F6 jbc   REG_C5,BIT_07,L3910
38F9  B3F78000            ldb   REG_38,$0080[REG_F6]	; new ECT value from ROM = ($9428) = $4B ($4B*4 = 300)
      38
38FE  BCB032        L38FE ldbse REG_32,REG_B0			; Engine Coolant Temperature - degrees F ?
3901  BC3834              ldbse REG_34,REG_38			; new ECT value to filter and save
3904  090838              shl   REG_38,#$08				; R38 = R38 * 256
3907  A3FA4436            ld    REG_36,$44[REG_FA]		; filter factor
390B  2D5D                scall L366A					; FILTER (factor times difference added back)
390D  B03EB0              ldb   REG_B0,REG_3E			; Set Engine Coolant Temperature - degrees F ?
;
; ???
;
3910  A372B414      L3910 ld    REG_14,$B4[REG_72]		; $0134 - PUTMR - Counts up after hardware reset
3914  8BF85214            cmp   REG_14,$52[REG_F8]		; ROM $9482 TKYON2 - compare whole seconds
3918  D115                jnh   L392F					; jump timer <= ROM time
391A  B374E714            ldb   REG_14,$E7[REG_74]		; ECTCNT
391E  990814              cmpb  REG_14,#$08
3921  DB0C                jc    L392F					; jmp time <= 8 secs?
3923  0A0338              shra  REG_38,#$03				; div by 8
3926  6438AC              add   REG_AC,REG_38			; REG_AC = TCSTRL?
3929  1714                incb  REG_14					; incr what?
392B  C774E714            stb   REG_14,$E7[REG_74]		; ECTCNT
;
; update TP
;
392F  3CC510        L392F jbs   REG_C5,BIT_04,L3942		; Flag indicating that TP sensor has failed

3932  A372A230            ld    REG_30,$A2[REG_72]	<<<<<<  ; read raw TP AD value
3936  8BF27030            cmp   REG_30,$70[REG_F2]		; ROM range limit
393A  D306                jnc   L3942					; range error
393C  8BF26E30            cmp   REG_30,$6E[REG_F2]		; ROM range limit
3940  D123                jnh   L3965
;  TP is out of range
3942  A372A630      L3942 ld    REG_30,$A6[REG_72]		; $0126 - RATCH=Closed TP
3946  3FA11C              jbs   REG_A1,BIT_07,L3965		; jump if CRANKING
3949  8BF78400A2          cmp   REG_A2,$0084[REG_F6]			; REG_A2 = AM = Air mass flow for the engine (lb/min) : ROM
394E  D315                jnc   L3965					; range error

3950  34C515              jbc   REG_C5,BIT_04,L3968		; Flag indicating that TP sensor has failed

3953  A3F00230            ld    REG_30,$02[REG_F0]		; ROM $8C02
3957  C372A630            st    REG_30,$A6[REG_72]		; $0126 - RATCH=Closed TP
395B  67F7820030          add   REG_30,$0082[REG_F6]	; ROM $942A Change in TP  if  not  at  idle  (as  indicated  by  AM) This parameter is designed to permit Part Throttle operation
3960  D303                jnc   L3965
3962  BDC030              ldbse REG_30,#$C0				; default value
3965  A030AA        L3965 ld    REG_AA,REG_30			; set REG_AA is Throttle position
;
; update TAR - Throttle position sensor rate
;
3968  A1AEA338      L3968 ld    REG_38,#$A3AE			; minimum rate?
396C  6B72A038            sub   REG_38,$A0[REG_72]	<<<<<<	; read raw TAR sensor $0120
3970  DB02                jc    L3974
3972  0138                clr   REG_38					; clamp to zero

3974  6DAEBC38      L3974 mulu  REG_38,#$BCAE
3978  0D0138              shll  REG_38,#$01				; X2
397B  6580003A            add   REG_3A,#$0080			; round up
397F  C774203B            stb   REG_3B,$20[REG_74]		; $029E = TAR converted to degrees per second 
;
; update BP
;
3983  9BF84B00            cmpb  Zero,$4B[REG_F8]		; ROM
3987  D70A                jne   L3993
3989  B3F84C14            ldb   REG_14,$4C[REG_F8]		; ROM
398D  C7748014            stb   REG_14,$80[REG_74]		; BP - barometric pressure - byte
3991  2094                sjmp  L3A27

3993  31C509        L3993 jbc   REG_C5,BIT_01,L399F
3996  B3F7860035          ldb   REG_35,$0086[REG_F6]	; ROM
399B  206C                sjmp  L3A09					; filter REG_35 as new TP

399D  2066                sjmp  L3A05					; How do we get here?

399F  B372B63A      L399F ldb   REG_3A,$B6[REG_72]		; $0136 - timer? - time since last BP pulse?
39A3  9BF31601            cmpb  REG_3A,$0116[REG_F2]	; ROM $8F70 - Maximum time since last BP update, secs
      3A
39A8  D977                jh    L3A21
39AA  A3728A1C            ld    REG_1C,$8A[REG_72]		; $010A - MAP/BP
39AE  8BF30201            cmp   REG_1C,$0102[REG_F2]	; ROM $8F69 maf_maximum_voltage ?
      1C
39B3  D36C                jnc   L3A21
39B5  3FA103              jbs   REG_A1,BIT_07,L39BB		; jump if CRANKING
39B8  324E4A              jbc   REG_4E,BIT_02,L3A05

39BB  FA            L39BB di							; why no ints in this section?
39BC  FF                  nop
39BD  ACB61E              ldbze REG_1E,REG_B6			; BP counts
39C0  A3740216            ld    REG_16,$02[REG_74] 		; time of last BP read
39C4  11B6                clrb  REG_B6					; reset count to zero
39C6  301E07              jbc   REG_1E,BIT_00,L39D0		; disallow odd BP counts
39C9  151E                decb  REG_1E
39CB  17B6                incb  REG_B6
39CD  681C16              sub   REG_16,REG_1C
39D0  FB            L39D0 ei

39D1  981E00              cmpb  Zero,REG_1E				; BP count == zero?
39D4  D62F                jge   L3A05
39D6  4B72BC16            sub   REG_18,REG_16,$BC[REG_72]	; $013C - time of last BP read - REG_18 is delta time?
      18
39DB  011A                clr   REG_1A
39DD  0D0118              shll  REG_18,#$01				; X 2
39E0  8C1E18              divu  REG_18,REG_1E			; convert counts to freq by dividing by time
39E3  A1AB9A34            ld    REG_34,#$9AAB
39E7  A15B0636            ld    REG_36,#$065B
39EB  8C1834              divu  REG_34,REG_18			; convert units
39EE  457800F0            add   REG_32,REG_F0,#$0078	; TABLE $8C78 = FN000 = - conversion to BP units
      32
39F3  EF16FC              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
39F6  65800038            add   REG_38,#$0080			; round up to save byte vs word
39FA  C772AF39            stb   REG_39,$AF[REG_72]		; save BP $012F
39FE  C372BC16            st    REG_16,$BC[REG_72]		; time of last BP calc
3A02  71FB4E              andb  REG_4E,#$FB

3A05  B372AF35      L3A05 ldb   REG_35,$AF[REG_72]		; new AD sensor value Hi = $012F - BP

3A09  1134          L3A09 clrb  REG_34					; new AD sensor value Lo
3A0B  A372B032            ld    REG_32,$B0[REG_72]		; Old AD sensor value   = $0130 - filtered BP
3A0F  EF4CFC              lcall L365E					; filter new AD input 
3A12  56D0                word  $D056					; filter factors (lookup in ROM)
3A14  C372B03E            st    REG_3E,$B0[REG_72]		; updated AD value      = $0130 -  filtered BP

3A18  C774803F            stb   REG_3F,$80[REG_74]		; BP - barometric pressure $01FE
3A1C  39C502              jbs   REG_C5,BIT_01,L3A21
3A1F  2006                sjmp  L3A27
3A21  11B6          L3A21 clrb  REG_B6
3A23  C372BC06            st    Master_IO_Timer_Lo,$BC[REG_72]	; time of last BP calc
;
; update MAF
;
3A27  3BC519        L3A27 jbs   REG_C5,BIT_03,L3A43
3A2A  A372A434            ld    REG_34,$A4[REG_72] 		; (raw MAF counts?) $124
3A2E  8BF31201AE          cmp   REG_AE,$0112[REG_F2]	; REG_AE = engine RPM * 4 : ROM $8F6C mass_air_rpm
3A33  DB07                jc    L3A3C
3A35  8BF30E0134          cmp   REG_34,$010E[REG_F2]	; ROM $8F68 mass_air_maximum = $F500 - max MAF count (remember 'left' justified)
3A3A  D907                jh    L3A43

3A3C  8BF3100134    L3A3C cmp   REG_34,$0110[REG_F2]	; ROM $8F6A mass_air_minimum = $12C0 - min MAF count
3A41  DB0B                jc    L3A4E					; jump range OK
3A43  910126        L3A43 orb   REG_26,#$01				; MAF count out of range error
3A46  B3F24C34            ldb   REG_34,$4C[REG_F2]		; ROM $8EA6 - bad MAF sensor retry interval (3)
3A4A  C772CB34            stb   REG_34,$CB[REG_72]		; set bad MAF retry interval
; valid MAF sensor reading
3A4E  37A106        L3A4E jbc   REG_A1,BIT_07,L3A57		; jump if not CRANKING
3A51  C772CB00            stb   Zero,$CB[REG_72]		; counts since last bad MAF read
3A55  2011                sjmp  L3A68

3A57  B372CB34      L3A57 ldb   REG_34,$CB[REG_72]		; decr bad MAF read count but clamp to zero
3A5B  983400              cmpb  Zero,REG_34
3A5E  DF08                je    L3A68
3A60  1534                decb  REG_34
3A62  C772CB34            stb   REG_34,$CB[REG_72]
3A66  2003                sjmp  L3A6B
3A68  71FE26        L3A68 andb  REG_26,#$FE				; clr MAF input range error? 

3A6B  38261E        L3A6B jbs   REG_26,BIT_00,L3A8C		; jmp if MAF out of range error
3A6E  CB74DA              push  $DA[REG_74]				; ARCHFG = Filtered air charge according to filling model
3A71  CF74D4              pop   $D4[REG_74]				; $0252 ARCHG = Air Charge Mass inducted per Intake Stroke, lbm/Intake.
3A74  A374D830            ld    REG_30,$D8[REG_74]
3A78  0132                clr   REG_32
3A7A  0D0830              shll  REG_30,#$08
3A7D  8F74DA30            divu  REG_30,$DA[REG_74]		; ARCHFG = Filtered air charge according to filling model
3A81  D503                jnv   L3A86
3A83  BDFF30              ldbse REG_30,#$FF
3A86  C374DC30      L3A86 st    REG_30,$DC[REG_74]
3A8A  207D                sjmp  L3B09
; MAF sensor read is bad - calc air mass by speed-density
3A8C  A0AE34        L3A8C ld    REG_34,REG_AE			; REG_AE = engine RPM * 4
3A8F  3CC567              jbs   REG_C5,BIT_04,L3AF9

3A92  45DE00F032          add   REG_32,REG_F0,#$00DE	; TABLE $8CDE spark_table_RPM_scaling
3A97  EF72FB              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
3A9A  A03830              ld    REG_30,REG_38
3A9D  A372A234            ld    REG_34,$A2[REG_72]		; read raw TP AD value $0122
3AA1  6B72A634            sub   REG_34,$A6[REG_72]		; $0126 - RATCH=Closed TP
3AA5  DB02                jc    L3AA9
3AA7  0134                clr   REG_34					; clamp to zero (if throttle was closing?)
3AA9  45F000F432    L3AA9 add   REG_32,REG_F4,#$00F0	; TABLE $90C6 Normalized delta TP, used for MAF sensor failure table lookup.
3AAE  EF5BFB              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
3AB1  A03832              ld    REG_32,REG_38
3AB4  452C01F438          add   REG_38,REG_F4,#$012C	; TABLE $9102 - Table lookup for failed Mass Air Flow Sensor(N, delta TP)
3AB9  AD0A34              ldbze REG_34,#$0A
3ABC  EF2BFC              lcall L36EA					; Interpolate two var table R38-Table
3ABF  AC3B38              ldbze REG_38,REG_3B
3AC2  A374E434            ld    REG_34,$E4[REG_74]
3AC6  0136                clr   REG_36
3AC8  0D0834              shll  REG_34,#$08
3ACB  8CAE34              divu  REG_34,REG_AE			; REG_AE = engine RPM * 4
3ACE  9FFE0734            divub REG_34,$07[REG_FE]		; ROM ENGCYL = Number of cylinders per engine revolution (NUMCYL/2); or number of PIPs per engine revolution
3AD2  D503                jnv   L3AD7
3AD4  B1FF34              ldb   REG_34,#$FF				; clamp
3AD7  1135          L3AD7 clrb  REG_35
3AD9  643834              add   REG_34,REG_38
3ADC  AF748036            ldbze REG_36,$80[REG_74]		; BP - barometric pressure
3AE0  090736              shl   REG_36,#$07
3AE3  6C3634              mulu  REG_34,REG_36
3AE6  8DEF0034            divu  REG_34,#$00EF
3AEA  D503                jnv   L3AEF
3AEC  BDFF34              ldbse REG_34,#$FF				; clamp
3AEF  C374D434      L3AEF st    REG_34,$D4[REG_74]		; $0252 ARCHG = Air Charge Mass inducted per Intake Stroke, lbm/Intake.
3AF3  C374DA34            st    REG_34,$DA[REG_74]		; ARCHFG = Filtered air charge according to filling model
3AF7  2010                sjmp  L3B09

3AF9  450C01F4      L3AF9 add   REG_32,REG_F4,#$010C	; TABLE $90E2 Default ARCHI for failed Mass Air Flow sensor AND TP sensor.
      32
3AFE  EF0BFB              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
3B01  C374D438            st    REG_38,$D4[REG_74]		; $0252 ARCHG = Air Charge Mass inducted per Intake Stroke, lbm/Intake.
3B05  C374DA38            st    REG_38,$DA[REG_74]		; ARCHFG = Filtered air charge according to filling model
;
; Update NDS and ACC (multiplexed inputs)
;
3B09  A3729A14      L3B09 ld    REG_14,$9A[REG_72]	<<<<<<  ; read raw AD NDS/A3C
3B0D  4B740C1416          sub   REG_16,REG_14,$0C[REG_74]	; last raw AD NDS/A3C
3B12  DB02                jc    L3B16
3B14  0316                neg   REG_16
3B16  89800216      L3B16 cmp   REG_16,#$0280
3B1A  D928                jh    L3B44
3B1C  717FEE              andb  REG_EE,#$7F				; A3C OFF - A/C cycling control switch is open
3B1F  9140EE              orb   REG_EE,#$40				; INDFLG ON 
3B22  8900EE14            cmp   REG_14,#$EE00			; 952 AD counts
3B26  DB1C                jc    L3B44
3B28  89008B14            cmp   REG_14,#$8B00			; 556 AD counts
3B2C  D305                jnc   L3B33
3B2E  71BFEE              andb  REG_EE,#$BF				; INDFLG OFF
3B31  2011                sjmp  L3B44
3B33  89006714      L3B33 cmp   REG_14,#$6700			; 412 AD counts
3B37  D305                jnc   L3B3E
3B39  9180EE              orb   REG_EE,#$80				; A3C ON
3B3C  2006                sjmp  L3B44
3B3E  9180EE        L3B3E orb   REG_EE,#$80				; A3C ON - A/C cycling control switch is closed
3B41  71BFEE              andb  REG_EE,#$BF				; INDFLG OFF
3B44  C3740C14      L3B44 st    REG_14,$0C[REG_74]		; save last NDS/A3C

3B48  B3FE0218            ldb   REG_18,$02[REG_FE]		; ROM $9E5C TRLOAD = Transmission Load switch
3B4C  B0E730              ldb   REG_30,REG_E7
3B4F  717FE7              andb  REG_E7,#$7F				; clr NDSFLG - Neutral/Drive Flag 1 = Drive.
3B52  990018              cmpb  REG_18,#$00				; TRLOAD = 0 = Manual Transmission, no clutch or gear switches, forced neutral state (NDSFLG = 0).
3B55  DF06                je    L3B5D
3B57  36EE03              jbc   REG_EE,BIT_06,L3B5D		; INDFLG bit
3B5A  9180E7              orb   REG_E7,#$80				; set NDSFLG - Neutral/Drive Flag 1 = Drive.
3B5D  94E730        L3B5D xorb  REG_30,REG_E7
3B60  373002              jbc   REG_30,BIT_07,L3B65
3B63  11CC                clrb  REG_CC					; zero NDDTIM timer - time since Neutral/Drive Switch State change, sec.
3B65  990318        L3B65 cmpb  REG_18,#$03				; TRLOAD = 3 = Manual Transmission, both clutch and gear switches.
3B68  D90B                jh    L3B75
3B6A  71BF26              andb  REG_26,#$BF
3B6D  37E72A              jbc   REG_E7,BIT_07,L3B9A		; NDSFLG - Neutral/Drive Flag 1 = Drive.
3B70  914026              orb   REG_26,#$40				; set DNDSUP = Drive Neutral select.
3B73  2025                sjmp  L3B9A
3B75  3FE70F        L3B75 jbs   REG_E7,BIT_07,L3B87		; NDSFLG - Neutral/Drive Flag 1 = Drive.
3B78  B3F59200            ldb   REG_38,$0092[REG_F4]
      38
3B7D  98CC38              cmpb  REG_38,REG_CC			; NDDTIM timer - time since Neutral/Drive Switch State change, sec.
3B80  D918                jh    L3B9A
3B82  71BF26              andb  REG_26,#$BF				; clr DNDSUP = Drive Neutral select.
3B85  2013                sjmp  L3B9A

3B87  B0B034        L3B87 ldb   REG_34,REG_B0			; Engine Coolant Temperature - degrees F
3B8A  452600F032          add   REG_32,REG_F0,#$0026	; TABLE $8C26 - Time delay before recognition of N/D Transition - forward gear  Input = ECT; OUTPUT = Seconds.
3B8F  EF1AFA              lcall L35AC					; Interpolate Single var Table R32-table,R34-in,R38-out 
3B92  98CC38              cmpb  REG_38,REG_CC			; NDDTIM timer - time since Neutral/Drive Switch State change, sec.
3B95  D903                jh    L3B9A
3B97  914026              orb   REG_26,#$40				; set DNDSUP - Drive/Neutral Select.

3B9A  71EF27        L3B9A andb  REG_27,#$EF				; clr POWSFG - Power Steering Flag.
3B9D  30DF03              jbc   REG_DF,BIT_00,L3BA3
3BA0  911027              orb   REG_27,#$10				; set POWSFG - Power Steering Flag.
;
; Update HEGOs
;
; check EGO 1
3BA3  71F727        L3BA3 andb  REG_27,#$F7				; clr REG_27 bit 3
3BA6  A3729C14            ld    REG_14,$9C[REG_72]		; read raw HEGO1 $011C
3BAA  89C0D514            cmp   REG_14,#$D5C0			; O2S TRIP VOLTAGE
3BAE  DB08                jc    L3BB8					; jump if R14 >= 4.17volts (jump if mixture is RICH)
3BB0  3FEA13              jbs   REG_EA,BIT_07,L3BC6		; jmp if we are already RICH - (NO CROSS) EGOFlag1
3BB3  9180EA              orb   REG_EA,#$80				; set REG_EA bit 7 - mixture RICH
3BB6  2006                sjmp  L3BBE

3BB8  37EA0B        L3BB8 jbc   REG_EA,BIT_07,L3BC6		; jmp if we are already lean - EGOFlag1
3BBB  717FEA              andb  REG_EA,#$7F				; clear REG_EA bit 7 - mixture is LEAN?

; handle a switch from rich to lean or lean to rich
3BBE  910827        L3BBE orb   REG_27,#$08				; CROSS FLAG
3BC1  AD0142              ldbze REG_42,#$01				; sensor number 1
3BC4  2909                scall L3CCF

; sensor did not cross stiochoimetric
; check EGO 2
3BC6  71FE27        L3BC6 andb  REG_27,#$FE
3BC9  A3729E14            ld    REG_14,$9E[REG_72]		; read raw HEGO2 $011E
3BCD  89C0D514            cmp   REG_14,#$D5C0			; O2S TRIP VOLTAGE
3BD1  DB08                jc    L3BDB
3BD3  3EEA13              jbs   REG_EA,BIT_06,L3BE9
3BD6  9140EA              orb   REG_EA,#$40				; set REG_EA bit 6
3BD9  2006                sjmp  L3BE1

3BDB  36EA0B        L3BDB jbc   REG_EA,BIT_06,L3BE9
3BDE  71BFEA              andb  REG_EA,#$BF
3BE1  910127        L3BE1 orb   REG_27,#$01            	; CROSS FLAG
3BE4  AD0242              ldbze REG_42,#$02				; sensor number 2
3BE7  28E6                scall L3CCF
;
; Update Brake On / Off (A/C ???)
;
3BE9  71FDEA        L3BE9 andb  REG_EA,#$FD				; clr BIFLG
3BEC  9BF61300            cmpb  Zero,$13[REG_F6]		; ROM $93BB - BIHP Brake Input Hardware Present
3BF0  DF06                je    L3BF8					; jmp if not A/C or BOO sensor input
3BF2  349003              jbc   REG_90,BIT_04,L3BF8		; jmp if not BOO_HIGH
3BF5  9102EA              orb   REG_EA,#$02				; set BIFLG =  If equal to 1, Brake is on.
;
; Update STI input line reading
;
3BF8  91202B        L3BF8 orb   REG_2B,#$20			; default - set REG_2B bit 5 - STI ON
3BFB  330B03              jbc   HSI_Sample,BIT_03,L3C01		; HSI bit 3 is STI - Self Test Input - on the fly test
3BFE  71DF2B              andb  REG_2B,#$DF			; clr STI - REG_2B bit 5 
;
; Update VCAL/KEYPWR
; KeyPower may be read thru a 20k and 4.35K voltage divider yeilding a 17.86% of battery voltage to AD input
; VCAL is 2.5Volts giving an AD reading of $7FE0
; resulting battery voltage level is times 16
; a 14V battery thru the divider gives a 2.5V AD input
; 2 2.5V AD input gives a $7FE0 AD reading 
;
3C01  A3FC0C36      L3C01 ld    REG_36,$0C[REG_FC]	; ROM hi 16 of 32 bits 9A7E+C=9A8A = 2800
3C05  0134                clr   REG_34				; clr low 16 bits REG_34/35/36/37 = 2800 0000
3C07  A3729032            ld    REG_32,$90[REG_72] <<<< ; raw AD VCAL ! $0110 (if no voltage err = $7FE0)
3C0B  883200        L3C0B cmp   Zero,REG_32			; ck for div by zero ( VCAL regulator is bad)
3C0E  DF05                je    L3C15
3C10  8C3234              divu  REG_34,REG_32		; 28000000 / VCAL = $5014 without voltage error
3C13  D506                jnv   L3C1B
3C15  A1FD8D34      L3C15 ld    REG_34,#$8DFD		; default value for VCAL if AD value=zero - note default=hi limit
3C19  2010                sjmp  L3C2B
; validate VCAL range (SB $5014)
3C1B  89FD8D34      L3C1B cmp   REG_34,#$8DFD		; ROM / VCAL range limit
3C1F  D9F4                jh    L3C15
3C21  89894134            cmp   REG_34,#$4189		; ROM / VCAL range limit
3C25  D904                jh    L3C2B
3C27  A1894134            ld    REG_34,#$4189		; clamp range err
; normalize KEYPWR voltage
3C2B  6FFE1834      L3C2B mulu  REG_34,$18[REG_FE]	; ROM $9E72 = $B32C (gives $380BBF70 w/o voltage err)
3C2F  A03634              ld    REG_34,REG_36		; hi 16 bits of 32 bit result
3C32  6F728C34            mulu  REG_34,$8C[REG_72] <<<<	; raw KEYPWR (17.86% of bat voltage)(result is VBat * 2)(result Hi SB $1BFE w/o errs)
3C36  89E11F36            cmp   REG_36,#$1FE1		; check max voltage in top 16 of 32 bit result (~15.94V)
3C3A  D905                jh    L3C41				; jump if bigger to clamp voltage
3C3C  0D0334              shll  REG_34,#$03			; mult LONG by 8 (now volts * 16)
3C3F  2003                sjmp  L3C44
3C41  B1FF37        L3C41 ldb   REG_37,#$FF			; max voltage
; filter battery voltage level
3C44  AF749332      L3C44 ldbze REG_32,$93[REG_74]	; OLD AD sensor value Lo = $0211 - Battery Voltage Level
3C48  AC3734              ldbze REG_34,REG_37		; NEW AD sensor value Lo
3C4B  EF10FA              lcall L365E				; filter new AD input - battery voltage
3C4E                      word  $D0C7				; filter factors (lookup in ROM)
3C50  C774933e            stb   REG_3E,$93[REG_74]	; updated AD value = $0211 - Battery Voltage Level * 16

3C54  B03E34              ldb   REG_34,REG_3E
3C57  45B200FC32          add   REG_32,REG_FC,#$00B2 ; ROM $9B30 TABLE injector_offset_vs_battery_volts
3C5C  EF58F9              lcall L35B7
3C5F  C7721338            stb   REG_38,$13[REG_72]	; $0193 = PWOFS =  = Injector pulsewidth offset (milliseconds)

3C63  0130                clr   REG_30
3C65  B03831              ldb   REG_31,REG_38
3C68  6D060D30            mulu  REG_30,#$0D06
3C6C  C3720E32            st    REG_32,$0E[REG_72]	; $018E = PWOFF = Injector pulsewidth offset (clock ticks)

3C70  A3749C32            ld    REG_32,$9C[REG_74]	; 
3C74  68AA32              sub   REG_32,REG_AA		; REG_AA is Throttle position
3C77  D30A                jnc   L3C83
3C79  8BF43032            cmp   REG_32,$30[REG_F4]
3C7D  D104                jnh   L3C83
3C7F  C7742000            stb   Zero,$20[REG_74]	; $029E = TAR converted to degrees per second 

; test for intake manifold wetting effect
3C83  B3742030      L3C83 ldb   REG_30,$20[REG_74]	; $029E = TAR converted to degrees per second 
3C87  9BF43430            cmpb  REG_30,$34[REG_F4]	; $900A = AETAR
3C8B  D115                jnh   L3CA2
3C8D  A374DE32            ld    REG_32,$DE[REG_74]	; $025C = engine load (VE?) LOAD
3C91  6B749E32            sub   REG_32,$9E[REG_74]	; AELOAD
3C95  D30B                jnc   L3CA2
3C97  8BF43232            cmp   REG_32,$32[REG_F4]	; AEACLD
3C9B  D105                jnh   L3CA2
3C9D  912029              orb   REG_29,#$20			; set AEOFLG - intake manifold is filling (wetting effect needs compensation)
3CA0  2008                sjmp  L3CAA
3CA2  980030        L3CA2 cmpb  REG_30,Zero
3CA5  D703                jne   L3CAA
3CA7  71DF29              andb  REG_29,#$DF			; clr AEOFLG - no intake wetting effect
3CAA  C3749CAA      L3CAA st    REG_AA,$9C[REG_74]	; OLDTP = REG_AA is Throttle position

3CAE  45E300F432          add   REG_32,REG_F4,#$00E3 ; TABLE $90B9
3CB3  B3748034            ldb   REG_34,$80[REG_74]	; BP - barometric pressure
3CB7  EFFDF8              lcall L35B7				; Interpolate Single var Table R32-table,R34-in,R38-out
3CBA  C7748238            stb   REG_38,$82[REG_74]
3CBE  454601FA32          add   REG_32,REG_FA,#$0146 ; TABLE $98EE
3CC3  B3748034            ldb   REG_34,$80[REG_74]	; BP - barometric pressure
3CC7  EFEDF8              lcall L35B7				; Interpolate Single var Table R32-table,R34-in,R38-out
3CCA  C7748338            stb   REG_38,$83[REG_74]  ; $0201 = MULT_BP212A ???

3CCE  F0                  ret
;
;*******************************************************************
;
;*** DO THIS ON CROSS. R42 CONTAINS EGO NUMERB - EITHER 1 OR 2
; Count the number of times we switch between rich and lean (of stiochoimetric)
; $2A4 - total crosses
; $2A5 - EGO1 crosses
; $2A6 - EGO2 crosses
;
3CCF  2802          L3CCF scall L3CD3					;INCREMENT CROSS COUNT, BANK
3CD1  1142                clrb  REG_42

3CD3  B343A40234    L3CD3 ldb   REG_34,$02A4[REG_42]	;INCREMENT CROSS COUNTER
3CD8  1734                incb  REG_34
3CDA  D302                jnc   L3CDE
3CDC  1534                decb  REG_34					; clamp max to FF
3CDE  C743A40234    L3CDE stb   REG_34,$02A4[REG_42]
3CE3  F0                  ret
;
;*****************************************************************
; Cycling Routine at 2151, routine offset $12 
;
; Update (MPH) vehicle speed variables
;
; $02B2 = unfiltered MPH bp 9
; $02BC = filtered MPH
; $02AC = filtered MPH
;
; see routine $2A15 for click count
;
; Vehicle normalizes gears and tires thru a programmable
; module to provide a standardized 8000 clicks(pulses) per mile
;
; Later ecc corrected 96000000 to 96969600=0x049FB600
;
; MPH = 96 000 000 / (single tick time in IOTimes)
; IOTime = 15Mhz / 3 states / 12 states per hardware IOClock = 416666hz = 0.0000024sec period

; So at 100MPH 
; $2B2 varable(MPH unfiltered) is bp 9 so 512 * 100 = 51200 16bit var value = 96 000 000 / 1875 
; 1875 * 0.0000024 = 0.0045 sec per tick @ 100MPH 
;
; Alternately -
;  100 MPH = 100 * 8000 click/hr = 13333.3 clicks per min = 222.22 clicks per second
;   = 0.0045 sec per click(4.5ms) = 1875 IOTimes per click
; If background loop time is about 20ms then we should see about 4-5 clicks per pass thru this routine @100MPH
; 
; max = MPH variables overflow and clamp at 127.998 MPH
; min = max time delta is 256/1024 sec so .45 / 250 = 1.8MPH
;*****************************************************************
;
; get sample interval time end and click count
3CE4  FA            L3CE4 di
3CE5  FF                  nop						; di instruction waits one instruction before it takes effect(see ref)
3CE6  ACB242              ldbze REG_42,REG_B2		; HSI line 6 count(VSS)
3CE9  A3744030            ld    REG_30,$40[REG_74]	; IO time for last time HSI line 6 went 'high' lo 16
3CED  B3744232            ldb   REG_32,$42[REG_74]	; IO time for last time HSI line 6 went 'high' hi 8
3CF1  11B2                clrb  REG_B2				; zero HSI line 6 count - VSS speed ring clicks (REDUNDANT!)
3CF3  FB                  ei

; start new sample interval
3CF4  0134                clr   REG_34				; preset to zero MPH
3CF6  B3743D36            ldb   REG_36,$3D[REG_74]	; $2BB timer - time since last click
3CFA  99FF36              cmpb  REG_36,#$FF			; timer maxs out(clamps) at $FF = 256/1024 sec = 1/4 sec = 250ms
3CFD  D305                jnc   L3D04				; jmp if we have not timed out
3CFF  71FBC4              andb  REG_C4,#$FB	; 1111 1011 clr interval start flag, start new interval,last click took too long
3D02  202F                sjmp  L3D33				; assume vehicle is stopped

; check for any click count
3D04  980042        L3D04 cmpb  REG_42,Zero			; no clicks?
3D07  D706                jne   L3D0F				; jmp if we have some clicks
3D09  A3743434            ld    REG_34,$34[REG_74]	; NEW MPH = last MPH
3D0D  2028                sjmp  L3D37

; calc time per speed ring click
3D0F  AC3216        L3D0F ldbze REG_16,REG_32		; time hi 8 bits
3D12  4B74443014          sub   REG_14,REG_30,$44[REG_74] ; $2C2 time hi 8 since we started this REG_B2 click count
3D17  BB744616            subcb REG_16,$46[REG_74]	; $2C4 time lo 16 since we started this REG_B2 click count
3D1B  8C4214              divu  REG_14,REG_42		; time interval / click count = time per VSS click
3D1E  D503                jnv   L3D23
3D20  BDFF14              ldbse REG_14,#$FF			; clamp overflow

; calc MPH
3D23  A1B80536      L3D23 ld    REG_36,#$05B8		; External module compensates for tires and gears to get 8000 clicks per mile
3D27  A100D834            ld    REG_34,#$D800		; $05B8D800 = 96 000 000
3D2B  8C1434              divu  REG_34,REG_14		; $05B8D800 / REG_14(time per click) = distance per time (MPH*512)
3D2E  D503                jnv   L3D33
3D30  BDFF34              ldbse REG_34,#$FF			; clamp overflow to ~128MPH

; save unfiltered MPH
3D33  C3743434      L3D33 st    REG_34,$34[REG_74]	; $02B2 NEW unfiltered MPH value (binary point 9)

; save sample interval start for next MPH calc
3D37  C3744430      L3D37 st    REG_30,$44[REG_74]	; $2C2 IOTIme of this sample (lo 16)(used to calc clicks per time)
3D3B  C7744632            stb   REG_32,$46[REG_74]	; $2C4 IOTIme of this sample (hi 8)

; smooth the VSBAR with filter 1
3D3F  A3743E32            ld    REG_32,$3E[REG_74]	; $2BC - vehicle speed filtered(1) (VSBAR)
3D43  EF18F9              lcall L365E				; filter new MPH input (new value to filter in REG_34)
3D46  52D0                word  $D052				; filter factors (lookup in ROM)
3D48  C3743E3E            st    REG_3E,$3E[REG_74]	; updated $02BC - vehicle speed filtered(1) (VSBAR)

; smooth the MPH with filter 2
3D4C  A3742E32            ld    REG_32,$2E[REG_74]	; $02AC - vehicle speed filtered(2) (MPH)
3D50  EF0BF9              lcall L365E				; filter new AD input (new value to filter in REG_34)
3D53  5AD0                word  $D05A				; filter factors (lookup in ROM)
3D55  C3742E3E            st    REG_3E,$2E[REG_74]	; updated $02AC - vehicle speed filtered(2) (MPH)

3D59  F0                  ret
;
;*****************************************************************
; Cycling Routine at 2151, routine offset $10
; Update heated windshield flag - check for some frequency input
;*****************************************************************
;
3D5A  5180EE30      L3D5A andb  REG_30,REG_EE,#$80		; A3C flag
3D5E  5B76383032          subb  REG_32,REG_30,$38[REG_76] ; subtract from last state
3D63  DF08                je    L3D6D					; jump if no state change

3D65  C7763830            stb   REG_30,$38[REG_76]		; last state = current state
3D69  C3762E00            st    Zero,$2E[REG_76]		; zero $03A8 timer A3CTMR

3D6D  A3762E30      L3D6D ld    REG_30,$2E[REG_76]		; $03A8 timer A3CTMR
3D71  8BF00630            cmp   REG_30,$06[REG_F0]		; ROM $8C06 - A3CTT = 250msec
3D75  D104                jnh   L3D7B
3D77  C3763000            st    Zero,$30[REG_76]		; zero $03AA timer HWTMR

3D7B  A3763034      L3D7B ld    REG_34,$30[REG_76]		; $03AA timer HWTMR
3D7F  8BF00834            cmp   REG_34,$08[REG_F0]		; ROM $8C08 - HWRT(300ms)
3D83  D10E                jnh   L3D93

3D85  39E60B              jbs   REG_E6,BIT_01,L3D93		; jmp if HWFLAG - defrost already on
3D88  38E608              jbs   REG_E6,BIT_00,L3D93		; jmp if HWFLGL - first time 
3D8B  9102E6              orb   REG_E6,#$02				; set HWFLAG
3D8E  9101E6              orb   REG_E6,#$01				; set HWFLGL - set first time defrost on
3D91  200C                sjmp  L3D9F

3D93  8BF60A30      L3D93 cmp   REG_30,$0A[REG_F6]		; ROM $8C0A - SSFCTR
3D97  D106                jnh   L3D9F
3D99  3FEE03              jbs   REG_EE,BIT_07,L3D9F		; jmp if A3C - is AC on?
3D9C  71FDE6              andb  REG_E6,#$FD				; clr HWFLAG - turn off defrost flag

3D9F  F0            L3D9F ret
;*****************************************************************
// a = 02FAF080 = 50,000,000 - 2 PIPs per engine revolution (4 cyl eng)
// b = 01FCA055 = 33,333,333 - 3 PIPs per engine revolution (6 cyl eng)
// c = 017D7840 = 25,000,000 - 4 PIPs per engine revolution (8 cyl eng)
3DA0  FA02        word  $02FA a
3DA2  FC01		  word  $01FC b
3DA4  7D01		  word  $017D c

3DA6  80F0		  word  $F080 a
3DA8  55A0		  word  $A055 b
3DAA  4078		  word  $7840 c
;
;*****************************************************************
; Cycling Routine at 2151, routine offset $14
;
; Update RPM var - filtering as required and other stuff
; REG_AE - raw unfiltered RPM ( REG_AE = engine RPM * 4 )
; $0108 RPM with filter 1
; $027C RPM with filter 2
;
;*****************************************************************
;
3DAC  A1330314      L3DAC ld    REG_14,#$0333
3DB0  8B72BE14            cmp   REG_14,$BE[REG_72]	; $013E - timer? time since last PIP recieved
3DB4  D93B                jh    L3DF1				; jump if #$0333 > timer
3DB6  0136                clr   REG_36				; RPM = 0?
3DB8  71EF2D              andb  REG_2D,#$EF			; clr flag bit 4 FIRST_PIP
3DBB  B10132              ldb   REG_32,#$01
3DBE  C774EC32            stb   REG_32,$EC[REG_74]	; INJ_PIP_CNT1
3DC2  C774ED32            stb   REG_32,$ED[REG_74]	; INJ_PIP_CNT2
3DC6  712F2E              andb  REG_2E,#$2F			; clr flag bits 7,6,4
3DC9  9BF81A00            cmpb  Zero,$1A[REG_F8]	; ROM addr $944A = 0CCDSW = Calibration Switch to select Computer Controlled Dwell. (1 = Computer Controlled Dwell, 0 = TFI Controlled Dwell)
3DCD  DF0D                je    L3DDC				; jump always

Computer Controlled Dwell
3DCF  FA                  di
3DD0  FF                  nop						; di waits one instruction?
3DD1  A1962292            ld    REG_92,#$2296		; short entry 2284 - spout?
3DD5  91084C              orb   REG_4C,#$08			; IMMEDIATE = flag that indicates that the output is to be placed in the hardware output carousel as soon as possible
3DD8  EFE2E5              lcall L23BD				; send HSO command 55 ands lots of other stuff - spout?
3DDB  FB                  ei

;TFI Controlled Dwell
3DDC  9BF81900      L3DDC cmpb  Zero,$19[REG_F8]	; ROM addr $9449 = 0 HP_HIDRES = Hardware present - High Data Rate Electronic Spark
3DE0  DF0D                je    L3DEF				; jump always - REG_36 is new RPM?

3DE2  FA                  di
3DE3  FF                  nop
3DE4  A19E2292            ld    REG_92,#$229E		; 2nd short entry 2284 - spout?
3DE8  91084C              orb   REG_4C,#$08			; IMMEDIATE = flag that indicates that the output is to be placed in the hardware output carousel as soon as possible
3DEB  EFCFE5              lcall L23BD				; send HSO command C5 ands lots of other stuff - spout?
3DEE  FB                  ei

3DEF  2025          L3DEF sjmp  L3E16				; REG_36 is new RPM?

3DF1  334E4E        L3DF1 jbc   REG_4E,BIT_03,L3E42	; check bit 3 = New RPM Flag
3DF4  71F74E              andb  REG_4E,#$F7			; clr bit 3 = New RPM Flag

3DF7  AFFE0730            ldbze REG_30,$07[REG_FE]	; ROM $9E5A+7 = 9E61 value = $08=ENGCYL=Number of cylinders per engine revolution

; 32 bit degrees of crank rotation in REG_34/35/36/37 = $017D 7840 = 25,000,000 dec
3DFB  A3319C3D36          ld    REG_36,$3D9C[REG_30]	; Hi 16 from data table above 3D9C+8=3DA4 @ $017D
3E00  A331A23D34          ld    REG_34,$3DA2[REG_30]	; Lo 16 3DA2+8=3DAA @ $7840

; 24 bit time for the above rotation
3E05  A0BA38              ld    REG_38,REG_BA		; 16 bits Lo of PIP time
3E08  ACBC3A              ldbze REG_3A,REG_BC		; 8 bits Hi of PIP time

3E0B  0F3038              norml REG_38,REG_30		; normalize the time value REG_38/39/3A/00 (most signif bits in R3A/3B)
3E0E  8C3A34              divu  REG_34,REG_3A		; div table value by normlized R38(revolutions / time = RPM)
3E11  0136                clr   REG_36				; engine RPM is in bottom bits of LONG shift
3E13  0D3034              shll  REG_34,REG_30		; new RPM

3E16  A036AE        L3E16 ld    REG_AE,REG_36		; set REG_AE = engine RPM * 4 bp=2

3E19  080636              shr   REG_36,#$06			; rpm >> 6
3E1C  980037              cmpb  REG_37,Zero			; overflow 8 bits?
3E1F  DF03                je    L3E24
3E21  B1FF36              ldb   REG_36,#$FF
3E24  C7742136      L3E24 stb   REG_36,$21[REG_74]	; 8 bit rpm bp=-4 = N_BYTE = $029F
; 
; filter RPM - using filter A
;
3E28  EF29F8              lcall L3654
3E2B  0801                word  $0108	; Old AD sensor address - filtered RPM
3E2D  AE00                word  $00AE	; new AD sensor address - unfiltered RPM
3E2F  4CD0                word  $D04C	; funny index for difference filter
3E31  C372883E            st    REG_3E,$88[REG_72] ; filtered sensor output - in place ($0108) - filtered RPM
; 
; filter RPM - using filter B
;
3E35  EF1CF8              lcall L3654
3E38  7C02                word  $027C	; Old AD sensor address - filter 2 RPM
3E3A  AE00                word  $00AE	; new AD sensor address - unfiltered RPM
3E3C  5CD0                word  $D05C	; funny index for difference filter
3E3E  C374FE3E            st    REG_3E,$FE[REG_74] ; filtered sensor output - in place ($027c) - filtered(2) RPM

3E42  A3FC2E32      L3E42 ld    REG_32,$2E[REG_FC]	; ROM
3E46  080432              shr   REG_32,#$04			; div by 16
3E49  7FFC3332            mulub REG_32,$33[REG_FC]	; ROM
3E4D  9FFC3232            divub REG_32,$32[REG_FC]	; ROM $9AB0 - 8 - number of cylinders
3E51  C7764432            stb   REG_32,$44[REG_76]

3E55  AFFE0714            ldbze REG_14,$07[REG_FE]	; ROM $9E5A+7 = 9E61 value = $08=ENGCYL=Number of cylinders per engine revolution
3E59  69040014            sub   REG_14,#$0004		; $08 - $04 = $04
3E5D  CB15C427            push  $27C4[REG_14]		; $27C4 + $04 = $27C8 contents = $80
3E61  CF7648              pop   $48[REG_76]			; $48[REG_76] = #$80

; set/clr bit 3 in REG_25 based on ROM values
; set up minimum pip interval - this probably limits engine speed
3E64  64F014              add   REG_14,REG_F0		; ROM REG_14 = $8C00 + $04 = $8C04
3E67  CB1412              push  $12[REG_14]			; $8C04 + $12 = $8C16 contents = $03C1 Minimum PIP period for 8-cylinder engine, clock ticks
3E6A  CF7646              pop   $46[REG_76]			; $0E[REG_76] = #$C1

3E6D  8BFE0E00            cmp   Zero,$0E[REG_FE]	; ROM $9E68 MHPFD = $33 51 = 50% pip duty cycle
3E71  D605                jge   L3E78
3E73  71FB25              andb  REG_25,#$FB			; clr REG_25 bit 3 
3E76  2003                sjmp  L3E7B
3E78  910425        L3E78 orb   REG_25,#$04			; set REG_25 bit 3
3E7B  F0            L3E7B ret
;
;*****************************************************************
; Cycling Routine at 2151, routine offset $20
;*****************************************************************
;
3E7C  A3F44236      L3E7C ld    REG_36,$42[REG_F4]
3E80  9FFE0736            divub REG_36,$07[REG_FE]	; ROM $9E5A+7 = 9E61 value = $08=ENGCYL=Number of cylinders per engine revolution
3E84  D503                jnv   L3E89
3E86  B1FF36              ldb   REG_36,#$FF
3E89  1137          L3E89 clrb  REG_37
3E8B  0134                clr   REG_34
3E8D  8CAE34              divu  REG_34,REG_AE		; REG_AE = engine RPM * 4
3E90  D503                jnv   L3E95
3E92  BDFF34              ldbse REG_34,#$FF
3E95  C374D634      L3E95 st    REG_34,$D6[REG_74]
3E99  9BF60800            cmpb  Zero,$08[REG_F6]
3E9D  DF05                je    L3EA4
3E9F  910226              orb   REG_26,#$02
3EA2  2003                sjmp  L3EA7
3EA4  71FD26        L3EA4 andb  REG_26,#$FD
3EA7  45DE00F0      L3EA7 add   REG_32,REG_F0,#$00DE	; TABLE $8CDE spark_table_RPM_scaling
      32
3EAC  A0AE34              ld    REG_34,REG_AE			; REG_AE = engine RPM * 4
3EAF  EF5AF7              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
3EB2  A038A6              ld    REG_A6,REG_38
3EB5  45B200F0            add   REG_32,REG_F0,#$00B2	; TABLE $8CB2 - ECC Load Scaling - emission_table_load_scaling
      32
3EBA  A374DE34            ld    REG_34,$DE[REG_74]	    ; raw engine load (VE?)
3EBE  EF4BF7              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
3EC1  A038A8              ld    REG_A8,REG_38
3EC4  A0A630              ld    REG_30,REG_A6
3EC7  A0A832              ld    REG_32,REG_A8
3ECA  AD0A34              ldbze REG_34,#$0A
3ECD  452201FC            add   REG_38,REG_FC,#$0122	; ROM TABLE $9BA0 - (N,LOAD) = Air Meter Backflow Correction Table
      38
3ED2  EF15F8              lcall L36EA					; Interpolate two var table R38-Table
3ED5  C776393B            stb   REG_3B,$39[REG_76]
3ED9  452E02F4            add   REG_32,REG_F4,#$022E	; TABLE $9204 ??? vs RPM
      32
3EDE  A0AE34              ld    REG_34,REG_AE			; REG_AE = engine RPM * 4
3EE1  EF28F7              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
3EE4  C3762C38            st    REG_38,$2C[REG_76]

; calc air mass rate for entire engine
3EE8  A374D430            ld    REG_30,$D4[REG_74]		; $0252 ARCHG = Air Charge Mass inducted per Intake Stroke, lbm/Intake.
3EEC  AFFE0732            ldbze REG_32,$07[REG_FE]		; ROM $9E5A+7 = 9E61 value = $08=ENGCYL=Number of cylinders per engine revolution
3EF0  6C3230              mulu  REG_30,REG_32
3EF3  0C0330              shrl  REG_30,#$03
3EF6  6CAE30              mulu  REG_30,REG_AE			; REG_AE = engine RPM * 4
3EF9  0C0E30              shrl  REG_30,#$0E
3EFC  880032              cmp   REG_32,Zero
3EFF  DF03                je    L3F04
3F01  BDFF30              ldbse REG_30,#$FF				; clamp
3F04  C0A230        L3F04 st    REG_30,REG_A2			; REG_A2 = AM = Air mass flow for the engine (lb/min)

3F07  A372DE3E            ld    REG_3E,$DE[REG_72]		; $015E - (FAM) Filtered Air Mass
3F0B  08013E              shr   REG_3E,#$01
3F0E  A372A63C            ld    REG_3C,$A6[REG_72]		; $0126 - RATCH=Closed TP
3F12  67F46A3C            add   REG_3C,$6A[REG_F4]		; ROM DELRAT = Throttle position adder to RATCH. Should be set equal to DELTA + HYSTS (See throttle mode select logic).  ..Typical value - 15 counts
3F16  47FE243C            add   REG_38,REG_3C,$24[REG_FE]	; ROM $9E7E DLHYST = TP hysteresis on exit from FAM.
      38
3F1B  88AA38              cmp   REG_38,REG_AA			; REG_AA is Throttle position
3F1E  D322                jnc   L3F42
3F20  B372E638            ldb   REG_38,$E6[REG_72]		; $0166 DSDRPM = Desired RPM (from ISC logic).
3F24  9BFE1E38            cmpb  REG_38,$1E[REG_FE]		; ROM $9E78 AMDESN = Desired RPM threshold to enter Idle AM logic, RPM
3F28  D918                jh    L3F42
3F2A  77FE1F38            addb  REG_38,$1F[REG_FE]		; ROM $9E79 AMRPM = Actual RPM (byte) threshold to enter Idle AM logic
3F2E  DB2A                jc    L3F5A
3F30  9B742138            cmpb  REG_38,$21[REG_74]
3F34  DB24                jc    L3F5A
3F36  77FE2038            addb  REG_38,$20[REG_FE]		; ROM $9E7A AMRPMH = RPM (byte) threshold hysteresis
3F3A  DB75                jc    L3FB1
3F3C  9B742138            cmpb  REG_38,$21[REG_74]
3F40  DB6F                jc    L3FB1
3F42  71F7EC        L3F42 andb  REG_EC,#$F7
3F45  A3FE263C            ld    REG_3C,$26[REG_FE]		; ROM $9E80 IFAM = Initial FAM - Upper FAM clip on exit from FAM
3F49  08013C              shr   REG_3C,#$01
3F4C  883C3E              cmp   REG_3E,REG_3C
3F4F  D107                jnh   L3F58
3F51  09013C              shl   REG_3C,#$01
3F54  C372DE3C            st    REG_3C,$DE[REG_72]		; $015E - (FAM) Filtered Air Mass
3F58  20A2          L3F58 sjmp  L3FFC

3F5A  88AA3C        L3F5A cmp   REG_3C,REG_AA			; REG_AA is Throttle position
3F5D  D352                jnc   L3FB1
3F5F  3BEC4F              jbs   REG_EC,BIT_03,L3FB1
3F62  9108EC              orb   REG_EC,#$08				; TFQ1?
3F65  C372B200            st    Zero,$B2[REG_72]		; zero $0132 timer - FFMTMR = FILTERED AIR MASS filter Timer, sec
3F69  AFFE2230            ldbze REG_30,$22[REG_FE]		; ROM $9E7C contents $66 = EFAMPL = Lower (AMPEM-EM) clip on entry to FAM
3F6D  6C3E30              mulu  REG_30,REG_3E
3F70  0C0730              shrl  REG_30,#$07
3F73  8830A2              cmp   REG_A2,REG_30			; REG_A2 = AM = Air mass flow for the engine (lb/min) : ?
3F76  DB05                jc    L3F7D
3F78  A030A2              ld    REG_A2,REG_30			; REG_A2 = AM = Air mass flow for the engine (lb/min)
3F7B  2012                sjmp  L3F8F

3F7D  AFFE2130      L3F7D ldbze REG_30,$21[REG_FE]		; ROM $9E7B contents $9A = EFAMPH = Upper (AMPEM-EM) clip on entry to FAM
3F81  6C3E30              mulu  REG_30,REG_3E
3F84  0C0730              shrl  REG_30,#$07
3F87  8830A2              cmp   REG_A2,REG_30			; REG_A2 = AM = Air mass flow for the engine (lb/min)
3F8A  D103                jnh   L3F8F
3F8C  A030A2              ld    REG_A2,REG_30			; REG_A2 = AM = Air mass flow for the engine (lb/min)
3F8F  A3F44A32      L3F8F ld    REG_32,$4A[REG_F4]		; ROM$9020 - FAMINC = FAM increment/decrement when entering FAM region, lb/min
3F93  0A0132              shra  REG_32,#$01
3F96  44A2323E            add   REG_3E,REG_32,REG_A2	; REG_A2 = AM = Air mass flow for the engine (lb/min)
3F9A  3F3307              jbs   REG_33,BIT_07,L3FA4
3F9D  D309                jnc   L3FA8
3F9F  BDFF3E              ldbse REG_3E,#$FF
3FA2  2004                sjmp  L3FA8
3FA4  DB02          L3FA4 jc    L3FA8
3FA6  013E                clr   REG_3E
3FA8  09013E        L3FA8 shl   REG_3E,#$01
3FAB  C372DE3E            st    REG_3E,$DE[REG_72]		; $015E - (FAM) Filtered Air Mass
3FAF  2045                sjmp  L3FF6
3FB1  33EC42        L3FB1 jbc   REG_EC,BIT_03,L3FF6		; REFFLG = Flag indicating (when set) that conditions to enter the filtered region have been satisfied.Flag is also referenced by adaptive fuel control to indicate when to use/update specific idle cells
3FB4  483EA240            sub   REG_40,REG_A2,REG_3E	; REG_A2 = AM = Air mass flow for the engine (lb/min)
3FB8  D602                jge   L3FBC
3FBA  0340                neg   REG_40
3FBC  A3F47E34      L3FBC ld    REG_34,$7E[REG_F4]		; ROM
3FC0  6CA234              mulu  REG_34,REG_A2			; REG_A2 = AM = Air mass flow for the engine (lb/min)
3FC3  883640              cmp   REG_40,REG_36
3FC6  D12E                jnh   L3FF6
3FC8  B372EA34            ldb   REG_34,$EA[REG_72]
3FCC  1734                incb  REG_34
3FCE  9BF46C34            cmpb  REG_34,$6C[REG_F4]		; ROM
3FD2  D324                jnc   L3FF8
3FD4  A03E32              ld    REG_32,REG_3E
3FD7  A0A234              ld    REG_34,REG_A2			; REG_A2 = AM = Air mass flow for the engine (lb/min)
3FDA  A3FA4A36            ld    REG_36,$4A[REG_FA]		; ROM
3FDE  A372B23E            ld    REG_3E,$B2[REG_72]		; $0132 timer?
3FE2  C372B200            st    Zero,$B2[REG_72]		; zero $0132 timer?
3FE6  9101CA              orb   REG_CA,#$01
3FE9  EF77F6              lcall L3663
3FEC  09013E              shl   REG_3E,#$01
3FEF  C372DE3E            st    REG_3E,$DE[REG_72]		; $015E - (FAM) Filtered Air Mass
3FF3  08013E              shr   REG_3E,#$01
3FF6  1134          L3FF6 clrb  REG_34
3FF8  C772EA34      L3FF8 stb   REG_34,$EA[REG_72]
3FFC  3BEC0F        L3FFC jbs   REG_EC,BIT_03,L400E
3FFF  1132                clrb  REG_32
4001  2003                sjmp  L4006
4003  B18032        L4003 ldb   REG_32,#$80
4006  71F725        L4006 andb  REG_25,#$F7
4009  A0A23E              ld    REG_3E,REG_A2			; REG_A2 = AM = Air mass flow for the engine (lb/min)
400C  202C                sjmp  L403A
400E  B1FF32        L400E ldb   REG_32,#$FF
4011  A3FE1C34            ld    REG_34,$1C[REG_FE]		; ROM $9E76 DELTAM = Multiplier of the filtered air mass. Establishes a threshold which  if  exceeded  by  the  instantaneous AM, forces the AM register to reference the instantaneous AM value. This provides a breakout capacity of the filtered routine which may be necessary due to unanticipated loads at idle.  ..Typical value - 1.15 contents $0000
4015  6C3E34              mulu  REG_34,REG_3E
4018  0D0134              shll  REG_34,#$01
401B  DB08                jc    L4025
401D  8836A2              cmp   REG_A2,REG_36			; REG_A2 = AM = Air mass flow for the engine (lb/min)
4020  D9E1                jh    L4003
4022  910825              orb   REG_25,#$08
4025  A3F58000      L4025 ld    REG_34,$0080[REG_F4]	; ROM $9056 MAXFAM contents $00A0 = Multiplier of the instantaneous AM value
      34
402A  6CA234              mulu  REG_34,REG_A2			; REG_A2 = AM = Air mass flow for the engine (lb/min)
402D  0D0134              shll  REG_34,#$01
4030  DB08                jc    L403A
4032  88363E              cmp   REG_3E,REG_36
4035  D103                jnh   L403A
4037  A0363E              ld    REG_3E,REG_36
403A  8BFE1A3E      L403A cmp   REG_3E,$1A[REG_FE]		; ROM $9E74 Minimum Air Mass Clip, lb air/min
403E  DB04                jc    L4044
4040  A3FE1A3E            ld    REG_3E,$1A[REG_FE]		; ROM $9E74 Minimum Air Mass Clip, lb air/min
4044  C0A23E        L4044 st    REG_3E,REG_A2			; REG_A2 = AM = Air mass flow for the engine (lb/min)

4047  C772E732            stb   REG_32,$E7[REG_72]
404B  AF740A38            ldbze REG_38,$0A[REG_74]		; $0288 EM - EGR Mass Flow
404F  090338              shl   REG_38,#$03
4052  64A238              add   REG_38,REG_A2			; REG_A2 = AM = Air mass flow for the engine (lb/min)
4055  D303                jnc   L405A
4057  BDFF38              ldbse REG_38,#$FF				; clamp max to $FFFF
405A  A038A4        L405A ld    REG_A4,REG_38
405D  A374D43E            ld    REG_3E,$D4[REG_74]		; $0252 ARCHG = Air Charge Mass inducted per Intake Stroke, lbm/Intake.
4061  013C                clr   REG_3C
4063  0C033C              shrl  REG_3C,#$03
4066  8FF4443C            divu  REG_3C,$44[REG_F4]		; ROM $901A engine_displacement contents = $1B4A = 6986 - engine_displacement ( one unit = 0.0430981 Cubic Inches)
406A  D503                jnv   L406F
406C  BDFF3C              ldbse REG_3C,#$FF				; clamp max to $FFFF
406F  C374DE3C      L406F st    REG_3C,$DE[REG_74]	   	; SET engine load (VE?)$025C

; speed density VE calc? RPM*BP/#$00EF = ???
4073  451202FC32          add   REG_32,REG_FC,#$0212	; ROM TABLE $9C90 FN035(N) = Peak load at sea level as a function of RPM
4078  A0AE34              ld    REG_34,REG_AE			; REG_AE = engine RPM * 4
407B  EF8EF5              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
407E  AF748030            ldbze REG_30,$80[REG_74]		; BP - barometric pressure
4082  6C3830              mulu  REG_30,REG_38			; BP * f(RPM)
4085  8DEF0030            divu  REG_30,#$00EF
4089  D503                jnv   L408E
408B  BDFF30              ldbse REG_30,#$FF				; clamp max to $FFFF
408E  C374E030      L408E st    REG_30,$E0[REG_74]		; $025E Air FLow??

4092  9BFC0200            cmpb  Zero,$02[REG_FC]		; ROM
4096  D710                jne   L40A8					; never jmps in this ROM
4098  A03C3E              ld    REG_3E,REG_3C
409B  013C                clr   REG_3C					; clr hi word
409D  0C013C              shrl  REG_3C,#$01				; div by 2
40A0  8C303C              divu  REG_3C,REG_30			; air flow / (RPM * CID) = VE
40A3  D503                jnv   L40A8
40A5  BDFF3C              ldbse REG_3C,#$FF				; clamp max to $FFFF
40A8  C374E23C      L40A8 st    REG_3C,$E2[REG_74]		; $0260 Volumetric Efficiency

40AC  EFA5F5              lcall L3654
40AF  1C02                word  $021C					; Old AD sensor address - AELOAD
40B1  5C02                word  $025C					; new AD input address - VE LOAD
40B3  54D0                word  $D054					; funny index for difference filter
40B5  C3749E3E            st    REG_3E,$9E[REG_74]		; filtered sensor output $021C

40B9  F0                  ret
;
;*****************************************************************
; Cycling Routine at 2151, routine offset $24
; Update EGR stuff?
;*****************************************************************
;
40BA  36E64A        L40BA jbc   REG_E6,BIT_06,L4107 ; jmp if not PFEHP_FLG - Switch to select EGR strategy
40BD  3FA13C              jbs   REG_A1,BIT_07,L40FC	; jump if CRANKING

40C0  EF91F5              lcall L3654
40C3  0401                word  $0104				; Old AD sensor address - filtered EPT
40C5  1601                word  $0116				; new AD sensor address - EVP AD raw h/w read
40C7  48D0                word  $D048				; funny index for difference filter
40C9  C372843E            st    REG_3E,$84[REG_72] 	; filtered sensor output $0104 - filtered EPT

40CD  37D02A              jbc   REG_D0,BIT_07,L40FA ; jmp if throttle not closed
40D0  77FA3000            addb  Zero,$30[REG_FA]	; ROM
40D4  DF24                je    L40FA
40D6  AF72E630            ldbze REG_30,$E6[REG_72]	; $0166
40DA  090630              shl   REG_30,#$06
40DD  67FA3230            add   REG_30,$32[REG_FA]	; ROM
40E1  8830AE              cmp   REG_AE,REG_30		; REG_AE = engine RPM * 4
40E4  D914                jh    L40FA
40E6  9BFA34B0            cmpb  REG_B0,$34[REG_FA]	; CMP Engine Coolant Temperature - degrees F ?
40EA  DE0E                jlt   L40FA

40EC  EF65F5              lcall L3654
40EF  EE07                word  $07EE				; Old AD sensor address - filtered EVP saved in KAM 
40F1  1601                word  $0116				; new AD sensor address - EVP AD raw h/w read
40F3  48D0                word  $D048				; funny index for difference filter
40F5  C301EE073E          st    REG_3E,$07EE[Zero] 	; filtered sensor output - filtered EVP saved in KAM 
      
40FA  2027          L40FA sjmp  L4123

40FC  A301EE0730    L40FC ld    REG_30,$07EE[Zero]	; filtered EVP saved in KAM 
4101  C3728430            st    REG_30,$84[REG_72]	; $0104 filtered EVP
4105  2039                sjmp  L4140

4107  37A102        L4107 jbc   REG_A1,BIT_07,L410C	; jump if not CRANKING
410A  2034                sjmp  L4140

410C  EF45F5        L410C lcall L3654
410F  0201                word  $0102				; Old AD sensor address - filtered EGR 
4111  7001                word  $0170				; new AD sensor address EVP
4113  60D0                word  $D060				; funny index for difference filter
4115  C372823E            st    REG_3E,$82[REG_72] 	; filtered sensor output ($0102) - filtered EGR

4119  8B72A83E            cmp   REG_3E,$A8[REG_72]
411D  DB04                jc    L4123
411F  C372A83E            st    REG_3E,$A8[REG_72]

4123  EF2EF5        L4123 lcall L3654
4126  0001                word  $0100				; Old AD sensor address - filtered TP
4128  AA00                word  $00AA				; new AD sensor address - throttle position
412A  4ED0                word  $D04E				; funny index for difference filter
412C  C372803E            st    REG_3E,$80[REG_72] 	; filtered sensor output $0100 - filtered TP

4130  890807AE            cmp   REG_AE,#$0708		; REG_AE = engine RPM * 4 ($708=1800) / 4 = 450 RPM
4134  D10A                jnh   L4140
4136  8B72A63E            cmp   REG_3E,$A6[REG_72]	; $0126 - RATCH=Closed TP
413A  DB04                jc    L4140				; jmp if TP >= RATCH
413C  C372A63E            st    REG_3E,$A6[REG_72]	; update to smaller RATCH=Closed TP (Ratch is closed TP position - minimum)
4140  F0            L4140 ret
;
;*****************************************************************
; Cycling Routine at 2151, routine offset $26
;
; Check for RPM and Speed limiters
;
; RPM values here are RPM * 4
;
; ************** THESE ARE NOT STOCK REV LIMITS ! ******************* causes ROM checksum error in my 'stock' a9l.bin
;
;*****************************************************************
;
4141  450400FC42    L4141 add   REG_42,REG_FC,#$0004	; ROM $9A82 -  NLM_SH = Overspeed RPM, sets stage 3 fuel limiter
4146  8A43AE              cmp   REG_AE,[REG_42]+		; REG_AE = engine RPM * 4 : ($9A82) $7D00 - 8000 RPM Half fuel ON
4149  D103                jnh   L414E					; jmp if RPM < 8000
414B  91082F              orb   REG_2F,#$08				; set NLMT_FLG - limit fuel to half
414E  8A43AE        L414E cmp   REG_AE,[REG_42]+		; REG_AE = engine RPM * 4 : ($9A84) $7530 - 7500 RPM HAlf fuel OFF
4151  DB03                jc    L4156					; jump if RPM < 7500
4153  71F72F              andb  REG_2F,#$F7				; REG_2F bit 3 CLR
4156  9BF24700      L4156 cmpb  Zero,$47[REG_F2]		; ROM $8EA1 - VSTYPE (are we tracking vehcle speed) = $01
415A  D707                jne   L4163
415C  71FBE7              andb  REG_E7,#$FB				; REG_E7 bit 2 CLR
415F  71FEE7              andb  REG_E7,#$FE				; REG_E7 bit 1 CLR
4162  F0                  ret

4163  B3743F30      L4163 ldb   REG_30,$3F[REG_74]		; $2BD - vehicle speed filtered(1) (MPH) $02BC is 8.8 format VSS
4167  9A4330              cmpb  REG_30,[REG_42]+		; ROM $9A86 - Speed Limiter A = FF ON
416A  D103                jnh   L416F					; jmp if speed < $FF (ALWAYS)
416C  912025              orb   REG_25,#$20				; REG_25 bit 5 ON (SLQ1)
416F  9A4330        L416F cmpb  REG_30,[REG_42]+		; ROM $9A88 - Speed Limiter A = FF OFF
4172  DB03                jc    L4177					; jmp if speed < $FF
4174  71DF25              andb  REG_25,#$DF				; REG_25 bit 5 OFF

4177  9A4330        L4177 cmpb  REG_30,[REG_42]+		; ROM $9A8A - Speed Limiter B = FF ON
417A  D90D                jh    L4189					; jump if speed <= ROM limit
417C  38E70A              jbs   REG_E7,BIT_00,L4189
417F  9A4230              cmpb  REG_30,[REG_42]			; ROM $9A8C - Speed Limiter B = FF OFF
4182  DB08                jc    L418C					; jmp if speed >= ROM limit
4184  71EF25              andb  REG_25,#$EF				; REG_25 bit 4 OFF
4187  2003                sjmp  L418C

4189  911025        L4189 orb   REG_25,#$10				; REG_25 bit 4 ON
418C  352504        L418C jbc   REG_25,BIT_05,L4193
418F  9101E7              orb   REG_E7,#$01				; REG_E7 bit 0 ON
4192  F0                  ret

4193  342507        L4193 jbc   REG_25,BIT_04,L419D
4196  9104E7              orb   REG_E7,#$04				; REG_E7 bit 2 ON - HSPFLG = High speed mode flag; 1 = High speed alternate fuel/spark
4199  71FEE7              andb  REG_E7,#$FE				; REG_E7 bit 0 OFF - FOFFLG =  Alternate  injector  fire  enable  flag;  1  =  fire  alternate injectors
419C  F0                  ret

419D  71FBE7        L419D andb  REG_E7,#$FB				; REG_E7 bit 1 OFF -  FGFFLG = Toggle flag for alternate Injector Firing, = 1 No firing on this injector
41A0  F0                  ret
;
;*****************************************************************
; Cycling Routine at 2151, routine offset $28
; Update closed loop flags
; Update warm EGO flags
;*****************************************************************
;
41A1  A3FA0E30      L41A1 ld    REG_30,$0E[REG_FA]		; ROM $97B6 LDMH
41A5  47FA1030            add   REG_32,REG_30,$10[REG_FA]	; ROM $97B8 LDMHH
      32
41AA  8B74E232            cmp   REG_32,$E2[REG_74]		; $0260 Volumetric Efficiency
41AE  D905                jh    L41B5
41B0  9101E9              orb   REG_E9,#$01				; set LDFlag
41B3  2009                sjmp  L41BE

41B5  8B74E230      L41B5 cmp   REG_30,$E2[REG_74]		; $0260 Volumetric Efficiency
41B9  D103                jnh   L41BE
41BB  71FEE9              andb  REG_E9,#$FE				; clr LDFlag
41BE  30E921        L41BE jbc   REG_E9,BIT_00,L41E2		; LDFlag
41C1  38D01E              jbs   REG_D0,BIT_00,L41E2		; jmp if throttle is closed or wide open
41C4  9BFA0AB0            cmpb  REG_B0,$0A[REG_FA]		; Engine Coolant Temperature - degrees F ? ROM $97B2 - LDEL 254?
41C8  DA18                jle   L41E2
41CA  9BFA0BB0            cmpb  REG_B0,$0B[REG_FA]		; Engine Coolant Temperature - degrees F ? ROM $97B3 - LDEH 220?
41CE  D612                jge   L41E2
41D0  B372C542            ldb   REG_42,$C5[REG_72]		; $145 - LUGTMR
41D4  9BFA0D42            cmpb  REG_42,$0D[REG_FA]		; ROM $97B5 - LDLTM
41D8  D308                jnc   L41E2
41DA  31EF05              jbc   REG_EF,BIT_01,L41E2		; jmp if not WMEGOL
41DD  9102E9              orb   REG_E9,#$02				; set LDFLG
41E0  2003                sjmp  L41E5

41E2  71FDE9        L41E2 andb  REG_E9,#$FD				; clr LDFLG
41E5  450E00FC30    L41E5 add   REG_30,REG_FC,#$000E	; ROM $9A8C
41EA  EF62F5              lcall L374F
41ED  DB10                jc    L41FF
41EF  B3742630            ldb   REG_30,$26[REG_74]		; $2A4 - EGOSSS
41F3  9BFC1A30            cmpb  REG_30,$1A[REG_FC]		; ROM $9A98 - EGOCL1 = 1
41F7  D306                jnc   L41FF
41F9  9104EF              orb   REG_EF,#$04				; set WRMEGO
41FC  9102EF              orb   REG_EF,#$02				; set WMEGOL
41FF  A3FC1C32      L41FF ld    REG_32,$1C[REG_FC]		; ROM $9A9A open_loop_minimum_load(min load for OL control)
4203  8B74DE32            cmp   REG_32,$DE[REG_74]	    ; engine load (VE?)
4207  DB05                jc    L420E
4209  9108EE              orb   REG_EE,#$08				; set QCLOL
420C  200F                sjmp  L421D
420E  6BFC1E32      L420E sub   REG_32,$1E[REG_FC]		; ROM $9A9C min_load_for_closed_loop 
4212  D309                jnc   L421D
4214  8B74DE32            cmp   REG_32,$DE[REG_74]	    ; engine load (VE?)
4218  D103                jnh   L421D
421A  71F7EE              andb  REG_EE,#$F7				; clr QCLOL
421D  452E02FC      L421D add   REG_32,REG_FC,#$022E	; ROM TABLE $9CAC
      32
4222  BCB034              ldbse REG_34,REG_B0			; Engine Coolant Temperature - degrees F ?
4225  EFD9F3              lcall L3601					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
4228  8B74E238            cmp   REG_38,$E2[REG_74]		; $0260 Volumetric Efficiency
422C  D105                jnh   L4233
422E  910129              orb   REG_29,#$01				; set TAQ6
4231  2012                sjmp  L4245

4233  67FC2038      L4233 add   REG_38,$20[REG_FC]		; ROM $9A9E HLODH = Upper LOAD Limit for Closed Loop Fuel Control,unitless
4237  D303                jnc   L423C
4239  BDFF38              ldbse REG_38,#$FF
423C  8B74E238      L423C cmp   REG_38,$E2[REG_74]		; $0260 Volumetric Efficiency
4240  DB03                jc    L4245
4242  71FE29              andb  REG_29,#$FE
4245  A3FC1438      L4245 ld    REG_38,$14[REG_FC]		; ROM $9A92 word open_loop_tp_Voltage (throttle position to force open loop (TPS voltage - 1))
4249  6772A638            add   REG_38,$A6[REG_72]		; $0126 - RATCH=Closed TP
424D  DB05                jc    L4254
424F  88AA38              cmp   REG_38,REG_AA			; REG_AA is Throttle position
4252  D305                jnc   L4259
4254  910429        L4254 orb   REG_29,#$04				; set QTPCLOL
4257  200E                sjmp  L4267
4259  67FA0438      L4259 add   REG_38,$04[REG_FA]		; ROM $97AC - HYST2 Hysteresis term to enter WOT mode
425D  DB08                jc    L4267
425F  88AA38              cmp   REG_38,REG_AA			; REG_AA is Throttle position
4262  DB03                jc    L4267
4264  71FB29              andb  REG_29,#$FB				; clr TAQ1
4267  33EE49        L4267 jbc   REG_EE,BIT_03,L42B3		; jmp if not QCLOL
426A  322946              jbc   REG_29,BIT_02,L42B3		; jmp if not QTPCLOL
426D  32EF43              jbc   REG_EF,BIT_02,L42B3		; jmp if not WRMEGO
4270  9BFC53B3            cmpb  REG_B3,$53[REG_FC]		; ROM $9AD1 - PIPNUM
4274  D73D                jne   L42B3
4276  36253A              jbc   REG_25,BIT_06,L42B3		; jmp if not CHKAIR
4279  3AE737              jbs   REG_E7,BIT_02,L42B3		; jmp if HSPFLG
427C  39E934              jbs   REG_E9,BIT_01,L42B3		; jmp if LDFLG
427F  30D00A              jbc   REG_D0,BIT_00,L428C		; jmp if throttle is partly open
4282  B372C432            ldb   REG_32,$C4[REG_72]		; $144 - CTNTMR
4286  9BF47232            cmpb  REG_32,$72[REG_F4]		; ROM $9048 - NIOLD
428A  D927                jh    L42B3
428C  30EC06        L428C jbc   REG_EC,BIT_00,L4295		; jmp if not MFAFLG
428F  9BF40700            cmpb  Zero,$07[REG_F4]		; ROM $8FDD - MFASW
4293  D71E                jne   L42B3
4295  38290A        L4295 jbs   REG_29,BIT_00,L42A2		; jmp if HLTMR_FLAG
4298  B372CC32            ldb   REG_32,$CC[REG_72]		; High load timer - 1/8 seconds under high load so far
429C  9BFC2232            cmpb  REG_32,$22[REG_FC]		; ROM $9AA0 open_loop_time_at_high_load - time_at_high_load_before_open_loop (time at high load to force Open loop(seconds))
42A0  D911                jh    L42B3					; jmp if timer > open_loop_time
42A2  32EE03        L42A2 jbc   REG_EE,BIT_02,L42A8		; jmp if not OLFLG
42A5  9101EB              orb   REG_EB,#$01				; set SIGPIP
42A8  71FBEE        L42A8 andb  REG_EE,#$FB				; clr OLFLG
42AB  B10134              ldb   REG_34,#$01				; 1 = closed loop control mode
42AE  C7749234            stb   REG_34,$92[REG_74]		; set ClosedLoopFlag $0210 - 
42B2  F0                  ret

42B3  9104EE        L42B3 orb   REG_EE,#$04				; set OLFLG
42B6  C7749200            stb   Zero,$92[REG_74]		; clr ClosedLoopFlag - open loop - from tables - no feedback
42BA  B10134              ldb   REG_34,#$01
42BD  C774EA34            stb   REG_34,$EA[REG_74]		; $268 - ENPIP1 = 1
42C1  C774EB34            stb   REG_34,$EB[REG_74]		; $269 - ENPIP2 = 1
42C5  F0                  ret

42C6  0114          L42C6 clr   REG_14
42C8  0116                clr   REG_16
42CA  39ED21              jbs   REG_ED,BIT_01,L42EE
42CD  71FDEE              andb  REG_EE,#$FD
42D0  37EA03              jbc   REG_EA,BIT_07,L42D6
42D3  9102EE              orb   REG_EE,#$02
42D6  71FEEE        L42D6 andb  REG_EE,#$FE
42D9  332703              jbc   REG_27,BIT_03,L42DF
42DC  9101EE              orb   REG_EE,#$01
42DF  2885          L42DF scall L4366
42E1  38ED23              jbs   REG_ED,BIT_00,L4307
42E4  AFFE1616            ldbze REG_16,$16[REG_FE]		; ROM $9E70 number_of_HEGOs
42E8  31161C              jbc   REG_16,BIT_01,L4307
42EB  AD0114              ldbze REG_14,#$01
42EE  71FDEE        L42EE andb  REG_EE,#$FD
42F1  36EA03              jbc   REG_EA,BIT_06,L42F7
42F4  9102EE              orb   REG_EE,#$02
42F7  71FEEE        L42F7 andb  REG_EE,#$FE
42FA  302703              jbc   REG_27,BIT_00,L4300
42FD  9101EE              orb   REG_EE,#$01
4300  2864          L4300 scall L4366
4302  39ED02              jbs   REG_ED,BIT_01,L4307
4305  2008                sjmp  L430F
4307  A3748C42      L4307 ld    REG_42,$8C[REG_74]		; LAMBSE2(word) - Desired fuel ratio for the left side bank of injectors
430B  C3748E42            st    REG_42,$8E[REG_74]		; LAMBSE1(word) - Desired fuel ratio for the right side bank of injectors
430F  3BEC16        L430F jbs   REG_EC,BIT_03,L4328
4312  33261B              jbc   REG_26,BIT_03,L4330
4315  71F726              andb  REG_26,#$F7
4318  0116                clr   REG_16
431A  A3FC2634            ld    REG_34,$26[REG_FC]
431E  29F3                scall L4513
4320  0716                inc   REG_16
4322  0716                inc   REG_16
4324  29ED                scall L4513
4326  2008                sjmp  L4330
4328  3B2605        L4328 jbs   REG_26,BIT_03,L4330
432B  910826              orb   REG_26,#$08
432E  281B                scall L434B
4330  37D00C        L4330 jbc   REG_D0,BIT_07,L433F		; jmp if throttle is not closed
4333  B372EB38            ldb   REG_38,$EB[REG_72]
4337  9B72EC38            cmpb  REG_38,$EC[REG_72]
433B  DF02                je    L433F
433D  280C                scall L434B
433F  30EB23        L433F jbc   REG_EB,BIT_00,L4365
4342  9BFE0A00            cmpb  Zero,$0A[REG_FE]
4346  DF1D                je    L4365
4348  71FEEB              andb  REG_EB,#$FE
434B  A1008042      L434B ld    REG_42,#$8000
434F  B3748D30            ldb   REG_30,$8D[REG_74]
4353  373004              jbc   REG_30,BIT_07,L435A
4356  C3748C42            st    REG_42,$8C[REG_74]		; LAMBSE2(word) - Desired fuel ratio for the left side bank of injectors
435A  B3748F30      L435A ldb   REG_30,$8F[REG_74]
435E  373004              jbc   REG_30,BIT_07,L4365
4361  C3748E42            st    REG_42,$8E[REG_74]		; LAMBSE1(word) - Desired fuel ratio for the right side bank of injectors
4365  F0            L4365 ret
;
;********
;
4366  459200FC32    L4366 add   REG_32,REG_FC,#$0092	; ROM TABLE $9B10 emission_table_rpm_scaling
436B  A0AE34              ld    REG_34,REG_AE			; REG_AE = engine RPM * 4
436E  EF9BF2              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
4371  A038A6              ld    REG_A6,REG_38

4374  45FA00F032          add   REG_32,REG_F0,#$00FA	; TABLE $8CFA load_scaling
4379  A374DE34            ld    REG_34,$DE[REG_74]	    ; engine load (VE?)
437D  EF8CF2              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
4380  A038A8              ld    REG_A8,REG_38

4383  A0A630              ld    REG_30,REG_A6
4386  A0A832              ld    REG_32,REG_A8
4389  AD0434              ldbze REG_34,#$04
438C  454A03FC38          add   REG_38,REG_FC,#$034A	; ROM $9DC8 HEGO_BIAS
4391  EF53F3              lcall L36E7					; Table interpolation routine
4394  C772143B            stb   REG_3B,$14[REG_72]		; computed HEGO bias?

4398  BC3B1E              ldbse REG_1E,REG_3B
439B  0118                clr   REG_18
439D  371F04              jbc   REG_1F,BIT_07,L43A4
43A0  1718                incb  REG_18
43A2  031E                neg   REG_1E
43A4  A0A832        L43A4 ld    REG_32,REG_A8
43A7  A0A630              ld    REG_30,REG_A6
43AA  AD0434              ldbze REG_34,#$04
43AD  452A03FC            add   REG_38,REG_FC,#$032A	; ROM TABLE $9DA8 - (N,LOAD) = Closed Loop Peak-to-Peak amplitude, units  are  lambdas.
      38
43B2  EF35F3              lcall L36EA					; Interpolate two var table R38-Table
43B5  AC3B1A              ldbze REG_1A,REG_3B
43B8  A0A832              ld    REG_32,REG_A8
43BB  A0A630              ld    REG_30,REG_A6
43BE  AD0434              ldbze REG_34,#$04
43C1  450A03FC            add   REG_38,REG_FC,#$030A	; ROM TABLE $9D88 Table - (N,LOAD) = System transport lag time; time delay from when  a  fuel change  is  made  until  the  EGO sensor indicates this change
      38
43C6  EF21F3              lcall L36EA					; Interpolate two var table R38-Table
43C9  B03B1D              ldb   REG_1D,REG_3B
43CC  B01A3B              ldb   REG_3B,REG_1A
43CF  A01E38              ld    REG_38,REG_1E
43D2  090738              shl   REG_38,#$07
43D5  9C3B38              divub REG_38,REG_3B
43D8  DD05                jv    L43DF
43DA  99E638              cmpb  REG_38,#$E6
43DD  D103                jnh   L43E2
43DF  B1E638        L43DF ldb   REG_38,#$E6
43E2  B0381C        L43E2 ldb   REG_1C,REG_38
43E5  30EE02              jbc   REG_EE,BIT_00,L43EA
43E8  2071                sjmp  L445B

43EA  A01E3C        L43EA ld    REG_3C,REG_1E
43ED  A01A30              ld    REG_30,REG_1A
43F0  090230              shl   REG_30,#$02
43F3  68303C              sub   REG_3C,REG_30
43F6  DB61                jc    L4459
43F8  033C                neg   REG_3C
43FA  456E01F0            add   REG_32,REG_F0,#$016E	; TABLE $8D6E Closed  Loop  ramp  rate  Multiplier  versus  absolute  value  of BIAS/PTPAMP
      32
43FF  B01C34              ldb   REG_34,REG_1C
4402  EFB2F1              lcall L35B7					; Interpolate Single var Table R32-table,R34-in,R38-out
4405  381805              jbs   REG_18,BIT_00,L440D
4408  39EE07              jbs   REG_EE,BIT_01,L4412
440B  2003                sjmp  L4410
440D  31EE02        L440D jbc   REG_EE,BIT_01,L4412
4410  1338          L4410 negb  REG_38
4412  6C383C        L4412 mulu  REG_3C,REG_38
4415  AC1D38              ldbze REG_38,REG_1D
4418  6DC00338            mulu  REG_38,#$03C0
441C  8CAE38              divu  REG_38,REG_AE			; REG_AE = engine RPM * 4
441F  D503                jnv   L4424
4421  BDFF38              ldbse REG_38,#$FF
4424  8C383C        L4424 divu  REG_3C,REG_38
4427  D503                jnv   L442C
4429  BDFF3C              ldbse REG_3C,#$FF
442C  4B177402      L442C sub   REG_34,Master_IO_Timer_Lo,$0274[REG_16]
      0634
4432  6D442834            mulu  REG_34,#$2844
4436  6C363C              mulu  REG_3C,REG_36
4439  A3170A02            ld    REG_34,$020A[REG_16]	; $020A - LAMBSE1(word)[divide by 32768]
      34
443E  39EE09              jbs   REG_EE,BIT_01,L444A
4441  683E34              sub   REG_34,REG_3E
4444  DB0C                jc    L4452
4446  0134                clr   REG_34
4448  2008                sjmp  L4452
444A  643E34        L444A add   REG_34,REG_3E
444D  D303                jnc   L4452
444F  BDFF34              ldbse REG_34,#$FF				; clamp overflow
4452  28AA          L4452 scall L44FE					; clamp REG_34 Lambda to ROM limits (19.0:1 to 10.98:1)
4454  C3170A02            st    REG_34,$020A[REG_16]	; $020A - LAMBSE1(word)[divide by 32768]
      34
4459  209D          L4459 sjmp  L44F8

445B  A01A3C        L445B ld    REG_3C,REG_1A
445E  09023C              shl   REG_3C,#$02
4461  457801F0            add   REG_32,REG_F0,#$0178	; TABLE $8D78 Closed Loop Jumpback distance  Multiplier  versus  |BIAS/PTPAMP|
      32
4466  B01C34              ldb   REG_34,REG_1C
4469  301805              jbc   REG_18,BIT_00,L4471
446C  39EE0F              jbs   REG_EE,BIT_01,L447E
446F  2003                sjmp  L4474
4471  31EE0A        L4471 jbc   REG_EE,BIT_01,L447E
4474  641E3C        L4474 add   REG_3C,REG_1E
4477  458601F0            add   REG_32,REG_F0,#$0186	; TABLE $8D86 Closed Loop Jumpback Distance  Multiplier  versus  |BIAS/PTPAMP|
      32
447C  1719                incb  REG_19
447E  EF36F1        L447E lcall L35B7					; Interpolate Single var Table R32-table,R34-in,R38-out
4481  6C3C38              mulu  REG_38,REG_3C
4484  0C0438              shrl  REG_38,#$04
4487  B3156802            ldb   REG_3C,$0268[REG_14]
      3C
448C  9B159C00            cmpb  REG_3C,$009C[REG_14]
      3C
4491  DB05                jc    L4498
4493  C7159C00            stb   REG_3C,$009C[REG_14]
      3C
4498  AF159C00      L4498 ldbze REG_3C,$009C[REG_14]
      3C
449D  6C383C              mulu  REG_3C,REG_38
44A0  AF156802            ldbze REG_38,$0268[REG_14]
      38
44A5  8C383C              divu  REG_3C,REG_38
44A8  A3170A02            ld    REG_34,$020A[REG_16]	; $020A - LAMBSE1(word)[divide by 32768]
      34
44AD  39EE09              jbs   REG_EE,BIT_01,L44B9
44B0  683C34              sub   REG_34,REG_3C
44B3  DB0C                jc    L44C1
44B5  0134                clr   REG_34
44B7  2008                sjmp  L44C1

44B9  643C34        L44B9 add   REG_34,REG_3C
44BC  D303                jnc   L44C1
44BE  BDFF34              ldbse REG_34,#$FF				; clamp overflow
44C1  283B          L44C1 scall L44FE					; clamp REG_34 Lambda to ROM limits (19.0:1 to 10.98:1)
44C3  C3170A02            st    REG_34,$020A[REG_16]	; $020A - LAMBSE1(word)[divide by 32768]
      34
44C8  C7159C00            stb   Zero,$009C[REG_14]
      00
44CD  AC1D3C              ldbze REG_3C,REG_1D
44D0  09013C              shl   REG_3C,#$01
44D3  B11038              ldb   REG_38,#$10
44D6  38190B              jbs   REG_19,BIT_00,L44E4
44D9  459001F0            add   REG_32,REG_F0,#$0190	; TABLE $8D90 Expected number of PIPs multiplier
      32
44DE  B01C34              ldb   REG_34,REG_1C
44E1  EFD3F0              lcall L35B7					; Interpolate Single var Table R32-table,R34-in,R38-out
44E4  7FFE0738      L44E4 mulub REG_38,$07[REG_FE]		; ROM $9E5A+7 = 9E61 value = $08=ENGCYL=Number of cylinders per engine revolution
44E8  6C383C              mulu  REG_3C,REG_38
44EB  88003E              cmp   REG_3E,Zero
44EE  DF03                je    L44F3
44F0  B1FF3D              ldb   REG_3D,#$FF
44F3  C71568023D    L44F3 stb   REG_3D,$0268[REG_14]
44F8  C317740206    L44F8 st    Master_IO_Timer_Lo,$0274[REG_16]
44FD  F0                  ret
;
;******
; clamp REG_34 Lambda to ROM limits
44FE  8BFC2434      L44FE cmp   REG_34,$24[REG_FC]		; ROM $9AA2 - LAMMAX = $A666 = 1.3000 (A/F ratio 19.0:1)
4502  D104                jnh   L4508					; jmp if REG_34 <= 1.3
4504  A3FC2434            ld    REG_34,$24[REG_FC]		; ROM $9AA2 - LAMMAX = $A666 = 1.3000
4508  8BFC2634      L4508 cmp   REG_34,$26[REG_FC]		; ROM $9AA4 - LAMMIN = $6000 = 0.7500 (A/F ratio 10.98:1)
450C  DB04                jc    L4512
450E  A3FC2634            ld    REG_34,$26[REG_FC]		; ROM $9AA4 - LAMMIN = $6000 = 0.7500
4512  F0            L4512 ret
;
;******
;
4513  A3170A0236    L4513 ld    REG_36,$020A[REG_16]	; $020A - LAMBSE1(word)[divide by 32768]
4518  6BFC7436            sub   REG_36,$74[REG_FC]		; ROM
451C  D305                jnc   L4523
451E  883436              cmp   REG_36,REG_34
4521  DB03                jc    L4526
4523  C03634        L4523 st    REG_34,REG_36
4526  C3170A0236    L4526 st    REG_36,$020A[REG_16]	; $020A - LAMBSE1(word)[divide by 32768]
452B  F0                  ret
;
;******
;
452C  45D200F0      L452C add   REG_32,REG_F0,#$00D2	; TABLE $8CD2 Temperature normalizing function; used for table lookup
      32
4531  B3FC3536            ldb   REG_36,$35[REG_FC]		; ROM
4535  29B1                scall L46E8
4537  0A0734              shra  REG_34,#$07
453A  EF6FF0              lcall L35AC					; Interpolate Single var Table R32-table,R34-in,R38-out
453D  B03830              ldb   REG_30,REG_38
4540  451601F0            add   REG_32,REG_F0,#$0116	; TABLE $9016
      32
4545  A374E234            ld    REG_34,$E2[REG_74]		; $0260 Volumetric Efficiency
4549  EFC0F0              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
454C  B03832              ldb   REG_32,REG_38
454F  AD0A34              ldbze REG_34,#$0A
4552  457201FC            add   REG_38,REG_FC,#$0172	; ROM TABLE $9BF0 - Base Fuel (A/F ratio) (ECT vs load)
      38
4557  EF81F1              lcall L36DB					; Interpolate two var table R38-Table
455A  45CA00FC            add   REG_32,REG_FC,#$00CA	; ROM TABLE $9B48 - Open Loop Fuel Multiplier vs ACT
      32
455F  B0B134              ldb   REG_34,REG_B1			; REG_B1 = ACT (ACT = REG_B1 * 4)
4562  EF47F0              lcall L35AC					; Interpolate Single var Table R32-table,R34-in,R38-out
4565  5C3B383C            mulub REG_3C,REG_38,REG_3B
4569  45D200F032          add   REG_32,REG_F0,#$00D2	; TABLE $8CD2 Temperature normalizing function
456E  B3FC3636            ldb   REG_36,$36[REG_FC]		; ROM $9AB4 ACT fraction for $9c40 lookup.
4572  2974                scall L46E8
4574  0A0734              shra  REG_34,#$07
4577  EF32F0              lcall L35AC					; Interpolate Single var Table R32-table,R34-in,R38-out
457A  B03830              ldb   REG_30,REG_38
457D  459000F0            add   REG_32,REG_F0,#$0090	; TABLE $8C90 Time (ATMR1) normalizing function (Y-input)
      32
4582  B0C834              ldb   REG_34,REG_C8			; (REG_C8 may be a byte size counter for ATMR1)
4585  EF2FF0              lcall L35B7					; Interpolate Single var Table R32-table,R34-in,R38-out
4588  B03832              ldb   REG_32,REG_38
458B  AD0A34              ldbze REG_34,#$0A
458E  45C201FC            add   REG_38,REG_FC,#$01C2	; ROM TABLE $9C40 - Startup Fuel (A/F ratio)(ECT vs Time)
      38
4593  EF45F1              lcall L36DB					; Interpolate two var table R38-Table
4596  6980003A            sub   REG_3A,#$0080
459A  08023A              shr   REG_3A,#$02
459D  683A3C              sub   REG_3C,REG_3A
45A0  DB02                jc    L45A4
45A2  013C                clr   REG_3C
45A4  AD8038        L45A4 ldbze REG_38,#$80
45A7  31E93F              jbc   REG_E9,BIT_01,L45E9
45AA  B3748342            ldb   REG_42,$83[REG_74]
45AE  458200FA            add   REG_32,REG_FA,#$0082	; TABLE $982A Sea Level Lugging O/L Fuel Multiplier vs RPM
      32
45B3  A0AE34              ld    REG_34,REG_AE			; REG_AE = engine RPM * 4
45B6  EF53F0              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
45B9  7C3842              mulub REG_42,REG_38
45BC  45C800F8            add   REG_32,REG_F8,#$00C8	; TABLE $94F8
      32
45C1  B3748034            ldb   REG_34,$80[REG_74]		; BP - barometric pressure
45C5  EFEFEF              lcall L35B7					; Interpolate Single var Table R32-table,R34-in,R38-out
45C8  B03830              ldb   REG_30,REG_38
45CB  459E00FA            add   REG_32,REG_FA,#$009E	; TABLE $9846 Altitude Lugging O/L Fuel Multiplier vs RPM
      32
45D0  A0AE34              ld    REG_34,REG_AE			; REG_AE = engine RPM * 4
45D3  EF36F0              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
45D6  7C3038              mulub REG_38,REG_30
45D9  644238              add   REG_38,REG_42
45DC  DB06                jc    L45E4
45DE  080738              shr   REG_38,#$07
45E1  303903              jbc   REG_39,BIT_00,L45E7
45E4  ADFF38        L45E4 ldbze REG_38,#$FF
45E7  20A7          L45E7 sjmp  L4690
45E9  36260D        L45E9 jbc   REG_26,BIT_06,L45F9
45EC  37D00A              jbc   REG_D0,BIT_07,L45F9		; jmp if throttle is not closed
45EF  3AEF07              jbs   REG_EF,BIT_02,L45F9
45F2  45D600FC            add   REG_32,REG_FC,#$00D6	; ROM TABLE $9B54 fuel_closed_throttle_open_loop_multiply
      32
45F7  2091                sjmp  L468A
45F9  32262C        L45F9 jbc   REG_26,BIT_02,L4628
45FC  9BFE05AD            cmpb  REG_AD,$05[REG_FE]		; ROM $9E5F CTLOW
4600  DA26                jle   L4628
4602  9BF40AAD            cmpb  REG_AD,$0A[REG_F4]
4606  D620                jge   L4628
4608  9BF40CC8            cmpb  REG_C8,$0C[REG_F4]		; (REG_C8 may be a byte size counter for ATMR1)
460C  DB1A                jc    L4628
460E  45EE00FC            add   REG_32,REG_FC,#$00EE	; ROM TABLE $9B6C
      32
4613  A0AE34              ld    REG_34,REG_AE			; REG_AE = engine RPM * 4
4616  EFF3EF              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
4619  7FF40B38            mulub REG_38,$0B[REG_F4]
461D  080738              shr   REG_38,#$07
4620  303903              jbc   REG_39,BIT_00,L4626
4623  ADFF38              ldbze REG_38,#$FF
4626  2068          L4626 sjmp  L4690

4628  30EC4D        L4628 jbc   REG_EC,BIT_00,L4678
462B  9BF40700            cmpb  Zero,$07[REG_F4]
462F  DF47                je    L4678
4631  45DE00F0            add   REG_32,REG_F0,#$00DE		; TABLE $8CDE spark_table_RPM_scaling
      32
4636  A0AE34              ld    REG_34,REG_AE				; REG_AE = engine RPM * 4
4639  EFD0EF              lcall L360C						; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
463C  A03830              ld    REG_30,REG_38	
463F  451601F0            add   REG_32,REG_F0,#$0116		; TABLE $9016
      32
4644  A374E234            ld    REG_34,$E2[REG_74]			; $0260 Volumetric Efficiency
4648  EFC1EF              lcall L360C						; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
464B  090438              shl   REG_38,#$04
464E  A03832              ld    REG_32,REG_38
4651  AD0A34              ldbze REG_34,#$0A
4654  459300F4            add   REG_38,REG_F4,#$0093		; TABLE $9069 Manage Fuel Air Fuel Table, 10 x 8 table of multipliers as a function of engine speed N and LOAD
      38
4659  EF8EF0              lcall L36EA						; Interpolate two var table R38-Table
465C  B3748238            ldb   REG_38,$82[REG_74]
4660  7C3B38              mulub REG_38,REG_3B
4663  5F74F439            mulub REG_38,REG_39,$F4[REG_74]
      38
4668  090238              shl   REG_38,#$02
466B  55803938            addb  REG_38,REG_39,#$80
466F  D303                jnc   L4674
4671  B1FF38              ldb   REG_38,#$FF
4674  1139          L4674 clrb  REG_39
4676  2018                sjmp  L4690

4678  322607        L4678 jbc   REG_26,BIT_02,L4682			; selects which "WOT Fuel Multiplier vs RPM" table to use
467B  45EE00FC32          add   REG_32,REG_FC,#$00EE		; ROM TABLE $9B6C WOT Fuel Multiplier vs RPM 1
4680  2008                sjmp  L468A

4682  30240B        L4682 jbc   REG_24,BIT_00,L4690			; check WOT flag
4685  450201FC            add   REG_32,REG_FC,#$0102		; ROM TABLE $9B80 WOT Fuel Multiplier vs RPM 2
      32
468A  A0AE34        L468A ld    REG_34,REG_AE				; REG_AE = engine RPM * 4
468D  EF7CEF              lcall L360C						; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
4690  6C383C        L4690 mulu  REG_3C,REG_38
4693  0C053C              shrl  REG_3C,#$05
4696  88003E              cmp   REG_3E,Zero
4699  DF03                je    L469E
469B  BDFF3C              ldbse REG_3C,#$FF
469E  6F72E83C      L469E mulu  REG_3C,$E8[REG_72]			; LAMBSE modifier???
46A2  983F00              cmpb  Zero,REG_3F
46A5  DF05                je    L46AC
46A7  BDFF3C              ldbse REG_3C,#$FF
46AA  2003                sjmp  L46AF
46AC  0C083C        L46AC shrl  REG_3C,#$08
46AF  6FFA123C      L46AF mulu  REG_3C,$12[REG_FA]			; ROM $97BA fuel_open_loop_multiplier (LAMBSE)
46B3  983F00              cmpb  Zero,REG_3F
46B6  DF05                je    L46BD
46B8  BDFF3E              ldbse REG_3E,#$FF
46BB  2003                sjmp  L46C0
46BD  0D083C        L46BD shll  REG_3C,#$08
46C0  32E715        L46C0 jbc   REG_E7,BIT_02,L46D8			; high speed flag???
46C3  457300FA            add   REG_32,REG_FA,#$0073		; TABLE $981B (vehicle speed - LAMBSE)
      32
46C8  B3743F34            ldb   REG_34,$3F[REG_74]			; $2BD - vehicle speed filtered(1) (MPH) $02BC is 8.8 format VSS
46CC  EFE8EE              lcall L35B7						; Interpolate Single var Table R32-table,R34-in,R38-out
46CF  A03E3C              ld    REG_3C,REG_3E
46D2  090838              shl   REG_38,#$08
46D5  6C383C              mulu  REG_3C,REG_38
46D8  88003E        L46D8 cmp   REG_3E,Zero
46DB  D702                jne   L46DF
46DD  073E                inc   REG_3E
46DF  C3748C3E      L46DF st    REG_3E,$8C[REG_74]		; LAMBSE2(word) - Desired fuel ratio for the left side bank of injectors
46E3  C3748E3E            st    REG_3E,$8E[REG_74]		; LAMBSE1(word) - Desired fuel ratio for the right side bank of injectors
46E7  F0                  ret
;
;*****************************************************************
; temp something?
; Blended temperature
;*****************************************************************
; FRCBFT * ACT + (1 - FRCBFT) * ECT
Input REG_36 = FRCBFT = blend factor

46E8  FE5CB13634    L46E8 mul   REG_34,REG_36,REG_B1	; REG_B1 = ACT (ACT = REG_B1 * 4)
46ED  1336                negb  REG_36					; -FRCBFT
46EF  757F36              addb  REG_36,#$7F
46F2  FE7CB036            mul   REG_36,REG_B0			; Engine Coolant Temperature - degrees F ?
46F6  BCB038              ldbse REG_38,REG_B0			; Engine Coolant Temperature - degrees F ?
46F9  643836              add   REG_36,REG_38
46FC  643634              add   REG_34,REG_36
46FF  F0                  ret
;
;*****************************************************************
; Cycling Routine at 2151, routine offset $2A
; Adaptive something
;*****************************************************************
;
4700  3FA114              jbs   REG_A1,BIT_07,L4717		; jump if CRANKING
4703  3AA111              jbs   REG_A1,BIT_02,L4717		; UNDSP = Run/Underspeed Flag.  (1 = Underspeed (or CRANK), 0 = Run)
4706  9BFC64B0            cmpb  REG_B0,$64[REG_FC]		; Engine Coolant Temperature - degrees F ? ROM $9AE2=55
470A  DE0B                jlt   L4717					; jump if ECT < 170 degrees Farenheit
470C  9BFC65B0            cmpb  REG_B0,$65[REG_FC]		; Engine Coolant Temperature - degrees F ? ROM $9AE3=71
4710  D205                jgt   L4717					; jump if ECT > 226 degrees Farenheit
4712  9101A1              orb   REG_A1,#$01				; set ADPTMR_FLG = Adaptive Fuel Time Flag
4715  2007                sjmp  L471E

; not at operating temp(too hot or cold)
4717  C372BA00      L4717 st    Zero,$BA[REG_72]		; zero $013A timer?
471B  71FEA1              andb  REG_A1,#$FE				; clr ADPTMR_FLG = Adaptive Fuel Time Flag

471E  51F8C538      L471E andb  REG_38,REG_C5,#$F8
4722  DF02                je    L4726
4724  20E9                sjmp  L480F

4726  3AEE0A        L4726 jbs   REG_EE,BIT_02,L4733
4729  A372BA38            ld    REG_38,$BA[REG_72]		; $013A timer ADPTMR (adaptive ???)
472D  8BFC6838            cmp   REG_38,$68[REG_FC]		; ROM $9AE6 - ADAPTM
4731  DB02                jc    L4735
4733  20DA          L4733 sjmp  L480F
4735  33EC25        L4735 jbc   REG_EC,BIT_03,L475D
4738  B372D730            ldb   REG_30,$D7[REG_72]
473C  990130              cmpb  REG_30,#$01
473F  D7F2                jne   L4733
4741  B372EB30            ldb   REG_30,$EB[REG_72]
4745  C7741230            stb   REG_30,$12[REG_74]		; $0290 COLTBU - A register which contains the column number of the Adaptive Learning Cell to be updated
4749  11A6                clrb  REG_A6
474B  C4A730              stb   REG_30,REG_A7
474E  A1080030            ld    REG_30,#$0008
4752  C7741330            stb   REG_30,$13[REG_74]
4756  C4A930              stb   REG_30,REG_A9
4759  11A8                clrb  REG_A8
475B  204F                sjmp  L47AC

475D  A372D238      L475D ld    REG_38,$D2[REG_72]
4761  6D030138            mulu  REG_38,#$0103
4765  C372D238            st    REG_38,$D2[REG_72]
4769  45B200F0            add   REG_32,REG_F0,#$00B2	; TABLE $8CB2 - ECC Load Scaling - emission_table_load_scaling
      32
476E  A374DE34            ld    REG_34,$DE[REG_74]	    ; engine load (VE?)
4772  EF97EE              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
4775  A038A8              ld    REG_A8,REG_38
4778  65800038            add   REG_38,#$0080
477C  BF72D23A            ldbse REG_3A,$D2[REG_72]
4780  643A38              add   REG_38,REG_3A
4783  C7741339            stb   REG_39,$13[REG_74]
4787  C43039              stb   REG_39,REG_30
478A  45DE00F0            add   REG_32,REG_F0,#$00DE	; TABLE $8CDE spark_table_RPM_scaling
      32
478F  A0AE34              ld    REG_34,REG_AE			; REG_AE = engine RPM * 4
4792  EF77EE              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
4795  A038A6              ld    REG_A6,REG_38
4798  65800038            add   REG_38,#$0080
479C  BF72D33A            ldbse REG_3A,$D3[REG_72]		; 
47A0  643A38              add   REG_38,REG_3A
47A3  C7741239            stb   REG_39,$12[REG_74]		; $0290 COLTBU - A register which contains the column number of the Adaptive Learning Cell to be updated
47A7  990830              cmpb  REG_30,#$08
47AA  DB63                jc    L480F
47AC  7D0A30        L47AC mulub REG_30,#$0A
47AF  77741230            addb  REG_30,$12[REG_74]		; $0290 COLTBU - A register which contains the column number of the Adaptive Learning Cell to be updated
47B3  458203FC            add   REG_38,REG_FC,#$0382	; ROM $9E00
      38
47B8  643038              add   REG_38,REG_30
47BB  B23838              ldb   REG_38,[REG_38]
47BE  983800              cmpb  Zero,REG_38
47C1  D21E                jgt   L47E1
47C3  4B740EA8            sub   REG_38,REG_A8,$0E[REG_74]
      38
47C8  DB02                jc    L47CC
47CA  0338                neg   REG_38
47CC  8BFC6C38      L47CC cmp   REG_38,$6C[REG_FC]
47D0  D90F                jh    L47E1
47D2  4B7410A6            sub   REG_38,REG_A6,$10[REG_74]
      38
47D7  DB02                jc    L47DB
47D9  0338                neg   REG_38
47DB  8BFC6E38      L47DB cmp   REG_38,$6E[REG_FC]		; ROM
47DF  D10A                jnh   L47EB
47E1  C3740EA8      L47E1 st    REG_A8,$0E[REG_74]
47E5  C37410A6            st    REG_A6,$10[REG_74]
47E9  2024                sjmp  L480F

47EB  A3720C38      L47EB ld    REG_38,$0C[REG_72]
47EF  8BFC7238            cmp   REG_38,$72[REG_FC]		; ROM
47F3  D91A                jh    L480F
47F5  A09E38              ld    REG_38,REG_9E
47F8  373902              jbc   REG_39,BIT_07,L47FD
47FB  0338                neg   REG_38
47FD  8BFC7638      L47FD cmp   REG_38,$76[REG_FC]		; ROM
4801  DB0C                jc    L480F
4803  9BFC66B1            cmpb  REG_B1,$66[REG_FC]		; REG_B1 = ACT (ACT = REG_B1 * 4) : ROM $9AE4 min_act_for_adaptive_control
4807  DA06                jle   L480F
4809  9BFC67B1            cmpb  REG_B1,$67[REG_FC]		; REG_B1 = ACT (ACT = REG_B1 * 4) : ROM $9AE5 max_act_for_adaptive_control
480D  DE11                jlt   L4820
480F  C301B80700    L480F st    Zero,$07B8[Zero]
4814  C301BA0700          st    Zero,$07BA[Zero]
4819  C301B20700          st    Zero,$07B2[Zero]
481E  2076                sjmp  L4896

4820  33270C        L4820 jbc   REG_27,BIT_03,L482F
4823  B301B20736          ldb   REG_36,$07B2[Zero]		; KAM ?
4828  1736                incb  REG_36
482A  C701B20736          stb   REG_36,$07B2[Zero]		; KAM ?

482F  30270C        L482F jbc   REG_27,BIT_00,L483E
4832  B301B30736          ldb   REG_36,$07B3[Zero]		; KAM ?
4837  1736                incb  REG_36
4839  C701B30736          stb   REG_36,$07B3[Zero]		; KAM ?

483E  BF721438      L483E ldbse REG_38,$14[REG_72]		; computed HEGO bias
4842  FE6D100038          mul   REG_38,#$0010
4847  65008038            add   REG_38,#$8000
484B  A3FC6A3A            ld    REG_3A,$6A[REG_FC]		; ROM
484F  B301E00714          ldb   REG_14,$07E0[Zero]
4854  9BFC7A14            cmpb  REG_14,$7A[REG_FC]		; ROM
4858  DB06                jc    L4860
485A  B3FC7914            ldb   REG_14,$79[REG_FC]		; ROM
485E  2004                sjmp  L4864

4860  B3FC7814      L4860 ldb   REG_14,$78[REG_FC]		; ROM
4864  9B01B20714    L4864 cmpb  REG_14,$07B2[Zero]		; KAM ?
4869  DB0F                jc    L487A

486B  0132                clr   REG_32
486D  013E                clr   REG_3E					; KAM index = 0
486F  A1040740            ld    REG_40,#$0704
4873  5180EA36            andb  REG_36,REG_EA,#$80
4877  EF1D00              lcall L4897					; KAM table[REG_3E] write something???

487A  9B01B30714    L487A cmpb  REG_14,$07B3[Zero]		; KAM ?
487F  DB15                jc    L4896
4881  AD0232              ldbze REG_32,#$02
4884  AD013E              ldbze REG_3E,#$01				; KAM index = 1
4887  A15A0740            ld    REG_40,#$075A
488B  5140EA36            andb  REG_36,REG_EA,#$40
488F  A3FC6A3A            ld    REG_3A,$6A[REG_FC]
4893  EF0100              lcall L4897					; KAM table[REG_3E] write something???

4896  F0            L4896 ret
;
;****************************************************************
; REG_3E = ???error?
;
4897  643040        L4897 add   REG_40,REG_30
489A  980036              cmpb  REG_36,Zero
489D  DF49                je    L48E8
489F  64383A              add   REG_3A,REG_38
48A2  A3330A02            ld    REG_42,$020A[REG_32]	; $020A - LAMBSE1(word)[divide by 32768]
      42
48A7  883A42              cmp   REG_42,REG_3A
48AA  D33B                jnc   L48E7

48AC  B33FBA073C          ldb   REG_3C,$07BA[REG_3E]	; KAM - read value from KAM table
48B1  173C                incb  REG_3C					; incr value
48B3  C73FBA073C          stb   REG_3C,$07BA[REG_3E]	; KAM - write value back to KAM table

48B8  458203FC34          add   REG_34,REG_FC,#$0382	; ROM $9E00 - read index ROM table value
48BD  643034              add   REG_34,REG_30
48C0  B2343D              ldb   REG_3D,[REG_34]

48C3  19013D              shlb  REG_3D,#$01
48C6  983D3C              cmpb  REG_3C,REG_3D
48C9  D11C                jnh   L48E7
48CB  B24036              ldb   REG_36,[REG_40]
48CE  9BFC7036            cmpb  REG_36,$70[REG_FC]		; ROM adaptive_control_minimum
48D2  D113                jnh   L48E7
48D4  1536                decb  REG_36
48D6  C64036              stb   REG_36,[REG_40]
48D9  C73FBA0700          stb   Zero,$07BA[REG_3E]		; KAM table store
48DE  A3010207            ld    REG_36,$0702[Zero]		; KAM checksum
      36
48E3  0536                dec   REG_36
48E5  2049                sjmp  L4930					; update KAM cksum and return

48E7  F0            L48E7 ret

48E8  033A          L48E8 neg   REG_3A
48EA  64383A              add   REG_3A,REG_38
48ED  A3330A0242          ld    REG_42,$020A[REG_32]	; $020A - LAMBSE1(word)[divide by 32768]
48F2  883A42              cmp   REG_42,REG_3A
48F5  D943                jh    L493A					; return

48F7  B33FB8073C          ldb   REG_3C,$07B8[REG_3E]	; KAM - read indexed KAM value
48FC  173C                incb  REG_3C					; incr value
48FE  C73FB8073C          stb   REG_3C,$07B8[REG_3E]	; KAM - store back into KAM loc

4903  458203FC34          add   REG_34,REG_FC,#$0382	; ROM $9E00
4908  643034              add   REG_34,REG_30
490B  B2343D              ldb   REG_3D,[REG_34]			; pull value from ROM table
490E  19013D              shlb  REG_3D,#$01				; byte << 1 (times 2)
4911  983D3C              cmpb  REG_3C,REG_3D
4914  D124                jnh   L493A
4916  B24036              ldb   REG_36,[REG_40]
4919  9BFC7136            cmpb  REG_36,$71[REG_FC]		; ROM adaptive_control_maximum
491D  DB1B                jc    L493A
491F  1736                incb  REG_36
4921  C64036              stb   REG_36,[REG_40]
4924  C73FB80700          stb   Zero,$07B8[REG_3E]		; KAM - store value into same loc as above

4929  A301020736          ld    REG_36,$0702[Zero]		; KAM checksum
492E  0736                inc   REG_36					; incr cksum to match incr to value
4930  C301020736    L4930 st    REG_36,$0702[Zero]		; KAM checksum
4935  C73FB20700          stb   Zero,$07B2[REG_3E]		; KAM ?

493A  F0            L493A ret

493B  AD803A        L493B ldbze REG_3A,#$80
493E  AD8040              ldbze REG_40,#$80
4941  3FA125              jbs   REG_A1,BIT_07,L4969		; jump if CRANKING
4944  31ED03              jbc   REG_ED,BIT_01,L494A
4947  38ED1F              jbs   REG_ED,BIT_00,L4969
494A  33EC1E        L494A jbc   REG_EC,BIT_03,L496B
494D  372606              jbc   REG_26,BIT_07,L4956
4950  9BFC7C00            cmpb  Zero,$7C[REG_FC]
4954  D715                jne   L496B
4956  AF72EB30      L4956 ldbze REG_30,$EB[REG_72]
495A  755030              addb  REG_30,#$50
495D  2928                scall L4A87
495F  AF330407            ldbze REG_3A,$0704[REG_32]	; KAM table 1 Lo byte of ?
      3A
4964  AF335A07            ldbze REG_40,$075A[REG_32]	; KAM table 2 Hi byte of ?
      40
4969  2090          L4969 sjmp  L49FB

496B  45DE00F0      L496B add   REG_32,REG_F0,#$00DE	; TABLE $8CDE spark_table_RPM_scaling
      32
4970  A0AE34              ld    REG_34,REG_AE			; REG_AE = engine RPM * 4
4973  EF96EC              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
4976  A038A6              ld    REG_A6,REG_38
4979  45B200F0            add   REG_32,REG_F0,#$00B2	; TABLE $8CB2 - ECC Load Scaling - emission_table_load_scaling
      32
497E  A374DE34            ld    REG_34,$DE[REG_74]	    ; engine load (VE?)
4982  EF87EC              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
4985  A038A8              ld    REG_A8,REG_38
4988  B0A930              ldb   REG_30,REG_A9
498B  7D0A30              mulub REG_30,#$0A
498E  74A730              addb  REG_30,REG_A7
4991  28F4                scall L4A87
4993  B3330407            ldb   REG_3C,$0704[REG_32]	; KAM table 1 Lo byte of ?
      3C
4998  B3335A07            ldb   REG_40,$075A[REG_32]	; KAM table 2 Hi byte of ?
      40
499D  0730                inc   REG_30
499F  28E6                scall L4A87
49A1  B3330407            ldb   REG_3D,$0704[REG_32]	; KAM table 1 Lo byte of ?
      3D
49A6  B3335A07            ldb   REG_41,$075A[REG_32]	; KAM table 2 Hi byte of ?
      41
49AB  9907A9              cmpb  REG_A9,#$07
49AE  D308                jnc   L49B8
49B0  A03C3E              ld    REG_3E,REG_3C
49B3  A04042              ld    REG_42,REG_40
49B6  201D                sjmp  L49D5

49B8  750930        L49B8 addb  REG_30,#$09
49BB  28CA                scall L4A87
49BD  B3330407            ldb   REG_3E,$0704[REG_32]	; KAM table 1 Lo byte of ?
      3E
49C2  B3335A07            ldb   REG_42,$075A[REG_32]	; KAM table 2 Hi byte of ?
      42
49C7  0730                inc   REG_30
49C9  28BC                scall L4A87
49CB  B3330407            ldb   REG_3F,$0704[REG_32]	; KAM table 1 Lo byte of ?
      3F
49D0  B3335A07            ldb   REG_43,$075A[REG_32]	; KAM table 2 Hi byte of ?
      43
49D5  ACA630        L49D5 ldbze REG_30,REG_A6
49D8  ACA832              ldbze REG_32,REG_A8
49DB  AD0234              ldbze REG_34,#$02
49DE  A1400038            ld    REG_38,#$0040
49E2  EF05ED              lcall L36EA					; Interpolate two var table R38-Table
49E5  AC3B40              ldbze REG_40,REG_3B
49E8  ACA630              ldbze REG_30,REG_A6
49EB  ACA832              ldbze REG_32,REG_A8
49EE  AD0234              ldbze REG_34,#$02
49F1  A13C0038            ld    REG_38,#$003C
49F5  EFF2EC              lcall L36EA					; Interpolate two var table R38-Table
49F8  AC3B3A              ldbze REG_3A,REG_3B
49FB  6580003A      L49FB add   REG_3A,#$0080
49FF  65800040            add   REG_40,#$0080
4A03  C301B4073A          st    REG_3A,$07B4[Zero]		; KAM ?
4A08  C301B60740          st    REG_40,$07B6[Zero]		; KAM ?

4A0D  38ED09              jbs   REG_ED,BIT_00,L4A19
4A10  B3FE1630            ldb   REG_30,$16[REG_FE]		; ROM $9E70 number_of_HEGOs
4A14  990130              cmpb  REG_30,#$01
4A17  D70C                jne   L4A25					; jmp if the number of HEGOs != 1
; One HEGO case
4A19  A301B40730    L4A19 ld    REG_30,$07B4[Zero]		; KAM ?
4A1E  C301B60730          st    REG_30,$07B6[Zero]		; KAM ?
4A23  200D                sjmp  L4A32
; Two HEGO case (zero hegos?)
4A25  31ED0A        L4A25 jbc   REG_ED,BIT_01,L4A32
4A28  A301B60730          ld    REG_30,$07B6[Zero]		; KAM ?
4A2D  C301B40730          st    REG_30,$07B4[Zero]		; KAM ?

4A32  451800F032    L4A32 add   REG_32,REG_F0,#$0018		; TABLE $8C18
4A37  B0B034              ldb   REG_34,REG_B0			; Engine Coolant Temperature - degrees F ?
4A3A  EF6FEB              lcall L35AC					; Interpolate Single var Table R32-table,R34-in,R38-out
4A3D  9B72C738            cmpb  REG_38,$C7[REG_72]		; $0147 - timer?
4A41  D91A                jh    L4A5D
4A43  A372E830            ld    REG_30,$E8[REG_72]
4A47  89000130            cmp   REG_30,#$0100
4A4B  DF10                je    L4A5D
4A4D  D904                jh    L4A53
4A4F  0730                inc   REG_30
4A51  2002                sjmp  L4A55

4A53  0530          L4A53 dec   REG_30
4A55  C372E830      L4A55 st    REG_30,$E8[REG_72]
4A59  C772C700            stb   Zero,$C7[REG_72]		; zero $0147 - timer?
4A5D  B3FE0232      L4A5D ldb   REG_32,$02[REG_FE]		; ROM $9E5C
4A61  990432              cmpb  REG_32,#$04
4A64  D320                jnc   L4A86
4A66  32EE1D              jbc   REG_EE,BIT_02,L4A86
4A69  3E2605              jbs   REG_26,BIT_06,L4A71
4A6C  9102EC              orb   REG_EC,#$02
4A6F  2015                sjmp  L4A86

4A71  31EC12        L4A71 jbc   REG_EC,BIT_01,L4A86
4A74  71FDEC              andb  REG_EC,#$FD
4A77  454A02FC            add   REG_32,REG_FC,#$024A	; ROM TABLE $9CC8
      32
4A7C  BCB034              ldbse REG_34,REG_B0			; Engine Coolant Temperature - degrees F ?
4A7F  EF7FEB              lcall L3601					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
4A82  C372E838            st    REG_38,$E8[REG_72]		; $0268
4A86  F0            L4A86 ret
;
;****************************************************************
; Look up something in a calibration table
4A87  A03032        L4A87 ld    REG_32,REG_30
4A8A  458203FC34          add   REG_34,REG_FC,#$0382	; ROM $9E00 Table FN1325 controls the update rate and update area  for  both  LTMTB1 and LTMTB2
4A8F  643034              add   REG_34,REG_30
4A92  BE3434              ldbse REG_34,[REG_34]
4A95  373505              jbc   REG_35,BIT_07,L4A9D
4A98  0334                neg   REG_34
4A9A  A03432              ld    REG_32,REG_34
4A9D  F0            L4A9D ret

;  Calculate the value of the pulsewidth conversion factor (PWCF) = REG_30
;
;                  1         2 * PIPOUT
;
; REG_30 = PWCF =  ---------- * ---------------
;
;              N * ENGCYL   NUMOUT * INJOUT

4A9E  A3FC2E30      L4A9E ld    REG_30,$2E[REG_FC]		; ROM $9AAC PIPOUT 
4AA2  090130              shl   REG_30,#$01				; times 2
4AA5  990231              cmpb  REG_31,#$02
4AA8  D104                jnh   L4AAE
4AAA  A1000230            ld    REG_30,#$0200
4AAE  090630        L4AAE shl   REG_30,#$06
4AB1  B3FC3134            ldb   REG_34,$31[REG_FC]		; ROM $9AAF INJOUT = Number of injectors fired by each output port
4AB5  7FFC3234            mulub REG_34,$32[REG_FC]		; ROM $9AB0 - 8 - number of cylinders
4AB9  7FFE0734            mulub REG_34,$07[REG_FE]		; ROM $9E5A+7 = 9E61 value = $08=ENGCYL=Number of cylinders per engine revolution
4ABD  6CAE34              mulu  REG_34,REG_AE			; REG_AE = engine RPM * 4
4AC0  0C0534              shrl  REG_34,#$05
4AC3  880036              cmp   REG_36,Zero
4AC6  DF03                je    L4ACB
4AC8  BDFF34              ldbse REG_34,#$FF
4ACB  6C3C30        L4ACB mulu  REG_30,REG_3C
4ACE  8C3430              divu  REG_30,REG_34
4AD1  D503                jnv   L4AD6
4AD3  BDFF30              ldbse REG_30,#$FF
4AD6  F0            L4AD6 ret
;
;*****************************************************************
; Cycling Routine at 2151, routine offset $2C - calc injector pulse width?
;*****************************************************************
;
4AD7  013E                clr   REG_3E					; pulse starts at zero
4AD9  37A151              jbc   REG_A1,BIT_07,L4B2D		; jump if not CRANKING
4ADC  382430              jbs   REG_24,BIT_00,L4B0F		; check WOT flag
4ADF  45D200FA            add   REG_32,REG_FA,#$00D2	; TALBLE $987A Cranking Fuel Pulse Width vs ECT
      32
4AE4  BCB034              ldbse REG_34,REG_B0			; Engine Coolant Temperature - degrees F ?
4AE7  EF17EB              lcall L3601					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
4AEA  AF748036            ldbze REG_36,$80[REG_74]		; BP - barometric pressure
4AEE  6C3638              mulu  REG_38,REG_36
4AF1  8DEF0038            divu  REG_38,#$00EF
4AF5  D503                jnv   L4AFA
4AF7  BDFF38              ldbse REG_38,#$FF
4AFA  C04238        L4AFA st    REG_38,REG_42			; injector pulse width?

4AFD  45BA00FA32          add   REG_32,REG_FA,#$00BA	; TABLE $9862 fuel_crank_pw_multiply_time
4B02  AF72CF34            ldbze REG_34,$CF[REG_72]		; $014F timer?
4B06  EF03EB              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
4B09  4C42383C            mulu  REG_3C,REG_38,REG_42
4B0D  29AE                scall L4CBD					; mult REG_3C LONG times 4 and clamp max to $FFFF-FFFF

; cranking at WOT (REG_3E = 0)
4B0F  A3F44622      L4B0F ld    REG_22,$46[REG_F4]		; ROM $901C ALOSL injector_slope_low
4B13  C3761A3E            st    REG_3E,$1A[REG_76]		; $0394 BGFUL1 Background Fuel Pulsewidth for bank1
4B17  C3761C3E            st    REG_3E,$1C[REG_76]		; $0396 BGFUL2 Background Fuel Pulsewidth for bank2
4B1B  4C223E3C            mulu  REG_3C,REG_3E,REG_22
4B1F  299C                scall L4CBD					; mult REG_3C LONG times 4 and clamp max to $FFFF-FFFF
4B21  C372163E            st    REG_3E,$16[REG_72]		; $0196 LBMF_INJ1 = The pounds mass of fuel per injection that is calculated for summing to be sent out on the Data Output Link (DOL)
4B25  C372183E            st    REG_3E,$18[REG_72]		; $0198 LBMF_INJ2
4B29  71DFE7              andb  REG_E7,#$DF
4B2C  F0                  ret

; not cranking (pulse width in REG_3E = 0 here)
4B2D  3B2FDF        L4B2D jbs   REG_2F,BIT_03,L4B0F		; NLMT_FLG = Engine Speed Limiter Flag - (1 = limit engine speed by turning off the fuel; 0 = normal engine speed)
4B30  32EE05              jbc   REG_EE,BIT_02,L4B38
4B33  EFF6F9              lcall L452C
4B36  2003                sjmp  L4B3B
4B38  EF8BF7        L4B38 lcall L42C6

4B3B  A3748C38      L4B3B ld    REG_38,$8C[REG_74]		; LAMBSE2(word) - Desired fuel ratio for the left side bank of injectors
4B3F  69008038            sub   REG_38,#$8000
4B43  C3748438            st    REG_38,$84[REG_74]

4B47  A3748E38            ld    REG_38,$8E[REG_74]		; LAMBSE1(word) - Desired fuel ratio for the right side bank of injectors
4B4B  69008038            sub   REG_38,#$8000
4B4F  C3748638            st    REG_38,$86[REG_74]

4B53  2DE6                scall L493B
4B55  EF3504              lcall L4F8D
4B58  EFA201              lcall L4CFD
;
;*****************************************************************
; Cycling Routine at 2151, routine offset $8E				Fall thru?
;*****************************************************************
;
4B5B  0116                clr   REG_16
4B5D  2826                scall L4B85
4B5F  AFFE1616            ldbze REG_16,$16[REG_FE]		; ROM $9E70 number_of_HEGOs
4B63  311602              jbc   REG_16,BIT_01,L4B68		; jmp if 2 hegos (must assume 0,1,or 2 only possible configs)
4B66  281D                scall L4B85
4B68  9BF20200      L4B68 cmpb  Zero,$02[REG_F2]		; ROM $8E5C = 00 = BFULSW = Force  Background  Fuel  Switch
4B6C  D713                jne   L4B81
4B6E  382610              jbs   REG_26,BIT_00,L4B81		; MAF input range error?
4B71  3BC50D              jbs   REG_C5,BIT_03,L4B81
4B74  38E70A              jbs   REG_E7,BIT_00,L4B81
4B77  3AE707              jbs   REG_E7,BIT_02,L4B81
4B7A  3B2504              jbs   REG_25,BIT_03,L4B81
4B7D  9120E7              orb   REG_E7,#$20
4B80  F0                  ret

4B81  71DFE7        L4B81 andb  REG_E7,#$DF
4B84  F0                  ret

4B85  EF0202        L4B85 lcall L4D8A
4B88  B14038              ldb   REG_38,#$40
4B8B  32A10B              jbc   REG_A1,BIT_02,L4B99		; UNDSP = Run/Underspeed Flag.  (1 = Underspeed (or CRANK), 0 = Run)
4B8E  45F600FA            add   REG_32,REG_FA,#$00F6	; TABLE $989E
      32
4B93  B0B034              ldb   REG_34,REG_B0			; Engine Coolant Temperature - degrees F ?
4B96  EF13EA              lcall L35AC					; Interpolate Single var Table R32-table,R34-in,R38-out
4B99  5C384014      L4B99 mulub REG_14,REG_40,REG_38
4B9D  A0A240              ld    REG_40,REG_A2			; REG_A2 = AM = Air mass flow for the engine (lb/min)
4BA0  28C6                scall L4C68
4BA2  C3178201            st    REG_42,$0182[REG_16]
      42
4BA7  28D6                scall L4C7F
4BA9  D603                jge   L4BAE
4BAB  6C0040              mulu  REG_40,Zero				; clr 4 bytes
4BAE  28D8          L4BAE scall L4C88
4BB0  C3173402            st    REG_42,$0234[REG_16]	; FUELFLOW1 set flags effecting $7XXX ad reads ??????????
      42
4BB5  A0421E              ld    REG_1E,REG_42
4BB8  011C                clr   REG_1C
4BBA  0C041C              shrl  REG_1C,#$04
4BBD  AFFE0718            ldbze REG_18,$07[REG_FE]		; ROM $9E5A+7 = 9E61 value = $08=ENGCYL=Number of cylinders per engine revolution
4BC1  6CAE18              mulu  REG_18,REG_AE			; REG_AE = engine RPM * 4
4BC4  0C0318              shrl  REG_18,#$03
4BC7  8C181C              divu  REG_1C,REG_18
4BCA  D503                jnv   L4BCF
4BCC  BDFF1C              ldbse REG_1C,#$FF
4BCF  C31796011C    L4BCF st    REG_1C,$0196[REG_16]


   Determine on which slope the  injector  is  operating  and  calculate  the  fuel
      pulsewidth  (BGFULn)  and  foreground  fuel  intermediate  values (FFULMn and
      FFULCn).

 ; Determine the intersection point, in fuelflow, of the two slopes of the injector flow vs time transfer functions.
;  fuel_f = FN389(VBAT) * N / 2
4BD4  455602F432          add   REG_32,REG_F4,#$0256	; TABLE $922C FN389(VBAT) = Dual slope injector breakpoint.Input = VBAT, volts and Output = lb/rev
4BD9  AF749334            ldbze REG_34,$93[REG_74]		; Battery Voltage Level * 16
4BDD  EF2CEA              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
4BE0  6CAE38              mulu  REG_38,REG_AE			; REG_AE = engine RPM * 4
4BE3  0C0138              shrl  REG_38,#$01				; REG_38 here is fuel_f

4BE6  6C001C              mulu  REG_1C,Zero				; load long zero REG_1C/1D/1E/1F

4BE9  A3F44622            ld    REG_22,$46[REG_F4]		; ROM $901C  ALOSL injector_slope_low
4BED  883A42              cmp   REG_42,REG_3A			; FUELFLOW1 : fuel_f
4BF0  D115                jnh   L4C07
4BF2  28B2                scall L4CA6					; Calculate the value of the pulsewidth conversion factor (PWCF) = REG_30
4BF4  A0301C              ld    REG_1C,REG_30			; PWCF

4BF7  A3F44822            ld    REG_22,$48[REG_F4]		; ROM $901E AHISL injector_slope_high
4BFB  28A9                scall L4CA6					; Calculate the value of the pulsewidth conversion factor (PWCF) = REG_30

4BFD  48301C1E            sub   REG_1E,REG_1C,REG_30	; PWCFs
4C01  683A42              sub   REG_42,REG_3A
4C04  A83840              subc  REG_40,REG_38

4C07  28A5          L4C07 scall L4CAE					; Calculate the value of the pulsewidth conversion factor (PWCF) = REG_30
4C09  641C30              add   REG_30,REG_1C
4C0C  D303                jnc   L4C11
4C0E  BDFF30              ldbse REG_30,#$FF				; clamp
4C11  C317940330    L4C11 st    REG_30,$0394[REG_16]	; BGFUL[bank] fuel pulsewidth

4C16  6C0040              mulu  REG_40,Zero
4C19  1114                clrb  REG_14
4C1B  2862                scall L4C7F
4C1D  D609                jge   L4C28
4C1F  1714                incb  REG_14
4C21  0242                not   REG_42
4C23  0340                neg   REG_40
4C25  A40042              addc  REG_42,Zero
4C28  285E          L4C28 scall L4C88
4C2A  2882                scall L4CAE					; Calculate the value of the pulsewidth conversion factor (PWCF) = REG_30
4C2C  A1FF7F32            ld    REG_32,#$7FFF
4C30  883230              cmp   REG_30,REG_32
4C33  D103                jnh   L4C38
4C35  A03230              ld    REG_30,REG_32
4C38  301402        L4C38 jbc   REG_14,BIT_00,L4C3D
4C3B  0330                neg   REG_30
4C3D  641E30        L4C3D add   REG_30,REG_1E
4C40  D507                jnv   L4C49
4C42  A03230              ld    REG_30,REG_32
4C45  D602                jge   L4C49
4C47  0330                neg   REG_30
4C49  C3179C03      L4C49 st    REG_30,$039C[REG_16]
      30
4C4E  A0A240              ld    REG_40,REG_A2			; REG_A2 = AM = Air mass flow for the engine (lb/min)
4C51  2815                scall L4C68
4C53  2833                scall L4C88
4C55  2857                scall L4CAE					; Calculate the value of the pulsewidth conversion factor (PWCF) = REG_30
4C57  A374D432            ld    REG_32,$D4[REG_74]		; $0252 ARCHG = Air Charge Mass inducted per Intake Stroke, lbm/Intake.
4C5B  FA                  di
4C5C  FF                  nop
4C5D  C3179803            st    REG_30,$0398[REG_16]	; FFULM[R16]
      30
4C62  C3762632            st    REG_32,$26[REG_76]
4C66  FB                  ei
4C67  F0                  ret

4C68  6D7C1140      L4C68 mulu  REG_40,#$117C

; FIXME EDIT ERROR?

4066  8FF4443C            divu  REG_3C,$44[REG_F4]		; ROM $901A engine_displacement contents = $1B4A = 6986 - engine_displacement ( one unit = 0.0430981 Cubic Inches)
406A  D503                jnv   L406F



4C7B  0D0540              shll  REG_40,#$05
4C7E  F0                  ret

4C7F  67762A40      L4C7F add   REG_40,$2A[REG_76]
4C83  A7762842            addc  REG_42,$28[REG_76]
4C87  F0                  ret

4C88  990743        L4C88 cmpb  REG_43,#$07
4C8B  D105                jnh   L4C92
4C8D  BDFF42              ldbse REG_42,#$FF
4C90  2003                sjmp  L4C95
4C92  0D0540        L4C92 shll  REG_40,#$05
4C95  4C144240      L4C95 mulu  REG_40,REG_42,REG_14
4C99  991F43              cmpb  REG_43,#$1F
4C9C  D104                jnh   L4CA2
4C9E  BDFF42              ldbse REG_42,#$FF
4CA1  F0                  ret

4CA2  0D0340        L4CA2 shll  REG_40,#$03
4CA5  F0                  ret

; PWCF = Computed value to convert amount of fuel for the engine to  amount of fuel to be delivered by each injector
; Calculate the value of the pulsewidth conversion factor (PWCF) = REG_30
4CA6  A0383C        L4CA6 ld    REG_3C,REG_38
4CA9  A03A3E              ld    REG_3E,REG_3A
4CAC  2006                sjmp  L4CB4

; PWCF = Computed value to convert amount of fuel for the engine to  amount of fuel to be delivered by each injector
; Calculate the value of the pulsewidth conversion factor (PWCF) = REG_30
4CAE  A0403C        L4CAE ld    REG_3C,REG_40
4CB1  A0423E              ld    REG_3E,REG_42

4CB4  0C043C        L4CB4 shrl  REG_3C,#$04		; long div by 16
4CB7  8C223C              divu  REG_3C,REG_22
4CBA  2DE2                scall L4A9E			; Calculate the value of the pulsewidth conversion factor (PWCF) = REG_30
4CBC  F0                  ret

; mult REG_3C long times 4 and clamp max to $FFFF-FFFF
4CBD  993F3F        L4CBD cmpb  REG_3F,#$3F	; clamp max REG_3F to $03FFF
4CC0  D104                jnh   L4CC6
4CC2  A1FF3F3E            ld    REG_3E,#$3FFF
4CC6  0D023C        L4CC6 shll  REG_3C,#$02     ; long * 4
4CC9  F0                  ret
;
;*****************************************************************
; Cycling Routine at 2151, routine offset $1E
; update fuel comsumption for DOL
;*****************************************************************
;
4CCA  9B74CE00      L4CCA cmpb  Zero,$CE[REG_74]		; $024C - Fuel Sum High for DOL since last sum period start
4CCE  D22C                jgt   L4CFC
4CD0  AFFC3114            ldbze REG_14,$31[REG_FC]		; ROM $9AAF INJOUT - Number of injectors fired by each output port.
4CD4  6D7C1E14            mulu  REG_14,#$1E7C
4CD8  0118                clr   REG_18
4CDA  A100021A            ld    REG_1A,#$0200
4CDE  8C1418              divu  REG_18,REG_14
4CE1  FA                  di

4CE2  A374CC14            ld    REG_14,$CC[REG_74]		; $024A - Fuel Sum Low for DOL since last sum period start
4CE6  AF74CE16            ldbze REG_16,$CE[REG_74]		; $024C - Fuel Sum High for DOL since last sum period start
4CEA  8C1814              divu  REG_14,REG_18
4CED  C374CC16            st    REG_16,$CC[REG_74]		; $024A - Fuel Sum Low for DOL since last sum period start
4CF1  C774CE00            stb   Zero,$CE[REG_74]		; $024C - Fuel Sum High for DOL since last sum period start

4CF5  090114              shl   REG_14,#$01
4CF8  6414C6              add   REG_C6,REG_14			; add to Data Output Link Count
4CFB  FB                  ei
4CFC  F0            L4CFC ret
;
;**********************************************************
;
4CFD  113E          L4CFD clrb  REG_3E
4CFF  3E2616              jbs   REG_26,BIT_06,L4D18
4D02  9BF40800            cmpb  Zero,$08[REG_F4]
4D06  DF10                je    L4D18
4D08  453F00FC            add   REG_30,REG_FC,#$003F		; ROM $9ABD - NITMR3 - ATMR1 timed delay to enter Closed Loop fuel after Hot start, sec. Range of 0 to 255 sec., accuracy 1 sec.	
      30
4D0D  EF3FEA              lcall L374F
4D10  DB06                jc    L4D18
4D12  B3F4093F            ldb   REG_3F,$09[REG_F4]
4D16  2064                sjmp  L4D7C

4D18  33EF0C        L4D18 jbc   REG_EF,BIT_03,L4D27
4D1B  9BFC3E00            cmpb  Zero,$3E[REG_FC]
4D1F  DF06                je    L4D27
4D21  B3FC3D3F            ldb   REG_3F,$3D[REG_FC]
4D25  2055                sjmp  L4D7C

4D27  30EC06        L4D27 jbc   REG_EC,BIT_00,L4D30
4D2A  B3FC3C3F            ldb   REG_3F,$3C[REG_FC]
4D2E  204C                sjmp  L4D7C

4D30  45DE00F0      L4D30 add   REG_32,REG_F0,#$00DE		; TABLE $8CDE spark_table_RPM_scaling
      32
4D35  A0AE34              ld    REG_34,REG_AE				; REG_AE = engine RPM * 4
4D38  EFD1E8              lcall L360C						; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
4D3B  080438              shr   REG_38,#$04
4D3E  B03830              ldb   REG_30,REG_38
4D41  457201F4            add   REG_32,REG_F4,#$0172		; TABLE $9148 injector_time_load_scaling
      32
4D46  A374DE34            ld    REG_34,$DE[REG_74]	    	; engine load (VE?)
4D4A  EFBFE8              lcall L360C						; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
4D4D  B03832              ldb   REG_32,REG_38
4D50  AD0A34              ldbze REG_34,#$0A
4D53  458A01F4            add   REG_38,REG_F4,#$018A		; TABLE $9160 - Injector Timing (crank degrees)(RPM vs Load)
      38
4D58  EF80E9              lcall L36DB						; Interpolate two var table R38-Table
4D5B  113C                clrb  REG_3C
4D5D  B03B3D              ldb   REG_3D,REG_3B
4D60  08013C              shr   REG_3C,#$01
4D63  6FF4263C            mulu  REG_3C,$26[REG_F4]
4D67  67F4283E            add   REG_3E,$28[REG_F4]			; ROM $8FFE injector_delay_global = 0
4D6B  D602                jge   L4D6F
4D6D  013E                clr   REG_3E
4D6F  89002D3E      L4D6F cmp   REG_3E,#$2D00
4D73  D104                jnh   L4D79
4D75  A1002D3E            ld    REG_3E,#$2D00
4D79  09023E        L4D79 shl   REG_3E,#$02

4D7C  EFD5E8        L4D7C lcall L3654
4D7F  8001                word  $0180	; Old AD sensor address - INJDLY
4D81  3E00                word  $003E	; new AD sensor address
4D83  58D0                word  $D058	; funny index for difference filter
4D85  C372003E            st    REG_3E,$00[REG_72] 	; filtered sensor output $0180 - INJDLY

4D89  F0                  ret

4D8A  A3FC461A      L4D8A ld    REG_1A,$46[REG_FC]
4D8E  8B74DE1A            cmp   REG_1A,$DE[REG_74]	    	; engine load (VE?)
4D92  D105                jnh   L4D99
4D94  9180E8              orb   REG_E8,#$80
4D97  2012                sjmp  L4DAB
4D99  67FC481A      L4D99 add   REG_1A,$48[REG_FC]
4D9D  D303                jnc   L4DA2
4D9F  BDFF1A              ldbse REG_1A,#$FF
4DA2  8B74DE1A      L4DA2 cmp   REG_1A,$DE[REG_74]	    	; engine load (VE?)
4DA6  DB03                jc    L4DAB
4DA8  717FE8              andb  REG_E8,#$7F
4DAB  B3FE0220      L4DAB ldb   REG_20,$02[REG_FE]			; ROM $9E5C
4DAF  990220              cmpb  REG_20,#$02
4DB2  D303                jnc   L4DB7
4DB4  37E705              jbc   REG_E7,BIT_07,L4DBC
4DB7  9140E8        L4DB7 orb   REG_E8,#$40
4DBA  200E                sjmp  L4DCA
4DBC  990420        L4DBC cmpb  REG_20,#$04
4DBF  DB06                jc    L4DC7
4DC1  9BFC4ECC            cmpb  REG_CC,$4E[REG_FC]			; REG_CC timer?
4DC5  D303                jnc   L4DCA
4DC7  71BFE8        L4DC7 andb  REG_E8,#$BF
4DCA  9BFC52CD      L4DCA cmpb  REG_CD,$52[REG_FC]		; timer?
4DCE  D105                jnh   L4DD5
4DD0  9120E8              orb   REG_E8,#$20
4DD3  2008                sjmp  L4DDD
4DD5  9800CD        L4DD5 cmpb  REG_CD,Zero				; timer?
4DD8  DF03                je    L4DDD
4DDA  71DFE8              andb  REG_E8,#$DF
4DDD  1118          L4DDD clrb  REG_18
4DDF  B372E619            ldb   REG_19,$E6[REG_72]
4DE3  080218              shr   REG_18,#$02
4DE6  4818AE18            sub   REG_18,REG_AE,REG_18	; REG_AE = engine RPM * 4
4DEA  8BFC5618            cmp   REG_18,$56[REG_FC]
4DEE  DA05                jle   L4DF5
4DF0  9110E8              orb   REG_E8,#$10
4DF3  2010                sjmp  L4E05
4DF5  A3FC561A      L4DF5 ld    REG_1A,$56[REG_FC]
4DF9  6BFC581A            sub   REG_1A,$58[REG_FC]
4DFD  88181A              cmp   REG_1A,REG_18
4E00  DE03                jlt   L4E05
4E02  71EFE8              andb  REG_E8,#$EF
4E05  8BFC4A18      L4E05 cmp   REG_18,$4A[REG_FC]		; ROM $9AC8 min_rpm_decel_fuel_shutoff
4E09  DA05                jle   L4E10
4E0B  9108E8              orb   REG_E8,#$08
4E0E  2010                sjmp  L4E20
4E10  A3FC4A1A      L4E10 ld    REG_1A,$4A[REG_FC]		; ROM $9AC8 min_rpm_decel_fuel_shutoff
4E14  6BFC4C1A            sub   REG_1A,$4C[REG_FC]
4E18  88181A              cmp   REG_1A,REG_18
4E1B  DA03                jle   L4E20
4E1D  71F7E8              andb  REG_E8,#$F7
4E20  B3FC5C1A      L4E20 ldb   REG_1A,$5C[REG_FC]
4E24  9B743F1A            cmpb  REG_1A,$3F[REG_74]		; $2BD - vehicle speed filtered(1) (MPH) $02BC is 8.8 format VSS
4E28  D905                jh    L4E2F
4E2A  9108CA              orb   REG_CA,#$08
4E2D  200F                sjmp  L4E3E
4E2F  7BFC5D1A      L4E2F subb  REG_1A,$5D[REG_FC]
4E33  D309                jnc   L4E3E
4E35  9B743F1A            cmpb  REG_1A,$3F[REG_74]		; $2BD - vehicle speed filtered(1) (MPH) $02BC is 8.8 format VSS
4E39  D103                jnh   L4E3E
4E3B  71F7CA              andb  REG_CA,#$F7
4E3E  A374DE34      L4E3E ld    REG_34,$DE[REG_74]	    ; engine load (VE?)
4E42  8BFC5E34            cmp   REG_34,$5E[REG_FC]
4E46  DB05                jc    L4E4D
4E48  9104CA              orb   REG_CA,#$04
4E4B  2009                sjmp  L4E56
4E4D  8BFC6034      L4E4D cmp   REG_34,$60[REG_FC]
4E51  D103                jnh   L4E56
4E53  71FBCA              andb  REG_CA,#$FB
4E56  9108A1        L4E56 orb   REG_A1,#$08				; set DMFLG = Decel fuel low load timer enabled flag, 1 = Count up timer.
4E59  37D003              jbc   REG_D0,BIT_07,L4E5F		; jmp if throttle is not closed
4E5C  3ACA07              jbs   REG_CA,BIT_02,L4E66
4E5F  71F7A1        L4E5F andb  REG_A1,#$F7				; clr DMFLG = Decel fuel low load timer enabled flag, 1 = Count up timer.
4E62  C772D000            stb   Zero,$D0[REG_72]		; zero $0150 timer?
4E66  51F8C532      L4E66 andb  REG_32,REG_C5,#$F8
4E6A  D774                jne   L4EE0
4E6C  456A03FC            add   REG_32,REG_FC,#$036A	; ROM TABLE $9DE8 Open Loop Fuel Multiplier vs RPM
      32
4E71  A0AE34              ld    REG_34,REG_AE			; REG_AE = engine RPM * 4
4E74  EF95E7              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
4E77  A03840              ld    REG_40,REG_38
4E7A  33E863              jbc   REG_E8,BIT_03,L4EE0
4E7D  38EC60              jbs   REG_EC,BIT_00,L4EE0
4E80  3D2A5D              jbs   REG_2A,BIT_05,L4EE0		; jump if running self tests
4E83  9BFC45B0            cmpb  REG_B0,$45[REG_FC]		; Engine Coolant Temperature - degrees F ? : ROM $9AC3 min_ect_decel_fuel_shutoff (140.0DegF)
4E87  D606                jge   L4E8F
4E89  9BF40DC8            cmpb  REG_C8,$0D[REG_F4]		; (REG_C8 may be a byte size counter for ATMR1)
4E8D  D151                jnh   L4EE0
4E8F  33A10A        L4E8F jbc   REG_A1,BIT_03,L4E9C		; DMFLG = Decel fuel low load timer enabled flag, 1 = Count up timer.
4E92  B372D01A            ldb   REG_1A,$D0[REG_72]		; $0150 timer?
4E96  9BFC621A            cmpb  REG_1A,$62[REG_FC]
4E9A  D33C                jnc   L4ED8
4E9C  37D014        L4E9C jbc   REG_D0,BIT_07,L4EB3		; jmp if throttle is not closed
4E9F  3FE711              jbs   REG_E7,BIT_07,L4EB3
4EA2  34E80E              jbc   REG_E8,BIT_04,L4EB3
4EA5  990320              cmpb  REG_20,#$03
4EA8  D909                jh    L4EB3
4EAA  B3FC4F1A            ldb   REG_1A,$4F[REG_FC]
4EAE  98CC1A              cmpb  REG_1A,REG_CC			; REG_CC timer?
4EB1  D925                jh    L4ED8
4EB3  37E82A        L4EB3 jbc   REG_E8,BIT_07,L4EE0
4EB6  36E827              jbc   REG_E8,BIT_06,L4EE0
4EB9  33CA24              jbc   REG_CA,BIT_03,L4EE0
4EBC  9BFC6300            cmpb  Zero,$63[REG_FC]
4EC0  D716                jne   L4ED8
4EC2  37D01B              jbc   REG_D0,BIT_07,L4EE0		; jmp if throttle is not closed
4EC5  B372AA1A            ldb   REG_1A,$AA[REG_72]		; $012A timer?
4EC9  9BFC501A            cmpb  REG_1A,$50[REG_FC]
4ECD  D311                jnc   L4EE0
4ECF  3DE806              jbs   REG_E8,BIT_05,L4ED8
4ED2  9BFC511A            cmpb  REG_1A,$51[REG_FC]
4ED6  D108                jnh   L4EE0
4ED8  9102CA        L4ED8 orb   REG_CA,#$02
4EDB  B101B3              ldb   REG_B3,#$01
4EDE  2007                sjmp  L4EE7
4EE0  A1800040      L4EE0 ld    REG_40,#$0080
4EE4  71FDCA              andb  REG_CA,#$FD
4EE7  71FD27        L4EE7 andb  REG_27,#$FD
4EEA  89000040            cmp   REG_40,#$0000
4EEE  D703                jne   L4EF3
4EF0  910227              orb   REG_27,#$02
4EF3  F0            L4EF3 ret
;
;*****************************************************************
; Cycling Routine at 2151, routine offset E
;*****************************************************************
;
4EF4  0138          L4EF4 clr   REG_38
4EF6  37A102              jbc   REG_A1,BIT_07,L4EFB		; jump if not CRANKING
4EF9  2089          L4EF9 sjmp  L4F84
4EFB  B3742030      L4EFB ldb   REG_30,$20[REG_74]		; scale and translated TAR
4EFF  9BF43430            cmpb  REG_30,$34[REG_F4]
4F03  D1F4                jnh   L4EF9
4F05  352910              jbc   REG_29,BIT_05,L4F18
4F08  A374DE42            ld    REG_42,$DE[REG_74]	    ; engine load (VE?)
4F0C  6B749E42            sub   REG_42,$9E[REG_74]
4F10  D306                jnc   L4F18
4F12  8BF43242            cmp   REG_42,$32[REG_F4]
4F16  D16C                jnh   L4F84
4F18  459E00F032    L4F18 add   REG_32,REG_F0,#$009E	; TABLE $8C9E fuel_table_tp_scaling
4F1D  B3742034            ldb   REG_34,$20[REG_74]		; scale and translated TAR
4F21  EF93E6              lcall L35B7					; Interpolate Single var Table R32-table,R34-in,R38-out
4F24  B03830              ldb   REG_30,REG_38
4F27  45A800F032          add   REG_32,REG_F0,#$00A8	; TABLE $8CA8 fuel_table_XX_scaling (@@ what is XX???@@)
4F2C  B3F43536            ldb   REG_36,$35[REG_F4]
4F30  EFB5F7              lcall L46E8
4F33  0A0734              shra  REG_34,#$07
4F36  EF73E6              lcall L35AC					; Interpolate Single var Table R32-table,R34-in,R38-out
4F39  B03832              ldb   REG_32,REG_38
4F3C  AD0834              ldbze REG_34,#$08
4F3F  45F501F4            add   REG_38,REG_F4,#$01F5	; TABLE $91CB - accel pump rate - (Deg/sec vs ECT)
      38
4F44  EF94E7              lcall L36DB					; Interpolate two var table R38-Table
4F47  AC3B3C              ldbze REG_3C,REG_3B
4F4A  45EB01F4            add   REG_32,REG_F4,#$01EB	; TABLE $91C1 - Accelerator Enrichment Multiplier vs TP
      32
4F4F  4B72A6AA            sub   REG_34,REG_AA,$A6[REG_72]	; REG_AA is Throttle position - $0126 - RATCH=Closed TP
      34
4F54  DB02                jc    L4F58
4F56  0134                clr   REG_34
4F58  080834        L4F58 shr   REG_34,#$08
4F5B  EF59E6              lcall L35B7					; Interpolate Single var Table R32-table,R34-in,R38-out
4F5E  6C383C              mulu  REG_3C,REG_38
4F61  B3748034            ldb   REG_34,$80[REG_74]		; BP - barometric pressure
4F65  45A601F0            add   REG_32,REG_F0,#$01A6	; TABLE $90A6
      32
4F6A  EF4AE6              lcall L35B7					; Interpolate Single var Table R32-table,R34-in,R38-out
4F6D  1139                clrb  REG_39
4F6F  6C383C              mulu  REG_3C,REG_38
4F72  0D033C              shll  REG_3C,#$03
4F75  A3F42C38            ld    REG_38,$2C[REG_F4]		; ROM $9002 - accel_pump_global_multiplier
4F79  6C3E38              mulu  REG_38,REG_3E
4F7C  98003A              cmpb  REG_3A,Zero
4F7F  DF03                je    L4F84
4F81  BDFF38              ldbse REG_38,#$FF
4F84  6D220238      L4F84 mulu  REG_38,#$0222
4F88  C3720C3A            st    REG_3A,$0C[REG_72]
4F8C  F0                  ret

4F8D  B3F43E18      L4F8D ldb   REG_18,$3E[REG_F4]
4F91  3FA109              jbs   REG_A1,BIT_07,L4F9D		; jump if CRANKING
4F94  3AA106              jbs   REG_A1,BIT_02,L4F9D		; UNDSP = Run/Underspeed Flag.  (1 = Underspeed (or CRANK), 0 = Run)
4F97  9BF43AC8            cmpb  REG_C8,$3A[REG_F4]		; (REG_C8 may be a byte size counter for ATMR1)
4F9B  DB07                jc    L4FA4
4F9D  71F728        L4F9D andb  REG_28,#$F7
4FA0  0138                clr   REG_38
4FA2  2123                sjmp  L50C7
4FA4  45D200F0      L4FA4 add   REG_32,REG_F0,#$00D2	; TABLE $8CD2 Temperature normalizing function; used for table lookup
      32
4FA9  B3F42A36            ldb   REG_36,$2A[REG_F4]		; ROM
4FAD  EF38F7              lcall L46E8
4FB0  0A0734              shra  REG_34,#$07
4FB3  EFF6E5              lcall L35AC					; Interpolate Single var Table R32-table,R34-in,R38-out
4FB6  AC38A6              ldbze REG_A6,REG_38
4FB9  45FA00F032          add   REG_32,REG_F0,#$00FA	; TABLE $8CFA load_scaling
4FBE  A374DE34            ld    REG_34,$DE[REG_74]	    ; engine load (VE?)
4FC2  EF47E6              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
4FC5  080438              shr   REG_38,#$04
4FC8  A038A8              ld    REG_A8,REG_38
4FCB  A0A630              ld    REG_30,REG_A6
4FCE  A0A832              ld    REG_32,REG_A8
4FD1  AD0A34              ldbze REG_34,#$0A
4FD4  45BA02FC            add   REG_38,REG_FC,#$02BA	; ROM TABLE $9D38 Equilibrium Fuel Transfer Constant
      38
4FD9  EFFFE6              lcall L36DB					; Interpolate two var table R38-Table
4FDC  5FF43C3B            mulub REG_40,REG_3B,$3C[REG_F4] ; ROM $9012
      40
4FE1  A0A630              ld    REG_30,REG_A6
4FE4  A0A832              ld    REG_32,REG_A8
4FE7  AD0A34              ldbze REG_34,#$0A
4FEA  456A02FC38          add   REG_38,REG_FC,#$026A	; ROM TABLE $9CE8 FN1321 Equilibrium Intake Surface Fuel Table
4FEF  EFE9E6              lcall L36DB					; Interpolate two var table R38-Table

4FF2  5FF43B3B3A          mulub REG_3A,REG_3B,$3B[REG_F4] ; ROM $9011 MTEISF = Equilibrium intake surface fuel multiplier
4FF7  08013A              shr   REG_3A,#$01
4FFA  332814              jbc   REG_28,BIT_03,L5011		; EFFLG1 = Equilibrium Fuel Flag. This flag controls the initialization of AISF
4FFD  312729              jbc   REG_27,BIT_01,L5029		; DFSFLG = Indicates DECEL Fuel shutoff
5000  AFFC4438            ldbze REG_38,$44[REG_FC]		; ROM $9AC2 - AISFM = Multiplier on AISF when in DFSO. Determines Fuel Puddle size upon re-entering normal fuel
5004  6C3A38              mulu  REG_38,REG_3A
5007  0D0938              shll  REG_38,#$09
500A  D30E                jnc   L501A
500C  BDFF3A              ldbse REG_3A,#$FF
500F  2009                sjmp  L501A
5011  B3F43D14      L5011 ldb   REG_14,$3D[REG_F4]		; ROM $9013 = TFCISW = Transient fuel compensation initialization switch
5015  381402              jbs   REG_14,BIT_00,L501A
5018  013A                clr   REG_3A

501A  C3741400      L501A st    Zero,$14[REG_74]
501E  C374163A            st    REG_3A,$16[REG_74]		; $0294 = AISF = Actual Intake Surface Fuel

5022  0138                clr   REG_38
5024  910828              orb   REG_28,#$08
5027  209E                sjmp  L50C7
5029  4B741806      L5029 sub   REG_34,Master_IO_Timer_Lo,$18[REG_74]
      34
502E  C3741806            st    Master_IO_Timer_Lo,$18[REG_74]
5032  6D442834            mulu  REG_34,#$2844
5036  A03634              ld    REG_34,REG_36
5039  FE6C9E34            mul   REG_34,REG_9E
503D  67741434            add   REG_34,$14[REG_74]
5041  A7741636            addc  REG_36,$16[REG_74]
5045  C3741434            st    REG_34,$14[REG_74]
5049  C3741636            st    REG_36,$16[REG_74]
504D  1118                clrb  REG_18
504F  3BEC4E              jbs   REG_EC,BIT_03,L50A0
5052  9B72D700            cmpb  Zero,$D7[REG_72]
5056  DE48                jlt   L50A0
5058  DF11                je    L506B
505A  AF72E630            ldbze REG_30,$E6[REG_72]
505E  090630              shl   REG_30,#$06
5061  4830AE30            sub   REG_30,REG_AE,REG_30		; REG_AE = engine RPM * 4
5065  8BF43830            cmp   REG_30,$38[REG_F4]
5069  DE35                jlt   L50A0
506B  8B74163A      L506B cmp   REG_3A,$16[REG_74]
506F  DF2F                je    L50A0
5071  4B74163A            sub   REG_34,REG_3A,$16[REG_74]
      34
5076  D902                jh    L507A
5078  0334                neg   REG_34
507A  0136          L507A clr   REG_36
507C  0D0834              shll  REG_34,#$08
507F  88003A              cmp   REG_3A,Zero
5082  D705                jne   L5089
5084  A03634              ld    REG_34,REG_36
5087  2003                sjmp  L508C
5089  8C3A34        L5089 divu  REG_34,REG_3A
508C  8BF44034      L508C cmp   REG_34,$40[REG_F4]			; ROM $9016 = TFCDED = Percentage deadband around Equilibrium Intake Surface Fuel to turn off transient fuel
5090  D10E                jnh   L50A0
5092  B3F43E18            ldb   REG_18,$3E[REG_F4]			; ROM $9014 = MEFTRA = Multiplier for accelerations
5096  8B74163A            cmp   REG_3A,$16[REG_74]
509A  DB04                jc    L50A0
509C  B3F43F18            ldb   REG_18,$3F[REG_F4]			; ROM $9015 = MEFTRD = Multiplier for decelerations

50A0  1142          L50A0 clrb  REG_42
50A2  6B74163A            sub   REG_3A,$16[REG_74]			; $0294 = AISF = Actual Intake Surface Fuel
50A6  DB04                jc    L50AC
50A8  1742                incb  REG_42
50AA  033A                neg   REG_3A
50AC  AFF43638      L50AC ldbze REG_38,$36[REG_F4]			; ROM $900C KFT = Multiplier (can be used to disable transient fuel compensation by setting equal to zero)
50B0  6C3A38              mulu  REG_38,REG_3A
50B3  0D0138              shll  REG_38,#$01
50B6  8C4038              divu  REG_38,REG_40
50B9  DD03                jv    L50BE
50BB  373904              jbc   REG_39,BIT_07,L50C2
50BE  A1FF7F38      L50BE ld    REG_38,#$7FFF

50C2  304202        L50C2 jbc   REG_42,BIT_00,L50C7
50C5  0338                neg   REG_38
50C7  C09E38        L50C7 st    REG_38,REG_9E
50CA  7D7818              mulub REG_18,#$78
50CD  FE6C1838            mul   REG_38,REG_18
50D1  0D0138              shll  REG_38,#$01
50D4  C372083A            st    REG_3A,$08[REG_72]		; $188 - EFTRFF
50D8  0E0138              shral REG_38,#$01
50DB  A3720C18            ld    REG_18,$0C[REG_72]		; $18C - AEFUEL
50DF  080118              shr   REG_18,#$01
50E2  64183A              add   REG_3A,REG_18
50E5  C376283A            st    REG_3A,$28[REG_76]		; #3A2 - AEFTRFF
50E9  C3762A38            st    REG_38,$2A[REG_76]		; $3A4 - AEFTRFFL
50ED  F0                  ret
;
;*****************************************************************
; Cycling Routine at 2151, routine offset $2E
; Update fuel pump enable
;*****************************************************************
;
50EE  38D911        L50EE jbs   REG_D9,BIT_00,L5102		; VIP_FUEL_PUMP_OVERRIDE
50F1  A372BE14            ld    REG_14,$BE[REG_72]		; $013E - timer? time since last PIP recieved
50F5  89000414            cmp   REG_14,#$0400			; 4 seconds?
50F9  D304                jnc   L50FF					; timer < 4 seconds
50FB  717F46              andb  REG_46,#$7F				; LSO output line 7 OFF (Fuel Pump)
50FE  F0                  ret

50FF  918046        L50FF orb   REG_46,#$80				; LSO output line 7 ON (Fuel Pump)
5102  F0            L5102 ret
;
;*****************************************************************
;
5103  3FA128        L5103 jbs   REG_A1,BIT_07,L512E		; jump if CRANKING
5106  51FAC538            andb  REG_38,REG_C5,#$FA
510A  D722                jne   L512E
510C  451F00FA            add   REG_30,REG_FA,#$001F	; TABLE $97C7
      30
5111  EF3BE6              lcall L374F
5114  DB18                jc    L512E
5116  38D015              jbs   REG_D0,BIT_00,L512E		; jmp if throttle is closed or wide open
5119  3EE616              jbs   REG_E6,BIT_06,L5132
511C  A372A838            ld    REG_38,$A8[REG_72]		; $128 - The EGR valve reading when the valve is fully closed in A/D counts
5120  6BFA2838            sub   REG_38,$28[REG_FA]		; ROM $97D0 - Deadband value for EVP - DELOPT, counts
5124  DB02                jc    L5128
5126  0138                clr   REG_38
5128  8B729638      L5128 cmp   REG_38,$96[REG_72]		; compare to raw EVP AD value
512C  D304                jnc   L5132
512E  71FE28        L512E andb  REG_28,#$FE
5131  F0                  ret
5132  910128        L5132 orb   REG_28,#$01
5135  F0                  ret
;
;*****************************************************************
; Cycling Routine at 2151, routine offset $30
; EVP something - large function
;*****************************************************************
;
5136  B3FA3114      L5136 ldb   REG_14,$31[REG_FA]		; ROM $97D9 EGR_Type contents = 00 - egr_type ( 0=sonic, 1=PFE, 2=none)
513A  301403              jbc   REG_14,BIT_00,L5140		; jmp if sonic or no EGR
513D  9140E6              orb   REG_E6,#$40				; PFEHP_FLG - sonic hardware present from calibration data
5140  31140C        L5140 jbc   REG_14,BIT_01,L514F		; jmp if EGR = none or sonic
5143  75029A              addb  REG_9A,#$02				; BG_POINT
5146  C7740A00            stb   Zero,$0A[REG_74]		; $0288 EM - EGR Mass Flow = zero
514A  C772EE00            stb   Zero,$EE[REG_72]		; $016E - EGRACT - Actual EGR percent = 100*EM/AMPEM.
514E  F0                  ret

514F  37A103        L514F jbc   REG_A1,BIT_07,L5155		; jump if not CRANKING
5152  E70D01              ljmp  L5262

5155  3EE603        L5155 jbs   REG_E6,BIT_06,L515B		; PFEHP_FLG - sonic hardware present from calibration data
5158  E79900              ljmp  L51F4

515B  450801FA32    L515B add   REG_32,REG_FA,#$0108	; TABLE $98B0 - BP correction for exhaust backpressure calculation, "Hg
5160  B3748034            ldb   REG_34,$80[REG_74]		; BP - barometric pressure
5164  EF50E4              lcall L35B7					; Interpolate Single var Table R32-table,R34-in,R38-out
5167  C7748138            stb   REG_38,$81[REG_74]		; $01FF - BPCOR - BP corrected
516B  A301B407            ld    REG_34,$07B4[Zero]		; KAMRF1 - Adaptive Fuel strategy correction factor. It is composed of the value LTMTB1rc + .5
      34
5170  6CA234              mulu  REG_34,REG_A2			; REG_A2 = AM = Air mass flow for the engine (lb/min)
5173  0C0734              shrl  REG_34,#$07
5176  880036              cmp   REG_36,Zero
5179  DF03                je    L517E
517B  BDFF34              ldbse REG_34,#$FF
517E  451201FA32    L517E add   REG_32,REG_FA,#$0112	; TABLE $98BA - Upstream pressure as a function of (AM * KAMREF). (KAMREF = Adaptive fuel correction factor), "H20.
5183  EF86E4              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
5186  6D00EF38            mulu  REG_38,#$EF00
518A  B3748137            ldb   REG_37,$81[REG_74]		; $01FF - BPCOR - BP corrected
518E  1136                clrb  REG_36
5190  080136              shr   REG_36,#$01
5193  8C3638              divu  REG_38,REG_36
5196  D503                jnv   L519B
5198  BDFF38              ldbse REG_38,#$FF
519B  C04038        L519B st    REG_38,REG_40
519E  A3728430            ld    REG_30,$84[REG_72]		; $0104 - EPTBAR - Rolling average of the synchronously sampled EPT sensor (time constant = TCEPT), secs
51A2  080130              shr   REG_30,#$01
51A5  A301EE0732          ld    REG_32,$07EE[Zero]		; filtered EVP saved in KAM 
51AA  080132              shr   REG_32,#$01
51AD  683230              sub   REG_30,REG_32
51B0  A3FA2C32            ld    REG_32,$2C[REG_FA]		; ROM $97D4 - XFREPT - Transfer function of EPT sensor, " H20/counts
51B4  FE6C3230            mul   REG_30,REG_32
51B8  28D9                scall L5293
51BA  48324034            sub   REG_34,REG_40,REG_32
51BE  3F3306              jbs   REG_33,BIT_07,L51C7
51C1  DB09                jc    L51CC
51C3  0134                clr   REG_34
51C5  2005                sjmp  L51CC
51C7  D303          L51C7 jnc   L51CC
51C9  BDFF34              ldbse REG_34,#$FF
51CC  C372F634      L51CC st    REG_34,$F6[REG_72]		; $0176 - DELPR - Pressure drop across the control orifice, " H20 = PE - DP
51D0  45B601FA32          add   REG_32,REG_FA,#$01B6	; TABLE $995E - EGR mass flow as a function of DELPR, lb/min.
51D5  EF34E4              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
51D8  B3748034            ldb   REG_34,$80[REG_74]		; BP - barometric pressure
51DC  7D4B34              mulub REG_34,#$4B
51DF  65753A34            add   REG_34,#$3A75
51E3  6C3438              mulu  REG_38,REG_34
51E6  09013A              shl   REG_3A,#$01
51E9  D303                jnc   L51EE
51EB  B1FF3B              ldb   REG_3B,#$FF
51EE  C7740A3B      L51EE stb   REG_3B,$0A[REG_74]		; $0288 EM - EGR Mass Flow
51F2  203E                sjmp  L5232
51F4  1138          L51F4 clrb  REG_38
51F6  51F8C534            andb  REG_34,REG_C5,#$F8
51FA  D732                jne   L522E
51FC  B372D734            ldb   REG_34,$D7[REG_72]		; $0157 - ISCFLG - ISC MODE Flag (1 = RPM CONTROL Mode)
5200  990134              cmpb  REG_34,#$01
5203  DE06                jlt   L520B
5205  8B749000            cmp   Zero,$90[REG_74]		; $020E - DELOPT - Filtered desired EGR valve position.
5209  DF23                je    L522E
520B  A372F034      L520B ld    REG_34,$F0[REG_72]		; $0170 - EVP - EGR valve position reading in A/D counts.
520F  6B72A834            sub   REG_34,$A8[REG_72]		; $0128 - EOFF - The EGR valve reading when the valve is fully closed in A/D counts
5213  DB02                jc    L5217
5215  0134                clr   REG_34
5217  455C01FA32    L5217 add   REG_32,REG_FA,#$015C	; TABLE $9904 - EGR mass flow as a function of EGR valve position (EVP-EOFF).
521C  080834              shr   REG_34,#$08
521F  EFEAE3              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
5222  7F748038            mulub REG_38,$80[REG_74]		; BP - barometric pressure
5226  9DEF38              divub REG_38,#$EF
5229  D503                jnv   L522E
522B  B1FF38              ldb   REG_38,#$FF
522E  C7740A38      L522E stb   REG_38,$0A[REG_74]		; $0288 EM - EGR Mass Flow

5232  B3740A34      L5232 ldb   REG_34,$0A[REG_74]		; $0288 EM - EGR Mass Flow
5236  7DC834              mulub REG_34,#$C8
5239  0136                clr   REG_36
523B  0D0434              shll  REG_34,#$04
523E  8CA434              divu  REG_34,REG_A4
5241  DD06                jv    L5249
5243  89FF0034            cmp   REG_34,#$00FF
5247  D103                jnh   L524C
5249  B1FF34        L5249 ldb   REG_34,#$FF
524C  AF72EE32      L524C ldbze REG_32,$EE[REG_72]		; old AD sensor value - EGRACT -  Actual EGR percent = 100*EM/AMPEM.
5250  C772EE34            stb   REG_34,$EE[REG_72]		; save new over old value $016E - EGRACT -  Actual EGR percent = 100*EM/AMPEM.
5254  1135                clrb  REG_35
5256  36E609              jbc   REG_E6,BIT_06,L5262		; PFEHP_FLG - sonic hardware present from calibration data
5259  EF02E4              lcall L365E					; FILTER AD new val=REG_34
525C  46D0                word  $D046					; funny index for difference filter
525E  C772EE3E            stb   REG_3E,$EE[REG_72] 		; filtered sensor output - EGRACT -  Actual EGR percent = 100*EM/AMPEM.

5262  2E9F          L5262 scall L5103
5264  717F24              andb  REG_24,#$7F
5267  B3FA2A38            ldb   REG_38,$2A[REG_FA]		; ROM $97D2 - EGRMPT - Calibration time delay to ramp EGR in, sec. (EGRATE Ramp time for TCSTRT <or= CTLOW)
526B  9BFE05AD            cmpb  REG_AD,$05[REG_FE]		; ROM $9E5F - CTLOW - Temperature of Engine Coolant at Cold Startup, deg F.
526F  D20F                jgt   L5280
5271  302810              jbc   REG_28,BIT_00,L5284
5274  918024              orb   REG_24,#$80				; set TSEGRE_FLG - 
5277  9B74E638            cmpb  REG_38,$E6[REG_74]		; $0264 timer TSEGRE - Accumulated time EGR is enabled.
527B  D907                jh    L5284
527D  717F24              andb  REG_24,#$7F				; clr TSEGRE_FLG - 
5280  C774E638      L5280 stb   REG_38,$E6[REG_74]		; set $0264 timer TSEGRE
5284  3EE625        L5284 jbs   REG_E6,BIT_06,L52AC		; PFEHP_FLG - sonic hardware present from calibration data
5287  382822              jbs   REG_28,BIT_00,L52AC		; EGREN - Flag which indicates EGR enabled
528A  C772EF00            stb   Zero,$EF[REG_72]		; $016F - EGRATE - Desired EGR rate in percent
528E  C3749000            st    Zero,$90[REG_74]		; $020E - DELOPT - Filtered desired EGR valve position.
5292  F0                  ret

5293  8900E732      L5293 cmp   REG_32,#$E700
5297  D605                jge   L529E
5299  A1009C32            ld    REG_32,#$9C00
529D  F0                  ret
529E  89800C32      L529E cmp   REG_32,#$0C80
52A2  DA04                jle   L52A8
52A4  A1800C32            ld    REG_32,#$0C80
52A8  090232        L52A8 shl   REG_32,#$02
52AB  F0                  ret
52AC  45DE00F032    L52AC add   REG_32,REG_F0,#$00DE	; TABLE $8CDE Engine speed N normalizing function for FN908A and FN908B, generates table entry point. Input = N and Output = table entry point
52B1  A0AE34              ld    REG_34,REG_AE			; REG_AE = engine RPM * 4
52B4  EF55E3              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
52B7  A038A6              ld    REG_A6,REG_38
52BA  45FA00F032          add   REG_32,REG_F0,#$00FA	; TABLE $8CFA Load Normalizing function; used for table lookup. Input = LOAD and Output = Normalized load
52BF  A374DE34            ld    REG_34,$DE[REG_74]	    ; engine load (VE?)
52C3  EF46E3              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
52C6  A038A8              ld    REG_A8,REG_38
52C9  A0A630              ld    REG_30,REG_A6
52CC  A0A832              ld    REG_32,REG_A8
52CF  AD0A34              ldbze REG_34,#$0A
52D2  450602FA38          add   REG_38,REG_FA,#$0206	; TABLE $99AE - Sea level EGR table. X-input = FN070 - Normalized engine speed, RPM Y-input = FN071 - Normalized load. Output = Percent EGR
52D7  EF10E4              lcall L36EA					; Interpolate two var table R38-Table
52DA  AC3B3C              ldbze REG_3C,REG_3B
52DD  AF748338            ldbze REG_38,$83[REG_74]		; $0201 - MULT_BP212A - ?
52E1  EF6605              lcall L584A
52E4  A03C42              ld    REG_42,REG_3C
52E7  A0A630              ld    REG_30,REG_A6
52EA  A0A832              ld    REG_32,REG_A8
52ED  AD0A34              ldbze REG_34,#$0A
52F0  455602FA38          add   REG_38,REG_FA,#$0256	; TABLE $99FE - Altitude EGR table. X-input = FN070 - Normalized engine speed, RPM Y-input = FN071 - Normalized load.
52F5  EFF2E3              lcall L36EA					; Interpolate two var table R38-Table
52F8  AC3B3C              ldbze REG_3C,REG_3B
52FB  455001FA32          add   REG_32,REG_FA,#$0150	; TABLE $98F8 - EGRALT multiplier as a function of Barometric Pressure BP.
5300  B3748034            ldb   REG_34,$80[REG_74]		; BP - barometric pressure
5304  EFB0E2              lcall L35B7					; Interpolate Single var Table R32-table,R34-in,R38-out
5307  1139                clrb  REG_39
5309  EF3E05              lcall L584A
530C  64423C              add   REG_3C,REG_42
530F  453A01FA            add   REG_32,REG_FA,#$013A	; TABLE $98E2 - Multiplier as a function  of ECT.
      32
5314  B0B034              ldb   REG_34,REG_B0			; Engine Coolant Temperature - degrees F ?
5317  EF97E2              lcall L35B1					; Interpolate Single var Table R32-table,R34-in,R38-out
531A  B0383A              ldb   REG_3A,REG_38
531D  457401FA            add   REG_32,REG_FA,#$0174	; TABLE $991C - Multiplier as a function of Air Charge Temperature ACT.
      32
5322  B0B134              ldb   REG_34,REG_B1			; REG_B1 = ACT (ACT = REG_B1 * 4)
5325  EF84E2              lcall L35AC					; Interpolate Single var Table R32-table,R34-in,R38-out
5328  7C3A38              mulub REG_38,REG_3A
532B  6C3C38              mulu  REG_38,REG_3C
532E  0D0338              shll  REG_38,#$03
5331  1138                clrb  REG_38
5333  B3FA2539            ldb   REG_39,$25[REG_FA]		; ROM $97CD X EGR table multplier. 
5337  6C3A38              mulu  REG_38,REG_3A
533A  B374E639            ldb   REG_39,$E6[REG_74]		; $0264 TSEGRE - Accumulated time EGR is enabled (sec)
533E  1138                clrb  REG_38
5340  9FFA2A38            divub REG_38,$2A[REG_FA]		; ROM $97D2 - EGRMPT - Calibration time delay to ramp EGR in, sec. (EGRATE Ramp time for TCSTRT <or= CTLOW)
5344  DD08                jv    L534E
5346  1139                clrb  REG_39
5348  6C3A38              mulu  REG_38,REG_3A
534B  0D0838              shll  REG_38,#$08
534E  30EC4E        L534E jbc   REG_EC,BIT_00,L539F		; MFAFLG - Managed Fuel Air State flag, set to 1 if MFA is being used.
5351  A03A3C              ld    REG_3C,REG_3A
5354  454601F032          add   REG_32,REG_F0,#$0146	; TABLE $8D46 - RPM normalizing function; generates table entry point. Input = N and Output = Normalized N.
5359  A0AE34              ld    REG_34,REG_AE			; REG_AE = engine RPM * 4
535C  EFADE2              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
535F  A03830              ld    REG_30,REG_38
5362  453201F032          add   REG_32,REG_F0,#$0132	; TABLE $8D32 - Load normalizing function; generates table entry point. Input = LOAD and Output = Normalized Load.
5367  A374DE34            ld    REG_34,$DE[REG_74]	    ; engine load (VE?)
536B  EF9EE2              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
536E  A03832              ld    REG_32,REG_38
5371  AD0434              ldbze REG_34,#$04
5374  45A602FA38          add   REG_38,REG_FA,#$02A6	; TABLE $9A4E - Managed fuel Air EGR Table. X-input = FN083 - Normalized Engine Speed, RPM Y-input = FN082 - Normalized load. Output = Multiplier.
5379  EF6EE3              lcall L36EA					; Interpolate two var table R38-Table
537C  B3748238            ldb   REG_38,$82[REG_74]
5380  7C3B38              mulub REG_38,REG_3B
5383  5F74F439            mulub REG_38,REG_39,$F4[REG_74]
      38
5388  0338                neg   REG_38
538A  65002038            add   REG_38,#$2000
538E  373902              jbc   REG_39,BIT_07,L5393
5391  0138                clr   REG_38
5393  6C3C38        L5393 mulu  REG_38,REG_3C
5396  0D0338              shll  REG_38,#$03
5399  D304                jnc   L539F
539B  A1FFFF3A            ld    REG_3A,#$FFFF
539F  77FA243A      L539F addb  REG_3A,$24[REG_FA]
53A3  B4003B              addcb REG_3B,Zero
53A6  98003B              cmpb  REG_3B,Zero
53A9  DF03                je    L53AE
53AB  B1FF3A              ldb   REG_3A,#$FF
53AE  C772EF3A      L53AE stb   REG_3A,$EF[REG_72]
53B2  3EE663              jbs   REG_E6,BIT_06,L5418
53B5  98003A              cmpb  REG_3A,Zero
53B8  D706                jne   L53C0
53BA  C3749000            st    Zero,$90[REG_74]
53BE  2057                sjmp  L5417
53C0  5DA43A38      L53C0 mulub REG_38,REG_3A,#$A4
53C4  6CA438              mulu  REG_38,REG_A4
53C7  0C0538              shrl  REG_38,#$05
53CA  A03A38              ld    REG_38,REG_3A
53CD  6DBC0338            mulu  REG_38,#$03BC
53D1  AF748034            ldbze REG_34,$80[REG_74]		; BP - barometric pressure
53D5  8C3438              divu  REG_38,REG_34
53D8  DD15                jv    L53EF
53DA  457E01FA            add   REG_32,REG_FA,#$017E	; TABLE $9926
      32
53DF  A03834              ld    REG_34,REG_38
53E2  EF27E2              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
53E5  090838              shl   REG_38,#$08
53E8  4772A838            add   REG_34,REG_38,$A8[REG_72]
      34
53ED  D303                jnc   L53F2
53EF  BDC034        L53EF ldbse REG_34,#$C0
53F2  A372A842      L53F2 ld    REG_42,$A8[REG_72]
53F6  8B749042            cmp   REG_42,$90[REG_74]
53FA  D304                jnc   L5400
53FC  C3749042            st    REG_42,$90[REG_74]

5400  EF51E2        L5400 lcall L3654					; FILTER new AD value 
5403  0E02                word  $020E					; Old AD sensor address - DELOPT
5405  3400                word  $0034					; new AD sensor address
5407  40D0                word  $D040					; funny index for difference filter
5409  8980E63E            cmp   REG_3E,#$E680 			; filtered sensor output
540D  D104                jnh   L5413
540F  A180E63E            ld    REG_3E,#$E680			; clamp value
5413  C374903E      L5413 st    REG_3E,$90[REG_74] 		; filtered sensor output $20E

5417  F0            L5417 ret

5418  7DA43A        L5418 mulub REG_3A,#$A4
541B  A0A438              ld    REG_38,REG_A4
541E  6C3A38              mulu  REG_38,REG_3A
5421  C03C3A              st    REG_3A,REG_3C
5424  99073B              cmpb  REG_3B,#$07
5427  D105                jnh   L542E
5429  BDFF3A              ldbse REG_3A,#$FF
542C  2003                sjmp  L5431
542E  0D0538        L542E shll  REG_38,#$05
5431  C772FE3B      L5431 stb   REG_3B,$FE[REG_72]
5435  A3FA3632            ld    REG_32,$36[REG_FA]
5439  67FA3832            add   REG_32,$38[REG_FA]
543D  88323C              cmp   REG_3C,REG_32
5440  D303                jnc   L5445
5442  9110A1              orb   REG_A1,#$10				; set EGONFLG
5445  8BFA363C      L5445 cmp   REG_3C,$36[REG_FA]
5449  DB03                jc    L544E
544B  71EFA1              andb  REG_A1,#$EF				; clr EGONFLG
544E  382802        L544E jbs   REG_28,BIT_00,L5453
5451  2069                sjmp  L54BC
5453  3CA102        L5453 jbs   REG_A1,BIT_04,L5458		; EGONFLG
5456  2070                sjmp  L54C8
5458  A03A34        L5458 ld    REG_34,REG_3A
545B  45DE01FA            add   REG_32,REG_FA,#$01DE	; TABLE $9986
      32
5460  EFA9E1              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
5463  6D00EF38            mulu  REG_38,#$EF00
5467  B3748037            ldb   REG_37,$80[REG_74]		; BP - barometric pressure
546B  1136                clrb  REG_36
546D  8C3638              divu  REG_38,REG_36
5470  D503                jnv   L5475
5472  BDFF38              ldbse REG_38,#$FF
5475  080238        L5475 shr   REG_38,#$02
5478  080240              shr   REG_40,#$02
547B  48384032            sub   REG_32,REG_40,REG_38
547F  2E12                scall L5293

5481  C03432              st    REG_32,REG_34
5484  A372F432            ld    REG_32,$F4[REG_72]		; old value
5488  A3FA4236            ld    REG_36,$42[REG_FA]
548C  EFDBE1              lcall L366A
548F  C372F43E            st    REG_3E,$F4[REG_72]		; new value

5493  A3FA2E38            ld    REG_38,$2E[REG_FA]
5497  FE6C3E38            mul   REG_38,REG_3E
549B  0D0238              shll  REG_38,#$02
549E  A301EE07            ld    REG_36,$07EE[Zero]		; filtered EVP saved in KAM 
      36
54A3  080136              shr   REG_36,#$01
54A6  64363A              add   REG_3A,REG_36
54A9  D505                jnv   L54B0
54AB  BDFF3A              ldbse REG_3A,#$FF
54AE  2007                sjmp  L54B7
54B0  D602          L54B0 jge   L54B4
54B2  013A                clr   REG_3A
54B4  09013A        L54B4 shl   REG_3A,#$01
54B7  C372FC3A      L54B7 st    REG_3A,$FC[REG_72]
54BB  F0                  ret

54BC  C7740A00      L54BC stb   Zero,$0A[REG_74]		; $0288 EM - EGR Mass Flow
54C0  C772EE00            stb   Zero,$EE[REG_72]
54C4  C772EF00            stb   Zero,$EF[REG_72]
54C8  C772FE00      L54C8 stb   Zero,$FE[REG_72]
54CC  A3728430            ld    REG_30,$84[REG_72]		; $104 - EPTBAR
54D0  C372FC30            st    REG_30,$FC[REG_72]		; $17C - CONPR
54D4  C372F440            st    REG_40,$F4[REG_72]		; $174 - DESDP
54D8  F0                  ret
;
;*****************************************************************
; Cycling Routine at 2151, routine offset $32
; EGR stuff
;*****************************************************************
;
54D9  3EE663        L54D9 jbs   REG_E6,BIT_06,L553F		; PFE HP flag
54DC  8B749000            cmp   Zero,$90[REG_74]		; $20E - DELOPT
54E0  DB52                jc    L5534
54E2  A3FA2830            ld    REG_30,$28[REG_FA]		; ROM $97D0 - EGRDED
54E6  6772A830            add   REG_30,$A8[REG_72]		; $128 - EOFF
54EA  D303                jnc   L54EF
54EC  BDC030              ldbse REG_30,#$C0
54EF  8B72F030      L54EF cmp   REG_30,$F0[REG_72]		; $170 - EVP
54F3  D30C                jnc   L5501
54F5  3F290C              jbs   REG_29,BIT_07,L5504		; jmp if EGRFLG
54F8  A3FA26D2            ld    REG_D2,$26[REG_FA]		; ROM $97CE - DCOFF
54FC  918029              orb   REG_29,#$80				; set EGRFLG
54FF  2003                sjmp  L5504
5501  717F29        L5501 andb  REG_29,#$7F				; clr EGRFLG
5504  A3749034      L5504 ld    REG_34,$90[REG_74]		; $20E - DELOPT
5508  080134              shr   REG_34,#$01
550B  A372F032            ld    REG_32,$F0[REG_72]		; $170 - EVP
550F  080132              shr   REG_32,#$01
5512  683234              sub   REG_34,REG_32
5515  C372F234            st    REG_34,$F2[REG_72]		; $172 - EGRERR
5519  459A01FA32          add   REG_32,REG_FA,#$019A	; Table $9942
551E  EFE5E0              lcall L3606					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
5521  64D238              add   REG_38,REG_D2			; EGRDC
5524  DD08                jv    L552E
5526  DA0C                jle   L5534
5528  89337338            cmp   REG_38,#$7333
552C  D104                jnh   L5532
552E  A1337338      L552E ld    REG_38,#$7333
5532  2005          L5532 sjmp  L5539
5534  0138          L5534 clr   REG_38
5536  717F29              andb  REG_29,#$7F				; clr EGRFLG
5539  A038D2        L5539 ld    REG_D2,REG_38
553C  E74800              ljmp  L5587
553F  9B72FE00      L553F cmpb  Zero,$FE[REG_72]		; $27E - TCF
5543  DF3A                je    L557F
5545  3F2907              jbs   REG_29,BIT_07,L554F		; jmp if EGRFLG
5548  A3FA26D2            ld    REG_D2,$26[REG_FA]		; ROM $97CE - DCOFF
554C  918029              orb   REG_29,#$80
554F  A372FC30      L554F ld    REG_30,$FC[REG_72]		; $27C - NDBAR
5553  080130              shr   REG_30,#$01
5556  A3728434            ld    REG_34,$84[REG_72]		; $104 - EPTBAR
555A  080134              shr   REG_34,#$01
555D  683034              sub   REG_34,REG_30
5560  C372FA34            st    REG_34,$FA[REG_72]		; $17A - PRESER
5564  459A01FA            add   REG_32,REG_FA,#$019A	; TABLE $9942
      32
5569  EF9AE0              lcall L3606					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
556C  64D238              add   REG_38,REG_D2			; EGRDC
556F  DD08                jv    L5579
5571  DA0F                jle   L5582
5573  89337338            cmp   REG_38,#$7333
5577  D10B                jnh   L5584
5579  A1337338      L5579 ld    REG_38,#$7333
557D  2005                sjmp  L5584
557F  717F29        L557F andb  REG_29,#$7F				; clr EGRFLG
5582  0138          L5582 clr   REG_38
5584  C0D238        L5584 st    REG_38,REG_D2			; EGRDC
;
;*****************************************************************
; Cycling Routine at 2151, routine offset $6E    
;                                 Fall thru ???
; Update EGR stuff
;*****************************************************************
;
5587  9800D3        L5587 cmpb  REG_D3,Zero
558A  D70F                jne   L559B
558C  C774A300            stb   Zero,$A3[REG_74]		; $0221 - EGRCNT
5590  C774A400            stb   Zero,$A4[REG_74]		; $0222 - EGRPER
5594  F0                  ret

5595  0A172C              byte  $0A,$17,$2C,$40,$58,$6E
5598  40586E
559B  AD0630        L559B ldzb  REG_30,#$06
559E  9B319455D3    L559E cmpb  REG_D3,$5594[REG_30]
55A3  D903                jh    L55A8
55A5  E030F6              djnz  REG_30,L559E

55A8  090B30        L55A8 shl   REG_30,#$0B
55AB  C774A331            stb   REG_31,$A3[REG_74]		; $0221 - EGRCNT

55AF  1130                clrb  REG_30
55B1  9CD330              divub REG_30,REG_D3
55B4  DD05                jv    L55BB
55B6  99C030              cmpb  REG_30,#$C0
55B9  D103                jnh   L55BE
55BB  B1C030        L55BB ldb   REG_30,#$C0
55BE  C774A430      L55BE stb   REG_30,$A4[REG_74]		; $0222 - EGRPER
55C2  F0                  ret
;
;*****************************************************************
; Cycling Routine at 2151, routine offset $34
; Update spark advance
;*****************************************************************
;
55C3  3FA103        L55C3 jbs   REG_A1,BIT_07,L55C9		; jump if CRANKING
55C6  32A105              jbc   REG_A1,BIT_02,L55CE		; UNDSP = Run/Underspeed Flag.  (1 = Underspeed (or CRANK), 0 = Run)
55C9  B128C2        L55C9 ldb   REG_C2,#$28
55CC  2243                sjmp  L5811
55CE  3A2802        L55CE jbs   REG_28,BIT_02,L55D3
55D1  223E                sjmp  L5811
55D3  45DE00F0      L55D3 add   REG_32,REG_F0,#$00DE	; TABLE $8CDE spark_table_RPM_scaling
      32
55D8  A0AE34              ld    REG_34,REG_AE			; REG_AE = engine RPM * 4
55DB  EF2EE0              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
55DE  A038A6              ld    REG_A6,REG_38
55E1  45FA00F032          add   REG_32,REG_F0,#$00FA	; TABLE $8CFA load_scaling
55E6  A374DE34            ld    REG_34,$DE[REG_74]	 	; engine load (VE?)
55EA  EF1FE0              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
55ED  A038A8              ld    REG_A8,REG_38
55F0  0118                clr   REG_18
55F2  B3743F34            ldb   REG_34,$3F[REG_74]		; $2BD - vehicle speed filtered(1) (MPH) $02BC is 8.8 format
55F6  7FF81834            mulub REG_34,$18[REG_F8]
55FA  A0AE36              ld    REG_36,REG_AE			; REG_AE = engine RPM * 4
55FD  080336              shr   REG_36,#$03
5600  883634              cmp   REG_34,REG_36
5603  DB14                jc    L5619
5605  A0A630              ld    REG_30,REG_A6
5608  A0A832              ld    REG_32,REG_A8
560B  AD0A34              ldbze REG_34,#$0A
560E  459002F8            add   REG_38,REG_F8,#$0290	; TABLE $96C0 - Torque Reduction Table (auto trans protection)
      38
5613  EFD4E0              lcall L36EA					; Interpolate two var table R38-Table
5616  AC3B18              ldbze REG_18,REG_3B
5619  3FD002        L5619 jbs   REG_D0,BIT_07,L561E		; jmp if throttle is not closed
561C  2083                sjmp  L56A1
561E  459000F8      L561E add   REG_32,REG_F8,#$0090	; TABLE $94C0 Closed Throttle Spark advance adder as a function of Engine Coolant Temperature ECT (to generate cold temperature spark advance) Input = ECT, deg F and Output = spark adder.
      32
5623  B0B034              ldb   REG_34,REG_B0			; Engine Coolant Temperature - degrees F ?
5626  EF88DF              lcall L35B1					; Interpolate Single var Table R32-table,R34-in,R38-out
5629  BC3842              ldbse REG_42,REG_38
562C  457C00F8            add   REG_32,REG_F8,#$007C	; TABLE $94AC Closed Throttle Base spark advance as a function of engine speed N. Input = Engine speed, RPM and Output = spark advance, deg BTDC.
      32
5631  A0AE34              ld    REG_34,REG_AE			; REG_AE = engine RPM * 4
5634  EFCFDF              lcall L3606					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
5637  643842              add   REG_42,REG_38
563A  67F80242            add   REG_42,$02[REG_F8]		; ROM $9032 spark_adder_closed_throttle
563E  A3F80638            ld    REG_38,$06[REG_F8]
5642  8838AE              cmp   REG_AE,REG_38			; REG_AE = engine RPM * 4
5645  D103                jnh   L564A
5647  9110ED              orb   REG_ED,#$10
564A  6BF80838      L564A sub   REG_38,$08[REG_F8]
564E  8838AE              cmp   REG_AE,REG_38			; REG_AE = engine RPM * 4
5651  DB03                jc    L5656
5653  71EFED              andb  REG_ED,#$EF
5656  34ED23        L5656 jbc   REG_ED,BIT_04,L567C
5659  453801F8            add   REG_32,REG_F8,#$0138	; TABLE $9568 Time since startup kicker time delay, sec. It's input is TCSTRT and has a maximum repetition of 6.
      32
565E  B0AD34              ldb   REG_34,REG_AD
5661  EF48DF              lcall L35AC					; Interpolate Single var Table R32-table,R34-in,R38-out
5664  9838C8              cmpb  REG_C8,REG_38			; (REG_C8 may be a byte size counter for ATMR1)
5667  DB13                jc    L567C
5669  459E00F8            add   REG_32,REG_F8,#$009E	; TABLE $94CE (BP is input)
      32
566E  B3748034            ldb   REG_34,$80[REG_74]		; BP - barometric pressure
5672  EF3FDF              lcall L35B4					; Interpolate Single var Table R32-table,R34-in,R38-out
5675  1638                extb  REG_38
5677  683842              sub   REG_42,REG_38
567A  2016                sjmp  L5692
567C  322613        L567C jbc   REG_26,BIT_02,L5692
567F  67F81242            add   REG_42,$12[REG_F8]
5683  B372C434            ldb   REG_34,$C4[REG_72]
5687  451E01F8            add   REG_32,REG_F8,#$011E	; TABLE $954E Idle Spark subtractor, deg.
      32
568C  EF28DF              lcall L35B7					; Interpolate Single var Table R32-table,R34-in,R38-out
568F  683842              sub   REG_42,REG_38
5692  4818423C      L5692 sub   REG_3C,REG_42,REG_18
5696  AF72D638            ldbze REG_38,$D6[REG_72]
569A  29AE                scall L584A
569C  A03C42              ld    REG_42,REG_3C
569F  216A                sjmp  L580B
56A1  30D048        L56A1 jbc   REG_D0,BIT_00,L56EC		; jmp if throttle is partly open
56A4  45D400F8            add   REG_32,REG_F8,#$00D4	; TABLE $9504 - WOT spark advance vs RPM
      32
56A9  A0AE34              ld    REG_34,REG_AE			; REG_AE = engine RPM * 4
56AC  EF5DDF              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
56AF  A03842              ld    REG_42,REG_38
56B2  45F800F8            add   REG_32,REG_F8,#$00F8	; TABLE $9528 - Spark Advance vs. BP
      32
56B7  B3748034            ldb   REG_34,$80[REG_74]		; BP - barometric pressure
56BB  EFF6DE              lcall L35B4					; Interpolate Single var Table R32-table,R34-in,R38-out
56BE  1638                extb  REG_38
56C0  643842              add   REG_42,REG_38
56C3  450201F8            add   REG_32,REG_F8,#$0102	; TABLE $9532 - WOT Spark Advance vs ECT
      32
56C8  B0B034              ldb   REG_34,REG_B0			; INPUT: Engine Coolant Temp
56CB  EFE3DE              lcall L35B1					; Interpolate Single var Table R32-table,R34-in,R38-out
56CE  1638                extb  REG_38					; OUTPUT: ECT advance increment
56D0  643842              add   REG_42,REG_38
56D3  451001F8            add   REG_32,REG_F8,#$0110    ; TABLE $9540 - WOT Spark Advance vs ACT
      32
56D8  B0B134              ldb   REG_34,REG_B1			; REG_B1 = ACT (ACT = REG_B1 * 4)
56DB  EFD3DE              lcall L35B1					; Interpolate Single var Table R32-table,R34-in,R38-out
56DE  1638                extb  REG_38
56E0  643842              add   REG_42,REG_38
56E3  67F80A42            add   REG_42,$0A[REG_F8]		; ROM $943A spark_adder_WOT
56E7  681842              sub   REG_42,REG_18
56EA  210D                sjmp  L57F9					; done !!!
56EC  A0A630        L56EC ld    REG_30,REG_A6
56EF  A0A832              ld    REG_32,REG_A8
56F2  AD0A34              ldbze REG_34,#$0A
56F5  459401F8            add   REG_38,REG_F8,#$0194	; TABLE $95C4 - Altitude Base spark (RPM vs LOAD)
      38
56FA  EFEDDF              lcall L36EA					; Interpolate two var table R38-Table
56FD  AC3B3C              ldbze REG_3C,REG_3B
5700  AF748338            ldbze REG_38,$83[REG_74]
5704  2944                scall L584A
5706  A03C42              ld    REG_42,REG_3C
5709  A0A630              ld    REG_30,REG_A6
570C  A0A832              ld    REG_32,REG_A8
570F  AD0A34              ldbze REG_34,#$0A
5712  45E401F8            add   REG_38,REG_F8,#$01E4	; TABLE $9614 - limp mode spark timing table (Deg BTDC)(RPM vs LOAD)
      38
5717  EFD0DF              lcall L36EA					; Interpolate two var table R38-Table
571A  AC3B3C              ldbze REG_3C,REG_3B
571D  45C800F8            add   REG_32,REG_F8,#$00C8	; TABLE $94F8 LOMALT table multiplier as a function of Barometric Pressure, BP.(0 at sea level 1.0 at 'high' altitude
      32
5722  B3748034            ldb   REG_34,$80[REG_74]		; BP - barometric pressure
5726  EF8EDE              lcall L35B7					; Interpolate Single var Table R32-table,R34-in,R38-out
5729  1139                clrb  REG_39
572B  291D                scall L584A
572D  643C42              add   REG_42,REG_3C
5730  A0A630              ld    REG_30,REG_A6
5733  A0A832              ld    REG_32,REG_A8
5736  AD0A34              ldbze REG_34,#$0A
5739  454401F8            add   REG_38,REG_F8,#$0144	; TABLE $9574 - base spark timing table (Deg BTDC)(RPM vs LOAD)
      38
573E  EFA9DF              lcall L36EA					; Interpolate two var table R38-Table
5741  AC3B34              ldbze REG_34,REG_3B
5744  4834423C            sub   REG_3C,REG_42,REG_34
5748  013A                clr   REG_3A
574A  B372C539            ldb   REG_39,$C5[REG_72]
574E  1138                clrb  REG_38
5750  AFF80F36            ldbze REG_36,$0F[REG_F8]		; ROM $943F = LUGTIM = Engine load transition time, sec
5754  8C3638              divu  REG_38,REG_36
5757  080138              shr   REG_38,#$01
575A  28EE                scall L584A
575C  44343C42            add   REG_42,REG_3C,REG_34
5760  A0A630              ld    REG_30,REG_A6
5763  A0A832              ld    REG_32,REG_A8
5766  AD0A34              ldbze REG_34,#$0A
5769  453402F8            add   REG_38,REG_F8,#$0234	; TABLE $9664 Spark advance adder for EGR as a function of RPM and LOAD; X-input = Normalized engine speed on RPM - FN070, Y-input = Normalized LOAD - FN071, Output = Spark advance adder for EGR, deg per 1 percent EGR.
      38
576E  EF79DF              lcall L36EA					; Interpolate two var table R38-Table
5771  AC3B38              ldbze REG_38,REG_3B
5774  7F72EE38            mulub REG_38,$EE[REG_72]
5778  080638              shr   REG_38,#$06
577B  643842              add   REG_42,REG_38
577E  454601F0            add   REG_32,REG_F0,#$0146	; TABLE $8D46 RPM normalizing function; generates table entry point. Input = N and Output = Normalized N.
      32
5783  A0AE34              ld    REG_34,REG_AE			; REG_AE = engine RPM * 4
5786  EF83DE              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
5789  A03830              ld    REG_30,REG_38
578C  453201F0            add   REG_32,REG_F0,#$0132	; TABLE $8D32 Load normalizing function; generates table entry point. Input = LOAD and Output = Normalized Load.
      32
5791  A374DE34            ld    REG_34,$DE[REG_74]	    ; engine load (VE?)
5795  EF74DE              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
5798  A03832              ld    REG_32,REG_38
579B  AD0434              ldbze REG_34,#$04
579E  458402F8            add   REG_38,REG_F8,#$0284	; TABLE $96B4 4 x 3 table of spark adders as a function of engine speed N and LOAD. The (X-input) normalizing function for N is FN083 and the (Y-input) normalizing function for LOAD is FN082.
      38
57A3  EF44DF              lcall L36EA					; Interpolate two var table R38-Table
57A6  BC3B3C              ldbse REG_3C,REG_3B
57A9  AF748238            ldbze REG_38,$82[REG_74]
57AD  289B                scall L584A
57AF  AF74F438            ldbze REG_38,$F4[REG_74]
57B3  2895                scall L584A
57B5  643C42              add   REG_42,REG_3C
57B8  455800F8            add   REG_32,REG_F8,#$0058	; TABLE $9488 ECT normalizing function.
      32
57BD  BCB034              ldbse REG_34,REG_B0			; Engine Coolant Temperature - degrees F ?
57C0  EF3EDE              lcall L3601					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
57C3  A03830              ld    REG_30,REG_38
57C6  A0A832              ld    REG_32,REG_A8
57C9  AD0734              ldbze REG_34,#$07
57CC  45E002F8            add   REG_38,REG_F8,#$02E0	; TABLE $9710 (ECT,LOAD) = Part throttle spark modifier table. X-input = Normalized ECT (FN033) Y-input = Normalized LOAD (FN071).
      38
57D1  EF13DF              lcall L36E7					; Table interpolation routine
57D4  BC3B3A              ldbse REG_3A,REG_3B
57D7  643A42              add   REG_42,REG_3A
57DA  45BE00F8            add   REG_32,REG_F8,#$00BE	;TABLE: $94EE - spark advance vs ACT - pt_advance_vs_act
      32
57DF  B0B134              ldb   REG_34,REG_B1			; REG_B1 = ACT (ACT = REG_B1 * 4)
57E2  EFCCDD              lcall L35B1					; Interpolate Single var Table R32-table,R34-in,R38-out
57E5  1638                extb  REG_38
57E7  4438423C            add   REG_3C,REG_42,REG_38
57EB  68183C              sub   REG_3C,REG_18
57EE  AFF80E38            ldbze REG_38,$0E[REG_F8]
57F2  2856                scall L584A
57F4  47F8043C            add   REG_42,REG_3C,$04[REG_F8]	; ROM $9434 spark_ader_part_throttle
      42
57F9  32E70F        L57F9 jbc   REG_E7,BIT_02,L580B		;join up here for advance
;********************************************************
57FC  456500FA32          add   REG_32,REG_FA,#$0065	; TABLE $980D High Speed Spark retard, mph.
5801  B3743F34            ldb   REG_34,$3F[REG_74]		; $2BD - vehicle speed filtered(1) (MPH) $02BC is 8.8 format
5805  EFAFDD              lcall L35B7					; Interpolate Single var Table R32-table,R34-in,R38-out
5808  683842              sub   REG_42,REG_38			; shift spark
;********************************************************
580B  A042C2        L580B ld    REG_C2,REG_42
580E  71FB28              andb  REG_28,#$FB
5811  9180ED        L5811 orb   REG_ED,#$80
5814  71BFED              andb  REG_ED,#$BF
5817  B372C538            ldb   REG_38,$C5[REG_72]
581B  9BF80F38            cmpb  REG_38,$0F[REG_F8]
581F  D303                jnc   L5824
5821  717FED              andb  REG_ED,#$7F
5824  382422        L5824 jbs   REG_24,BIT_00,L5849		; check WOT flag
5827  45AA00F8            add   REG_32,REG_F8,#$00AA	; TABLE $94DA LOM Load function to activate LOM spark strategy. Input: RPM and Output: load.
      32
582C  A0AE34              ld    REG_34,REG_AE			; REG_AE = engine RPM * 4
582F  EFDADD              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
5832  8B74DE38            cmp   REG_38,$DE[REG_74]	    ; engine load (VE?)
5836  D311                jnc   L5849
5838  B3F81038            ldb   REG_38,$10[REG_F8]
583C  303804              jbc   REG_38,BIT_00,L5843
583F  C772C500            stb   Zero,$C5[REG_72]
5843  717FED        L5843 andb  REG_ED,#$7F
5846  9140ED              orb   REG_ED,#$40
5849  F0            L5849 ret

584A  FE6C383C      L584A mul   REG_3C,REG_38
584E  0E073C              shral REG_3C,#$07
5851  F0                  ret

;
;*****************************************************************
; Cycling Routine at 2151, routine offset 4
; Update Dwell
;*****************************************************************
;
5852  9BF81A00      L5852 cmpb  Zero,$1A[REG_F8]		; ROM $944A - CCDSW - Calibration Switch to select Computer Controlled Dwell. (1 = Computer Controlled Dwell; 0 = TFI Controlled Dwell)
5856  DF57                je    L58AF
5858  B3F82A36            ldb   REG_36,$2A[REG_F8]		; ROM $945A - DWLWF - Weighting factor determining effect of ECT and ACT on Base Dwell, unitless.
585C  EF89EE              lcall L46E8
585F  0A0734              shra  REG_34,#$07
5862  451803F8            add   REG_32,REG_F8,#$0318	; TABLE $9748 - Min low speed dwell(Dwell/Coil off time vs battery voltage)
      32
5867  9BF82B34            cmpb  REG_34,$2B[REG_F8]
586B  DA05                jle   L5872
586D  453003F8            add   REG_32,REG_F8,#$0330	; TABLE $9760 - Min high speed dwell(Dwell/Coil off time vs battery voltage)
      32
5872  AF749334      L5872 ldbze REG_34,$93[REG_74]		; Battery Voltage Level * 16
5876  EF93DD              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
5879  C374C038            st    REG_38,$C0[REG_74]		; $023E - DWLBSE - Base amount of DWELL as a function of VBAT and TEMDWL, sec. Initial value = 0.005.
587D  6D73CB38            mulu  REG_38,#$CB73
5881  C374BC3A            st    REG_3A,$BC[REG_74]		; $023A - DWLBST - 
5885  A374BE38            ld    REG_38,$BE[REG_74]		; $023C - DWELL - 
5889  6D499D38            mulu  REG_38,#$9D49
588D  C374C23A            st    REG_3A,$C2[REG_74]		; $0240 - DWELLMS - 
5891  AFFE0732            ldbze REG_32,$07[REG_FE]		; ROM $9E61 - ENGCYL - Number of cylinders per engine revolution (NUMCYL/2); or number of PIPs per engine revolution
5895  013A                clr   REG_3A
5897  A3F81C38            ld    REG_38,$1C[REG_F8]		; ROM $943C - SPLCLP - Lower limit spark clip for rotor registry.
589B  8C3238              divu  REG_38,REG_32
589E  C374C638            st    REG_38,$C6[REG_74]		; $0244 - PPERENG - 
58A2  013A                clr   REG_3A
58A4  A3F81E38            ld    REG_38,$1E[REG_F8]		; ROM $943E - Y - Normal Part throttle spark multiplier?
58A8  8C3238              divu  REG_38,REG_32
58AB  C374C838            st    REG_38,$C8[REG_74]		; $0246 - POFFENG - 
58AF  F0            L58AF ret

;
;*****************************************************************
; Cycling Routine at 2151, routine offset $42
;
; Idle Speed controls
;
;*****************************************************************
;
58B0  342B01        L58B0 jbc   REG_2B,BIT_04,L58B4		; jmp if not Disable Idle Speed Control
58B3  F0                  ret

58B4  B3F24842      L58B4 ldb   REG_42,$48[REG_F2]		; ROM $8EA2 DAS MPH ($0D)
58B8  57F2494240          addb  REG_40,REG_42,$49[REG_F2]	; ROM $8EA3 DASH HYST (Dashpot hystesis ???) ($04)
58BD  D303                jnc   L58C2				
58BF  B1FF40              ldb   REG_40,#$FF				; clamp value to max of $FF

; REG_40 = $11 defined by ROM
58C2  9B743F40      L58C2 cmpb  REG_40,$3F[REG_74]		; $2BD - vehicle speed filtered(1) (MPH) $02BC is 8.8 format
58C6  D10B                jnh   L58D3					; 17 <= MPH
58C8  9B743F42            cmpb  REG_42,$3F[REG_74]		; $2BD - vehicle speed filtered(1) (MPH) $02BC is 8.8 format
58CC  D308                jnc   L58D6					; 13 < MPH
58CE  71F7E7              andb  REG_E7,#$F7				; clr flag DashMinQ?
58D1  2003                sjmp  L58D6

58D3  9108E7        L58D3 orb   REG_E7,#$08				; set flag DashMinQ?

58D6  37A12F        L58D6 jbc   REG_A1,BIT_07,L5908		; jump if not cranknig
58D9  A372A63A            ld    REG_3A,$A6[REG_72]		; $0126 - RATCH=Closed TP
58DD  C372DA3A            st    REG_3A,$DA[REG_72]		; DSTPBR?
58E1  0114                clr   REG_14
58E3  A372BE3A            ld    REG_3A,$BE[REG_72]		; $013E - timer? time since last PIP recieved
58E7  8900083A            cmp   REG_3A,#$0800			; 8 seconds
58EB  DB0E                jc    L58FB
58ED  458403F432          add   REG_32,REG_F4,#$0384		; TABLE $935A ISC_during_crank (isc duty cycle during crank, keyed off ect at start (ect, duty cycle)
58F2  B0AD34              ldb   REG_34,REG_AD			; REG_AD - TC START
58F5  EFB4DC              lcall L35AC					; Interpolate Single var Table R32-table,R34-in,R38-out
58F8  B03815              ldb   REG_15,REG_38
58FB  C0B814        L58FB st    REG_14,REG_B8			; ISCDTY

58FE  A3FE263A            ld    REG_3A,$26[REG_FE]		; ROM $9E80 IFAM
5902  C372DE3A            st    REG_3A,$DE[REG_72]		; $015E - (FAM) Filtered Air Mass
5906  2012                sjmp  L591A

5908  33C517        L5908 jbc   REG_C5,BIT_03,L5922		; MFMFlag
590B  34C514              jbc   REG_C5,BIT_04,L5922		; TFMFlag
590E  A3F67CB8            ld    REG_B8,$7C[REG_F6]		; ISCDTY - ROM $9AFA FCAMSW
5912  B3F67E42            ldb   REG_42,$7E[REG_F6]		; ROM $9AFC Function
5916  C772E642            stb   REG_42,$E6[REG_72]		; $0166 DSD RPM
591A  B17F3A        L591A ldb   REG_3A,#$7F				; REG_3A bit 7 
591D  C772D63A            stb   REG_3A,$D6[REG_72]		; $0156 SPKMUL
5921  F0                  ret

5922  A3FA3E1C      L5922 ld    REG_1C,$3E[REG_FA]
5926  352A16              jbc   REG_2A,BIT_05,L593F		; jump if normal strategy - not self test mode
5929  A3726E40            ld    REG_40,$6E[REG_72]
592D  6BF47440            sub   REG_40,$74[REG_F4]		; F4 = 8FD6 so $74+$8FD6 = $904A = Idle Speed in neutral (0054H = 84 and 84 * 8 = 672rpm
5931  8BF3900000          cmp   Zero,$0090[REG_F2]		; ROM 
5936  DF77                je    L59AF
5938  A3F390001C          ld    REG_1C,$0090[REG_F2]	; ROM 
593D  2070                sjmp  L59AF

593F  45C401F032    L593F add   REG_32,REG_F0,#$01C4	; TABLE $90C4
5944  B0B034              ldb   REG_34,REG_B0			; Engine Coolant Temperature - degrees F ?
5947  EF62DC              lcall L35AC					; Interpolate Single var Table R32-table,R34-in,R38-out
594A  A03840              ld    REG_40,REG_38
594D  45D401F032          add   REG_32,REG_F0,#$01D4	; TABLE $90D4
5952  B0B134              ldb   REG_34,REG_B1			; REG_B1 = ACT (ACT = REG_B1 * 4)
5955  EF54DC              lcall L35AC					; Interpolate Single var Table R32-table,R34-in,R38-out
5958  643840              add   REG_40,REG_38
595B  32E80F              jbc   REG_E8,BIT_02,L596D
595E  B372C434            ldb   REG_34,$C4[REG_72]
5962  452A01F832          add   REG_32,REG_F8,#$012A	; TABLE $955A
5967  EF4DDC              lcall L35B7					; Interpolate Single var Table R32-table,R34-in,R38-out
596A  643840              add   REG_40,REG_38
596D  9BF59100C8    L596D cmpb  REG_C8,$0091[REG_F4]	; (REG_C8 may be a byte size counter for ATMR1)
5972  DB06                jc    L597A
5974  67F47840            add   REG_40,$78[REG_F4]
5978  2003                sjmp  L597D
597A  3C2F15        L597A jbs   REG_2F,BIT_04,L5992		; PTSCR
597D  9BF59000C8    L597D cmpb  REG_C8,$0090[REG_F4]	; ATMR1 (REG_C8 may be a byte size counter for ATMR1)
5982  DB0E                jc    L5992
5984  45EA02F432          add   REG_32,REG_F4,#$02EA	; TABLE $92C0
5989  B0AD34              ldb   REG_34,REG_AD
598C  EF1DDC              lcall L35AC					; Interpolate Single var Table R32-table,R34-in,R38-out
598F  643840              add   REG_40,REG_38
5992  31E61A        L5992 jbc   REG_E6,BIT_01,L59AF		; jump if heated windshield not on (HWFLAG)
5995  30E617              jbc   REG_E6,BIT_00,L59AF
5998  3E2614              jbs   REG_26,BIT_06,L59AF
599B  A3F00430            ld    REG_30,$04[REG_F0]
599F  6BF47430            sub   REG_30,$74[REG_F4]		; F4 = 8FD6 so $74+$8FD6 = $904A = Idle Speed in neutral (0054H = 84 and 84 * 8 = 672rpm
59A3  DB02                jc    L59A7
59A5  0130                clr   REG_30
59A7  883040        L59A7 cmp   REG_40,REG_30
59AA  DB03                jc    L59AF
59AC  A03040              ld    REG_40,REG_30
59AF  080140        L59AF shr   REG_40,#$01
59B2  980041              cmpb  REG_41,Zero
59B5  DF03                je    L59BA
59B7  ADFF40              ldbze REG_40,#$FF
59BA  B04035        L59BA ldb   REG_35,REG_40
59BD  1134                clrb  REG_34
59BF  8B72E434            cmp   REG_34,$E4[REG_72]		; $0164 - DESNLO
59C3  DB15                jc    L59DA

59C5  A372E432            ld    REG_32,$E4[REG_72]		; OLD AD value - DESNLO
59C9  EF92DC              lcall L365E					; FILTER new AD value (REG_34 is new AD value)
59CC  1C00                word  $001C					; funny index for difference filter(this one NOT in ROM!)
59CE  C372E43E            st    REG_3E,$E4[REG_72] 		; filtered sensor output - DESNLO

59D2  C0403E              st    REG_3E,REG_40
59D5  080740              shr   REG_40,#$07
59D8  2007                sjmp  L59E1

59DA  C372E434      L59DA st    REG_34,$E4[REG_72]
59DE  090140              shl   REG_40,#$01
59E1  918026        L59E1 orb   REG_26,#$80
59E4  880040              cmp   REG_40,Zero
59E7  D703                jne   L59EC
59E9  717F26              andb  REG_26,#$7F
59EC  B372EB14      L59EC ldb   REG_14,$EB[REG_72]
59F0  C772EC14            stb   REG_14,$EC[REG_72]
59F4  013E                clr   REG_3E
59F6  A372DE16            ld    REG_16,$DE[REG_72]		; $015E - (FAM) Filtered Air Mass
59FA  362609              jbc   REG_26,BIT_06,L5A06
59FD  B3FE0230            ldb   REG_30,$02[REG_FE]		; ROM $9E5C
5A01  990330              cmpb  REG_30,#$03				; check if we are in neutral or in gear ( in ROM! = $03 )Maybe this is manual vs automatic
5A04  D909                jh    L5A0F
5A06  91023E        L5A06 orb   REG_3E,#$02
5A09  67F47440            add   REG_40,$74[REG_F4]		; F4 = 8FD6 so $74+$8FD6 = $904A = Idle Speed in neutral (0054H = 84 and 84 * 8 = 672rpm
5A0D  2004                sjmp  L5A13
5A0F  67F47640      L5A0F add   REG_40,$76[REG_F4]		; ROM $904C idle_speed_drive
5A13  3BEA03        L5A13 jbs   REG_EA,BIT_03,L5A19
5A16  32EA03              jbc   REG_EA,BIT_02,L5A1C
5A19  91013E        L5A19 orb   REG_3E,#$01
5A1C  383E0B        L5A1C jbs   REG_3E,BIT_00,L5A2A
5A1F  A3F58C0030          ld    REG_30,$008C[REG_F4]
5A24  8B749830            cmp   REG_30,$98[REG_74]		; $0216 - timer? ACCTMR
5A28  D104                jnh   L5A2E
5A2A  67F47A40      L5A2A add   REG_40,$7A[REG_F4]
5A2E  342712        L5A2E jbc   REG_27,BIT_04,L5A43
5A31  57F6140030          addb  REG_30,Zero,$14[REG_F6]
5A36  DF0B                je    L5A43
5A38  67F58E0040          add   REG_40,$008E[REG_F4]
5A3D  918026              orb   REG_26,#$80
5A40  91013F              orb   REG_3F,#$01
5A43  393E14        L5A43 jbs   REG_3E,BIT_01,L5A5A
5A46  B372CD30            ldb   REG_30,$CD[REG_72]		; ATMR3(byte) - timer? $014D - the since entering 'running' mode
5A4A  9BFA1E30            cmpb  REG_30,$1E[REG_FA]
5A4E  D10A                jnh   L5A5A
5A50  8BF47C40            cmp   REG_40,$7C[REG_F4]
5A54  D104                jnh   L5A5A
5A56  A3F47C40            ld    REG_40,$7C[REG_F4]
5A5A  313E07        L5A5A jbc   REG_3E,BIT_01,L5A64
5A5D  45C603F432          add   REG_32,REG_F4,#$03C6	; TABLE $939C
5A62  2005                sjmp  L5A69

5A64  45BA03F432    L5A64 add   REG_32,REG_F4,#$03BA	; TABLE $9390 - Airflow required for closed throttle operation in drive. Input to this function is absolute DSDRPM
5A69  A04034        L5A69 ld    REG_34,REG_40
5A6C  080134              shr   REG_34,#$01
5A6F  990035              cmpb  REG_35,#$00
5A72  D103                jnh   L5A77
5A74  B1FF34              ldb   REG_34,#$FF
5A77  EF3DDB        L5A77 lcall L35B7					; Interpolate Single var Table R32-table,R34-in,R38-out
5A7A  A03820              ld    REG_20,REG_38
5A7D  457602F432          add   REG_32,REG_F4,#$0276	; TABLE $924C
5A82  B0B034              ldb   REG_34,REG_B0			; Engine Coolant Temperature - degrees F ?
5A85  EF24DB              lcall L35AC					; Interpolate Single var Table R32-table,R34-in,R38-out
5A88  AC3830              ldbze REG_30,REG_38
5A8B  090430              shl   REG_30,#$04
5A8E  457E00FC32          add   REG_32,REG_FC,#$007E	; ROM TABLE $9AFC
5A93  AF72CD34            ldbze REG_34,$CD[REG_72]		; ATMR3(byte) - timer? $014D - the since entering 'running' mode
5A97  EF72DB              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
5A9A  A03832              ld    REG_32,REG_38
5A9D  AD0734              ldbze REG_34,#$07
5AA0  459003F438          add   REG_38,REG_F4,#$0390	; TABLE $9366 - (ECT,ATMR3) = Airflow multiplier  vs. ECT  and  ATMR3
5AA5  EF42DC              lcall L36EA					; Interpolate two var table R38-Table
5AA8  7C3B20              mulub REG_20,REG_3B
5AAB  080220              shr   REG_20,#$02
5AAE  303E05              jbc   REG_3E,BIT_00,L5AB6
5AB1  67F5860020          add   REG_20,$0086[REG_F4]
5AB6  303F05        L5AB6 jbc   REG_3F,BIT_00,L5ABE
5AB9  67F58A0020          add   REG_20,$008A[REG_F4]
5ABE  31140A        L5ABE jbc   REG_14,BIT_01,L5ACB
5AC1  393E14              jbs   REG_3E,BIT_01,L5AD8
5AC4  67F5820016          add   REG_16,$0082[REG_F4]
5AC9  200D                sjmp  L5AD8

5ACB  313E0A        L5ACB jbc   REG_3E,BIT_01,L5AD8
5ACE  6BF5840016          sub   REG_16,$0084[REG_F4]
5AD3  DB03                jc    L5AD8
5AD5  A00016              ld    REG_16,Zero
5AD8  30140F        L5AD8 jbc   REG_14,BIT_00,L5AEA
5ADB  383E14              jbs   REG_3E,BIT_00,L5AF2
5ADE  6BF5880016          sub   REG_16,$0088[REG_F4]
5AE3  DB0D                jc    L5AF2
5AE5  A00016              ld    REG_16,Zero
5AE8  2008                sjmp  L5AF2

5AEA  303E05        L5AEA jbc   REG_3E,BIT_00,L5AF2
5AED  67F5860016          add   REG_16,$0086[REG_F4]
5AF2  303F15        L5AF2 jbc   REG_3F,BIT_00,L5B0A
5AF5  3AEC15              jbs   REG_EC,BIT_02,L5B0D
5AF8  67F58A0016          add   REG_16,$008A[REG_F4]
5AFD  9104EC              orb   REG_EC,#$04
5B00  C372E000            st    Zero,$E0[REG_72]
5B04  C772EA00            stb   Zero,$EA[REG_72]
5B08  2003                sjmp  L5B0D

5B0A  71FBEC        L5B0A andb  REG_EC,#$FB
5B0D  31E60A        L5B0D jbc   REG_E6,BIT_01,L5B1A
5B10  30E607              jbc   REG_E6,BIT_00,L5B1A
5B13  3E2604              jbs   REG_26,BIT_06,L5B1A
5B16  67F60C20            add   REG_20,$0C[REG_F6]
5B1A  C772EB3E      L5B1A stb   REG_3E,$EB[REG_72]
5B1E  C372DE16            st    REG_16,$DE[REG_72]		; $015E - (FAM) Filtered Air Mass
5B22  080140              shr   REG_40,#$01
5B25  980041              cmpb  REG_41,Zero
5B28  DF03                je    L5B2D
5B2A  ADFF40              ldbze REG_40,#$FF
5B2D  C772E640      L5B2D stb   REG_40,$E6[REG_72]
5B31  090640              shl   REG_40,#$06
5B34  A372DA32            ld    REG_32,$DA[REG_72]
5B38  A0AA34              ld    REG_34,REG_AA			; REG_AA is Throttle position
5B3B  A3FA3C36            ld    REG_36,$3C[REG_FA]
5B3F  883234              cmp   REG_34,REG_32
5B42  D904                jh    L5B48
5B44  A3FA3A36            ld    REG_36,$3A[REG_FA]
5B48  EF18DB        L5B48 lcall L3663
5B4B  C372DA3E            st    REG_3E,$DA[REG_72]
5B4F  37D024              jbc   REG_D0,BIT_07,L5B76		; jmp if throttle is not closed
5B52  455403F432          add   REG_32,REG_F4,#$0354	; TABLE $932A - DASHPOT DEC RATE - dashpot_decrement_rate (dashpot decrement step at given flow(Kg/Hr(flow),Kg/Hr(Step))
5B57  A372DC34            ld    REG_34,$DC[REG_72]
5B5B  33E709              jbc   REG_E7,BIT_03,L5B67
5B5E  A3F24A3E            ld    REG_3E,$4A[REG_F2]
5B62  883E34              cmp   REG_34,REG_3E
5B65  D149                jnh   L5BB0
5B67  A0343E        L5B67 ld    REG_3E,REG_34
5B6A  EF9FDA              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
5B6D  68383E              sub   REG_3E,REG_38
5B70  DB3E                jc    L5BB0
5B72  013E                clr   REG_3E
5B74  203A                sjmp  L5BB0
5B76  A3F46042      L5B76 ld    REG_42,$60[REG_F4]
5B7A  6772A642            add   REG_42,$A6[REG_72]		; $0126 - RATCH=Closed TP
5B7E  D303                jnc   L5B83
5B80  BDC042              ldbse REG_42,#$C0
5B83  68423E        L5B83 sub   REG_3E,REG_42
5B86  DB02                jc    L5B8A
5B88  013E                clr   REG_3E
5B8A  A3F45C3C      L5B8A ld    REG_3C,$5C[REG_F4]
5B8E  6C3E3C              mulu  REG_3C,REG_3E
5B91  457003F432          add   REG_32,REG_F4,#$0370	; TABLE $9346 Max Dashpot clip Dashpot clip(lbs/min) vs RPM
5B96  A0AE34              ld    REG_34,REG_AE			; REG_AE = engine RPM * 4
5B99  EF70DA              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
5B9C  99203F              cmpb  REG_3F,#$20
5B9F  DB0C                jc    L5BAD
5BA1  0D023C              shll  REG_3C,#$02
5BA4  67F45E3E            add   REG_3E,$5E[REG_F4]
5BA8  88383E              cmp   REG_3E,REG_38
5BAB  D103                jnh   L5BB0
5BAD  A0383E        L5BAD ld    REG_3E,REG_38
5BB0  C372DC3E      L5BB0 st    REG_3E,$DC[REG_72]
5BB4  C01C3E              st    REG_3E,REG_1C
5BB7  3FD013              jbs   REG_D0,BIT_07,L5BCD		; jmp if throttle is closed
5BBA  C372E2AE            st    REG_AE,$E2[REG_72]		; REG_AE = engine RPM * 4
5BBE  113A                clrb  REG_3A
5BC0  C772C600            stb   Zero,$C6[REG_72]		; zero $0146 timer - ISCTMR
5BC4  B17F3C              ldb   REG_3C,#$7F
5BC7  C772D63C            stb   REG_3C,$D6[REG_72]
5BCB  20A1                sjmp  L5C6E
5BCD  B1013A        L5BCD ldb   REG_3A,#$01
5BD0  352A07              jbc   REG_2A,BIT_05,L5BDA		; jump if normal strategy - not self test mode
5BD3  881C00              cmp   Zero,REG_1C
5BD6  D702                jne   L5BDA
5BD8  2094                sjmp  L5C6E
5BDA  B3FE0216      L5BDA ldb   REG_16,$02[REG_FE]		; ROM $9E5C
5BDE  990316              cmpb  REG_16,#$03
5BE1  D703                jne   L5BE6
5BE3  3E2642              jbs   REG_26,BIT_06,L5C28
5BE6  B3F46630      L5BE6 ldb   REG_30,$66[REG_F4]
5BEA  9B743F30            cmpb  REG_30,$3F[REG_74]		; $2BD - vehicle speed filtered(1) (MPH) $02BC is 8.8 format
5BEE  D338                jnc   L5C28
5BF0  88001C              cmp   REG_1C,Zero
5BF3  D733                jne   L5C28
5BF5  47F4624038          add   REG_38,REG_40,$62[REG_F4]
5BFA  8838AE              cmp   REG_AE,REG_38			; REG_AE = engine RPM * 4
5BFD  D902                jh    L5C01
5BFF  206D                sjmp  L5C6E
5C01  9B72D700      L5C01 cmpb  Zero,$D7[REG_72]
5C05  DE37                jlt   L5C3E
5C07  B372C638            ldb   REG_38,$C6[REG_72]		; $0146 timer - ISCTMR
5C0B  9BF46D38            cmpb  REG_38,$6D[REG_F4]
5C0F  D317                jnc   L5C28
5C11  4B72E2AE38          sub   REG_38,REG_AE,$E2[REG_72] ; REG_AE = engine RPM * 4
5C16  DB02                jc    L5C1A
5C18  0338                neg   REG_38
5C1A  8BF46438      L5C1A cmp   REG_38,$64[REG_F4]
5C1E  D11E                jnh   L5C3E
5C20  C372E2AE            st    REG_AE,$E2[REG_72]		; REG_AE = engine RPM * 4
5C24  C772C600            stb   Zero,$C6[REG_72]
		; zero $0146 timer?
5C28  A01C34        L5C28 ld    REG_34,REG_1C
5C2B  080634              shr   REG_34,#$06
5C2E  45F802F432          add   REG_32,REG_F4,#$02F8	; TABLE $92CE
5C33  EF81D9              lcall L35B7					; Interpolate Single var Table R32-table,R34-in,R38-out
5C36  C772D638            stb   REG_38,$D6[REG_72]
5C3A  133A                negb  REG_3A
5C3C  2030                sjmp  L5C6E
5C3E  990316        L5C3E cmpb  REG_16,#$03
5C41  D303                jnc   L5C46
5C43  362625              jbc   REG_26,BIT_06,L5C6B
5C46  AFF46E38      L5C46 ldbze REG_38,$6E[REG_F4]
5C4A  33EA09              jbc   REG_EA,BIT_03,L5C56
5C4D  77F46F38            addb  REG_38,$6F[REG_F4]
5C51  D303                jnc   L5C56
5C53  ADFF38              ldbze REG_38,#$FF
5C56  090638        L5C56 shl   REG_38,#$06
5C59  8B74DE38            cmp   REG_38,$DE[REG_74]	   	; engine load (VE?)
5C5D  D30C                jnc   L5C6B
5C5F  C372E2AE            st    REG_AE,$E2[REG_72]		; REG_AE = engine RPM * 4
5C63  C772C600            stb   Zero,$C6[REG_72]		; zero $0146 timer - ISCTMR
5C67  133A                negb  REG_3A
5C69  2003                sjmp  L5C6E
5C6B  B1023A        L5C6B ldb   REG_3A,#$02
5C6E  C772D73A      L5C6E stb   REG_3A,$D7[REG_72]
5C72  AF72EB32            ldbze REG_32,$EB[REG_72]
5C76  A372D438            ld    REG_38,$D4[REG_72]
5C7A  0A0138              shra  REG_38,#$01
5C7D  08011C              shr   REG_1C,#$01
5C80  3FE906              jbs   REG_E9,BIT_07,L5C89
5C83  9B72EC32            cmpb  REG_32,$EC[REG_72]
5C87  DF13                je    L5C9C
5C89  C372E000      L5C89 st    Zero,$E0[REG_72]
5C8D  C772EA00            stb   Zero,$EA[REG_72]
5C91  880038              cmp   REG_38,Zero
5C94  D606                jge   L5C9C
5C96  0138                clr   REG_38
5C98  C372D438            st    REG_38,$D4[REG_72]
5C9C  090132        L5C9C shl   REG_32,#$01
5C9F  013C                clr   REG_3C
5CA1  3F2808              jbs   REG_28,BIT_07,L5CAC
5CA4  A333E4073C          ld    REG_3C,$07E4[REG_32]
5CA9  0A013C              shra  REG_3C,#$01
5CAC  641C20        L5CAC add   REG_20,REG_1C
5CAF  643820              add   REG_20,REG_38
5CB2  643C20              add   REG_20,REG_3C
5CB5  A0203E              ld    REG_3E,REG_20
5CB8  D602                jge   L5CBC
5CBA  013E                clr   REG_3E
5CBC  090120        L5CBC shl   REG_20,#$01
5CBF  C372D820            st    REG_20,$D8[REG_72]
5CC3  09013E              shl   REG_3E,#$01
5CC6  B372D71E            ldb   REG_1E,$D7[REG_72]
5CCA  A372E01C            ld    REG_1C,$E0[REG_72]
5CCE  45B002F432          add   REG_32,REG_F4,#$02B0	; TABLE $9286
5CD3  A0AE34              ld    REG_34,REG_AE			; REG_AE = engine RPM * 4
5CD6  EF33D9              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
5CD9  64383E              add   REG_3E,REG_38
5CDC  D303                jnc   L5CE1
5CDE  BDFF3E              ldbse REG_3E,#$FF
5CE1  6BF4583E      L5CE1 sub   REG_3E,$58[REG_F4]		; ROM
5CE5  DB02                jc    L5CE9
5CE7  013E                clr   REG_3E
5CE9  98001E        L5CE9 cmpb  REG_1E,Zero
5CEC  DA3B                jle   L5D29
5CEE  071C                inc   REG_1C
5CF0  D302                jnc   L5CF4
5CF2  051C                dec   REG_1C
5CF4  C372E01C      L5CF4 st    REG_1C,$E0[REG_72]
5CF8  1116                clrb  REG_16
5CFA  48AE4014            sub   REG_14,REG_40,REG_AE	; REG_AE = engine RPM * 4
5CFE  DB02                jc    L5D02
5D00  1716                incb  REG_16
5D02  3E2607        L5D02 jbs   REG_26,BIT_06,L5D0C
5D05  451C03F4            add   REG_32,REG_F4,#$031C	; TABLE $92F2 = FN841N = Spark Multiplier vs. RPM Error (idle)
      32
5D0A  2005                sjmp  L5D11
5D0C  450003F4      L5D0C add   REG_32,REG_F4,#$0300	; TABLE $92D6 = FN841D = Spark Multiplier vs. RPM Error (drive)
      32
5D11  A01434        L5D11 ld    REG_34,REG_14
5D14  EFEAD8              lcall L3601					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
5D17  C772D638            stb   REG_38,$D6[REG_72]
5D1B  A01434              ld    REG_34,REG_14
5D1E  301602              jbc   REG_16,BIT_00,L5D23
5D21  0314                neg   REG_14
5D23  8BF46814      L5D23 cmp   REG_14,$68[REG_F4]		; ROM 
5D27  D902                jh    L5D2B
5D29  20C6          L5D29 sjmp  L5DF1
5D2B  C772C600      L5D2B stb   Zero,$C6[REG_72]		; zero $0146 timer? ISC timer
5D2F  A3FE4438            ld    REG_38,$44[REG_FE]		; ROM 
5D33  3D2A08              jbs   REG_2A,BIT_05,L5D3E		; jump if running self tests
5D36  453803F432          add   REG_32,REG_F4,#$0338	; TABLE $930E FN860
5D3B  EFC3D8              lcall L3601					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
5D3E  88381C        L5D3E cmp   REG_1C,REG_38
5D41  DB02                jc    L5D45
5D43  20AC                sjmp  L5DF1
5D45  011C          L5D45 clr   REG_1C
5D47  C372E01C            st    REG_1C,$E0[REG_72]
5D4B  3D2A14              jbs   REG_2A,BIT_05,L5D62		; jump if running self tests
5D4E  89707DB8            cmp   REG_B8,#$7D70
5D52  D30E                jnc   L5D62
5D54  4BF4624032          sub   REG_32,REG_40,$62[REG_F4]
5D59  D107                jnh   L5D62
5D5B  88AE32              cmp   REG_32,REG_AE			; REG_AE = engine RPM * 4
5D5E  D102                jnh   L5D62
5D60  208F                sjmp  L5DF1
5D62  352A06        L5D62 jbc   REG_2A,BIT_05,L5D6B		; jump if normal strategy - not self test mode
5D65  A1004038            ld    REG_38,#$4000
5D69  200F                sjmp  L5D7A
5D6B  B3742134      L5D6B ldb   REG_34,$21[REG_74]		; $029F - N byte
5D6F  45DC02F432          add   REG_32,REG_F4,#$02DC	; TABLE $92B2
5D74  EF40D8              lcall L35B7					; Interpolate Single var Table R32-table,R34-in,R38-out
5D77  090838              shl   REG_38,#$08
5D7A  6C1438        L5D7A mulu  REG_38,REG_14
5D7D  352A0D              jbc   REG_2A,BIT_05,L5D8D		; jump if normal strategy - not self test mode
5D80  A3FE4038            ld    REG_38,$40[REG_FE]
5D84  381621              jbs   REG_16,BIT_00,L5DA8
5D87  A3FE4238            ld    REG_38,$42[REG_FE]		; ROM 
5D8B  201B                sjmp  L5DA8
5D8D  3E260D        L5D8D jbs   REG_26,BIT_06,L5D9D
5D90  A3F44E38            ld    REG_38,$4E[REG_F4]		; ROM 
5D94  381611              jbs   REG_16,BIT_00,L5DA8
5D97  A3F44C38            ld    REG_38,$4C[REG_F4]
5D9B  200B                sjmp  L5DA8
5D9D  A3F45238      L5D9D ld    REG_38,$52[REG_F4]		; ROM 
5DA1  381604              jbs   REG_16,BIT_00,L5DA8
5DA4  A3F45038            ld    REG_38,$50[REG_F4]		; ROM 
5DA8  6C3A38        L5DA8 mulu  REG_38,REG_3A
5DAB  99023B              cmpb  REG_3B,#$02
5DAE  D306                jnc   L5DB6
5DB0  A1FF7F3A            ld    REG_3A,#$7FFF
5DB4  2003                sjmp  L5DB9
5DB6  0D0638        L5DB6 shll  REG_38,#$06
5DB9  A3F45434      L5DB9 ld    REG_34,$54[REG_F4]		; ROM 
5DBD  A3F45636            ld    REG_36,$56[REG_F4]		; ROM 
5DC1  352A08              jbc   REG_2A,BIT_05,L5DCC		; jump if normal strategy - not self test mode
5DC4  A3FE3C34            ld    REG_34,$3C[REG_FE]
5DC8  A3FE3E36            ld    REG_36,$3E[REG_FE]
5DCC  301602        L5DCC jbc   REG_16,BIT_00,L5DD1
5DCF  033A                neg   REG_3A
5DD1  6772D43A      L5DD1 add   REG_3A,$D4[REG_72]
5DD5  D504                jnv   L5DDB
5DD7  D609                jge   L5DE2
5DD9  200F                sjmp  L5DEA
5DDB  DE08          L5DDB jlt   L5DE5
5DDD  88343A              cmp   REG_3A,REG_34
5DE0  DA0B                jle   L5DED
5DE2  A0343A        L5DE2 ld    REG_3A,REG_34
5DE5  88363A        L5DE5 cmp   REG_3A,REG_36
5DE8  D603                jge   L5DED
5DEA  A0363A        L5DEA ld    REG_3A,REG_36
5DED  C372D43A      L5DED st    REG_3A,$D4[REG_72]

5DF1  A03E32        L5DF1 ld    REG_32,REG_3E
5DF4  4DEF003E34          mulu  REG_34,REG_3E,#$00EF
5DF9  AF74803E            ldbze REG_3E,$80[REG_74]		; BP - barometric pressure
5DFD  8C3E34              divu  REG_34,REG_3E
5E00  8BF45A34            cmp   REG_34,$5A[REG_F4]		; ROM $9030 - DEBYCP ?
5E04  DB04                jc    L5E0A
5E06  A3F45A34            ld    REG_34,$5A[REG_F4]		; ROM $9030 - DEBYCP ?
5E0A  8BF45A32      L5E0A cmp   REG_32,$5A[REG_F4]		; ROM $9030 - DEBYCP ?
5E0E  DB04                jc    L5E14
5E10  A3F45A32            ld    REG_32,$5A[REG_F4]		; ROM $9030 - DEBYCP ?
5E14  C374E432      L5E14 st    REG_32,$E4[REG_74]
5E18  458002F432          add   REG_32,REG_F4,#$0280	; TABLE $9256
5E1D  EFECD7              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
5E20  A03840              ld    REG_40,REG_38
5E23  AFFE4638            ldbze REG_38,$46[REG_FE]
5E27  3D2A0C              jbs   REG_2A,BIT_05,L5E36		; jump if running self tests
5E2A  A374DE34            ld    REG_34,$DE[REG_74]	    ; engine load (VE?)
5E2E  45C402F4            add   REG_32,REG_F4,#$02C4	; TABLE $929A Crank Pulse Width Multiplier vs time in crank mode
      32
5E33  EFD6D7              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
5E36  090838        L5E36 shl   REG_38,#$08
5E39  6C4038              mulu  REG_38,REG_40
5E3C  0D0138              shll  REG_38,#$01
5E3F  DB06                jc    L5E47
5E41  8900803A            cmp   REG_3A,#$8000
5E45  D104                jnh   L5E4B
5E47  A100803A      L5E47 ld    REG_3A,#$8000
5E4B  C0B83A        L5E4B st    REG_3A,REG_B8
5E4E  99011E              cmpb  REG_1E,#$01
5E51  D770                jne   L5EC3					; return
5E53  B372C638            ldb   REG_38,$C6[REG_72]		; $0146 timer - ISCTMR
5E57  9BF47038            cmpb  REG_38,$70[REG_F4]
5E5B  D366                jnc   L5EC3					; return
5E5D  3F2663              jbs   REG_26,BIT_07,L5EC3		; return
5E60  A372D43C            ld    REG_3C,$D4[REG_72]
5E64  88003C              cmp   REG_3C,Zero
5E67  DF5A                je    L5EC3					; return
5E69  3F2857              jbs   REG_28,BIT_07,L5EC3		; return

5E6C  AF72EB32            ldbze REG_32,$EB[REG_72]		; $016B - ISFlag - index of some sort???
5E70  090132              shl   REG_32,#$01				; index to word offset
5E73  A333E40738          ld    REG_38,$07E4[REG_32]
5E78  AFF4713A            ldbze REG_3A,$71[REG_F4]		; ROM $9047 - UPDATM
5E7C  883A1C              cmp   REG_1C,REG_3A
5E7F  D342                jnc   L5EC3					; return
5E81  C372E000            st    Zero,$E0[REG_72]		; $0160 - IBGPSI
5E85  A301EC07            ld    REG_34,$07EC[Zero]		; KAM table 2 checksum
      34
5E8A  88003C              cmp   REG_3C,Zero
5E8D  D214                jgt   L5EA3
5E8F  8BF45638            cmp   REG_38,$56[REG_F4]		; ROM $902C - PSIBRN
5E93  DA2E                jle   L5EC3					; return
5E95  0538                dec   REG_38
5E97  0534                dec   REG_34					; CkSum
5E99  8BF4543C            cmp   REG_3C,$54[REG_F4]		; ROM $902A - PSIBR M
5E9D  D616                jge   L5EB5
5E9F  073C                inc   REG_3C
5EA1  2012                sjmp  L5EB5

5EA3  8BF45438      L5EA3 cmp   REG_38,$54[REG_F4]		; ROM $902A - PSIBR M
5EA7  D61A                jge   L5EC3					; return
5EA9  0738                inc   REG_38
5EAB  0734                inc   REG_34					; CkSum
5EAD  8BF4563C            cmp   REG_3C,$56[REG_F4]		; ROM $902C - PSIBRN
5EB1  DA02                jle   L5EB5
5EB3  053C                dec   REG_3C

5EB5  C333E407      L5EB5 st    REG_38,$07E4[REG_32]	; ISCKAMOL
      38
5EBA  C372D43C            st    REG_3C,$D4[REG_72]		; $0154 IPSIBR
5EBE  C301EC07            st    REG_34,$07EC[Zero]		; KAM table 2 checksum ISKSUM
      34
5EC3  F0            L5EC3 ret
;
;*****************************************************************
; Cycling Routine at 2151, routine offset $44
; SCCS stuff checks VBAT
;*****************************************************************
;
5EC4  B10230        L5EC4 ldb   REG_30,#$02
5EC7  9BF24730            cmpb  REG_30,$47[REG_F2]	; ROM $8EA0 SCCS Frequency - Desired VSC Frequency, Hz
5ECB  D70A                jne   L5ED7
5ECD  B3749330            ldb   REG_30,$93[REG_74]	; $0211 Battery Voltage Level * 16
5ED1  9BF24530            cmpb  REG_30,$45[REG_F2]	; ROM $8E9E = $26(38)HLDRNG - Error deadband for no pulses required.
5ED5  D907                jh    L5EDE				; jmp battery voltage > ROM limit

; Battery voltage insufficient
5ED7  B180B5        L5ED7 ldb   REG_B5,#$80			; SCCS force OFF BUTTON only
5EDA  11A0                clrb  REG_A0				; SCCS state clear all
5EDC  2002                sjmp  L5EE0

; Battery voltage is OK
5EDE  2807          L5EDE scall L5EE7				; Update Vehicle Speed Control(VSC)SCCS

5EE0  288F          L5EE0 scall L5F71
5EE2  29A3                scall L6087
5EE4  29E9                scall L60CF
5EE6  F0                  ret
;
;*****************************************************************
; Cycling Routine at 2151, routine offset $6A
; set VSC bits in REG_B5 & REG_A0 based on ABS voltage **CHANGE** on AD channel 4 (SCCS)
; Read Cruise control buttons (SCCS)
; Update Vehicle Speed Control(VSC)
;*****************************************************************
;
5EE7  A3729838      L5EE7 ld    REG_38,$98[REG_72]	; AD channel 4 $0118 Cruise control buttons - Vehicle Speed Control Command Switch
5EEB  4B7632383A          sub   REG_3A,REG_38,$32[REG_76]	; difference to old value of buttons
5EF0  DB02                jc    L5EF4
5EF2  033A                neg   REG_3A				; ABS difference

5EF4  8BF2123A      L5EF4 cmp   REG_3A,$12[REG_F2]	; ROM $8E6C - Minimum change in IVSCCS to reset the debounce timer
5EF8  D10C                jnh   L5F06
5EFA  C3763238            st    REG_38,$32[REG_76] 	; $03AC IVSCCS_LST - Previous valid SCCS input

5EFE  A3F2303A            ld    REG_3A,$30[REG_F2]	; ROM $8E8A - DEBTIM - Debounce time delay, seconds
5F02  C3742A3A            st    REG_3A,$2A[REG_74]	; $02A8 timer? DEBOUNCE timer

5F06  8B742A00      L5F06 cmp   Zero,$2A[REG_74]	; zero $02A8 timer? DEBOUNCE timer

5F0A  D704                jne   L5F10
5F0C  C3743638            st    REG_38,$36[REG_74]	; $02B4 save value ?Vehicle Speed Control Command Switch; input, debounced counts

5F10  A3743638      L5F10 ld    REG_38,$36[REG_74]
5F14  7102B5              andb  REG_B5,#$02			; check for SCCS error			
5F17  8BF21438            cmp   REG_38,$14[REG_F2]	; ROM $8E6E - HI_OFF - Input VSC command Switch input range, counts
5F1B  DB04                jc    L5F21
5F1D  9180B5              orb   REG_B5,#$80			; set REG_B5 bit 7 OFF BUTTON
5F20  F0                  ret

5F21  8BF21638      L5F21 cmp   REG_38,$16[REG_F2]	; ROM $8E70 - LOW_ON - Input VSCCS input range, counts.
5F25  D104                jnh   L5F2B
5F27  9180A0              orb   REG_A0,#$80			; set REG_A0 bit 7 ON STATE
5F2A  F0                  ret

5F2B  8BF21838      L5F2B cmp   REG_38,$18[REG_F2]	; ROM $8E72 - LCOAST - Input VSCCS input range, counts.
5F2F  D10A                jnh   L5F3B
5F31  8BF21A38            cmp   REG_38,$1A[REG_F2]	; ROM $8E74 - HCOAST - Input VSCCS input range, counts.
5F35  DB04                jc    L5F3B
5F37  9120B5              orb   REG_B5,#$20			; set REG_B5 bit 5 COAST BUTTON
5F3A  F0                  ret

5F3B  8BF21C38      L5F3B cmp   REG_38,$1C[REG_F2]	; ROM $8E76 - LACCEL - Input VSCCS input range, counts.
5F3F  D10A                jnh   L5F4B
5F41  8BF21E38            cmp   REG_38,$1E[REG_F2]	; ROM $8E78 - HACCEL - Input VSCCS input range, counts.
5F45  DB04                jc    L5F4B
5F47  9110B5              orb   REG_B5,#$10			; set REG_B5 bit 4 ACCELORATE BUTTON
5F4A  F0                  ret

5F4B  8BF22038      L5F4B cmp   REG_38,$20[REG_F2]	; ROM $8E7A - LRESUM - Input VSCCS input range, counts.
5F4F  D10A                jnh   L5F5B
5F51  8BF22238            cmp   REG_38,$22[REG_F2]	; ROM $8E7C - HRESUM - Input VSCCS input range, counts.
5F55  DB04                jc    L5F5B
5F57  9108B5              orb   REG_B5,#$08			; set REG_B5 bit 3 RESUME BUTTON
5F5A  F0                  ret

5F5B  8BF22438      L5F5B cmp   REG_38,$24[REG_F2]	; ROM $8E7E - LOHOLD - Input VSCCS input range, counts.
5F5F  D109                jnh   L5F6A
5F61  8BF22638            cmp   REG_38,$26[REG_F2]	; ROM $8E80 - HIHOLD - Input VSCCS input range, counts.
5F65  DB03                jc    L5F6A
5F67  11B5                clrb  REG_B5				; clr all bits in REG_B5
5F69  F0                  ret

5F6A  9102B5        L5F6A orb   REG_B5,#$02			; set REG_B5 bit 1 button voltage range error
5F6D  717FA0              andb  REG_A0,#$7F			; clr REG_A0 bit 7 clr ON state
5F70  F0                  ret
;
;****************************************************************
;
5F71  302A0A        L5F71 jbc   REG_2A,BIT_00,L5F7E		; jump if not VIP_mode_flag : VSCDT

5F74  A0AE3C              ld    REG_3C,REG_AE			; REG_AE = engine RPM * 4
5F77  09023C              shl   REG_3C,#$02			; x4
5F7A  C3742E3C            st    REG_3C,$2E[REG_74]		; SCCS vehicle speed in MPH filtered 2

5F7E  A3742E3C      L5F7E ld    REG_3C,$2E[REG_74]		; SCCS vehicle speed in MPH filtered 2
5F82  37A003              jbc   REG_A0,BIT_07,L5F88		; SCCS on state
5F85  37B507              jbc   REG_B5,BIT_07,L5F8F		; SCCS OFF buttob
5F88  11A0          L5F88 clrb  REG_A0
5F8A  C3743000            st    Zero,$30[REG_74]
5F8E  F0                  ret

5F8F  382A50        L5F8F jbs   REG_2A,BIT_00,L5FE2		; jump if VIP_mode_flag : VSCDT
5F92  A3F23238            ld    REG_38,$32[REG_F2]
5F96  88383C              cmp   REG_3C,REG_38
5F99  DB03                jc    L5F9E
5F9B  9120C4              orb   REG_C4,#$20
5F9E  67F23A38      L5F9E add   REG_38,$3A[REG_F2]
5FA2  DB08                jc    L5FAC
5FA4  88383C              cmp   REG_3C,REG_38
5FA7  D103                jnh   L5FAC
5FA9  71DFC4              andb  REG_C4,#$DF
5FAC  31B503        L5FAC jbc   REG_B5,BIT_01,L5FB2		; SCCS Button voltage range error
5FAF  9120C4              orb   REG_C4,#$20
5FB2  A3F23638      L5FB2 ld    REG_38,$36[REG_F2]
5FB6  88AE38              cmp   REG_38,REG_AE			; REG_AE = engine RPM * 4
5FB9  DB03                jc    L5FBE
5FBB  9120C4              orb   REG_C4,#$20
5FBE  3DC41D        L5FBE jbs   REG_C4,BIT_05,L5FDE
5FC1  A3F23438            ld    REG_38,$34[REG_F2]
5FC5  88383C              cmp   REG_3C,REG_38
5FC8  D103                jnh   L5FCD
5FCA  9110C4              orb   REG_C4,#$10
5FCD  6BF23A38      L5FCD sub   REG_38,$3A[REG_F2]
5FD1  D308                jnc   L5FDB
5FD3  88383C              cmp   REG_3C,REG_38
5FD6  DB03                jc    L5FDB
5FD8  71EFC4              andb  REG_C4,#$EF
5FDB  34C407        L5FDB jbc   REG_C4,BIT_04,L5FE5
5FDE  71A0A0        L5FDE andb  REG_A0,#$A0
5FE1  F0                  ret

5FE2  31EA19        L5FE2 jbc   REG_EA,BIT_01,L5FFE		; BIFLG =  If equal to 1, Brake is on.
5FE5  39EA09        L5FE5 jbs   REG_EA,BIT_01,L5FF1		; BIFLG =  If equal to 1, Brake is on.

5FE8  3FE713              jbs   REG_E7,BIT_07,L5FFE
5FEB  9BFE0200            cmpb  Zero,$02[REG_FE]		; ROM $9E5C
5FEF  DF0D                je    L5FFE
5FF1  B1A0A0        L5FF1 ldb   REG_A0,#$A0
5FF4  5138B500            andb  Zero,REG_B5,#$38		; ck SCCS buttons: RESUME, COAST, ACCELL
5FF8  DF03                je    L5FFD
5FFA  9102B5              orb   REG_B5,#$02				; set SCCS button Range error
5FFD  F0            L5FFD ret

5FFE  35B505        L5FFE jbc   REG_B5,BIT_05,L6006		; SCCS COAST button
6001  B1C0A0              ldb   REG_A0,#$C0
6004  2006                sjmp  L600C
6006  36A00C        L6006 jbc   REG_A0,BIT_06,L6015
6009  B185A0              ldb   REG_A0,#$85
600C  C374323C      L600C st    REG_3C,$32[REG_74]
6010  C374303C            st    REG_3C,$30[REG_74]
6014  F0                  ret

6015  34B50C        L6015 jbc   REG_B5,BIT_04,L6024		; SCCS ACCEL button
6018  3CA004              jbs   REG_A0,BIT_04,L601F
601B  C374323C            st    REG_3C,$32[REG_74]
601F  B191A0        L601F ldb   REG_A0,#$91
6022  200A                sjmp  L602E
6024  34A00C        L6024 jbc   REG_A0,BIT_04,L6033
6027  B185A0              ldb   REG_A0,#$85
602A  C374323C            st    REG_3C,$32[REG_74]
602E  C374303C      L602E st    REG_3C,$30[REG_74]
6032  F0                  ret

6033  3BA01B        L6033 jbs   REG_A0,BIT_03,L6051
6036  3DD910              jbs   REG_D9,BIT_05,L6049
6039  33B515              jbc   REG_B5,BIT_03,L6051		; SCCS RESUME button
603C  35A012              jbc   REG_A0,BIT_05,L6051
603F  A3743038            ld    REG_38,$30[REG_74]
6043  8BF23238            cmp   REG_38,$32[REG_F2]
6047  D108                jnh   L6051
6049  B189A0        L6049 ldb   REG_A0,#$89
604C  C374323C            st    REG_3C,$32[REG_74]
6050  F0                  ret

6051  33A00A        L6051 jbc   REG_A0,BIT_03,L605E
6054  8B74303C            cmp   REG_3C,$30[REG_74]
6058  DB04                jc    L605E
605A  B18BA0              ldb   REG_A0,#$8B
605D  F0                  ret

605E  33A00C        L605E jbc   REG_A0,BIT_03,L606D
6061  B185A0              ldb   REG_A0,#$85
6064  A3743038            ld    REG_38,$30[REG_74]
6068  C3743238            st    REG_38,$32[REG_74]
606C  F0                  ret

606D  32A016        L606D jbc   REG_A0,BIT_02,L6086
6070  A3743238            ld    REG_38,$32[REG_74]
6074  683C38              sub   REG_38,REG_3C
6077  D306                jnc   L607F
6079  8BF23838            cmp   REG_38,$38[REG_F2]
607D  D904                jh    L6083
607F  9101A0        L607F orb   REG_A0,#$01
6082  F0                  ret

6083  B1A0A0        L6083 ldb   REG_A0,#$A0
6086  F0            L6086 ret

6087  3CB503        L6087 jbs   REG_B5,BIT_04,L608D		; SCCS ACCEL button
608A  31A03D              jbc   REG_A0,BIT_01,L60CA
608D  4BF23C3C      L608D sub   REG_32,REG_3C,$3C[REG_F2]
      32
6092  DB03                jc    L6097
6094  A00032              ld    REG_32,Zero
6097  8B743232      L6097 cmp   REG_32,$32[REG_74]
609B  D106                jnh   L60A3
609D  C374323C            st    REG_3C,$32[REG_74]
60A1  2027                sjmp  L60CA
60A3  4B742C06      L60A3 sub   REG_38,Master_IO_Timer_Lo,$2C[REG_74]
      38
60A8  302A07              jbc   REG_2A,BIT_00,L60B2		; jump if not VIP_mode_flag : VSCDT
60AB  A3F36401            ld    REG_30,$0164[REG_F2]
      30
60B0  2004                sjmp  L60B6
60B2  A3F23E30      L60B2 ld    REG_30,$3E[REG_F2]
60B6  6D442838      L60B6 mulu  REG_38,#$2844
60BA  6C3A30              mulu  REG_30,REG_3A
60BD  67743232            add   REG_32,$32[REG_74]
60C1  D303                jnc   L60C6
60C3  BDFF32              ldbse REG_32,#$FF
60C6  C3743232      L60C6 st    REG_32,$32[REG_74]
60CA  C3742C06      L60CA st    Master_IO_Timer_Lo,$2C[REG_74]
60CE  F0                  ret

60CF  302A1D        L60CF jbc   REG_2A,BIT_00,L60EF		; jump if not VIP_mode_flag : VSCDT
60D2  3DD904              jbs   REG_D9,BIT_05,L60D9
60D5  B1FF9B              ldb   REG_9B,#$FF
60D8  F0                  ret

60D9  A3F35A01      L60D9 ld    REG_14,$015A[REG_F2]
      14
60DE  A3F35C01            ld    REG_18,$015C[REG_F2]
      18
60E3  A3F35E01            ld    REG_38,$015E[REG_F2]
      38
60E8  A3F37001            ld    REG_42,$0170[REG_F2]
      42
60ED  2010                sjmp  L60FF
60EF  A3F22A14      L60EF ld    REG_14,$2A[REG_F2]
60F3  A3F22C18            ld    REG_18,$2C[REG_F2]
60F7  A3F22E38            ld    REG_38,$2E[REG_F2]
60FB  A3F22842            ld    REG_42,$28[REG_F2]
60FF  30A021        L60FF jbc   REG_A0,BIT_00,L6123
6102  6F743214            mulu  REG_14,$32[REG_74]
6106  644216              add   REG_16,REG_42
6109  6F742E18            mulu  REG_18,$2E[REG_74]		; SCCS vehicle speed in MPH filtered 2
610D  681A16              sub   REG_16,REG_1A
6110  D311                jnc   L6123
6112  4B72A6AA            sub   REG_18,REG_AA,$A6[REG_72]		; REG_AA is Throttle position, $0126 - RATCH=Closed TP
      18
6117  DB02                jc    L611B
6119  0118                clr   REG_18
611B  6C3818        L611B mulu  REG_18,REG_38
611E  681A16              sub   REG_16,REG_1A
6121  DB02                jc    L6125
6123  0116          L6123 clr   REG_16
6125  A01614        L6125 ld    REG_14,REG_16
6128  080116              shr   REG_16,#$01
612B  C3743816            st    REG_16,$38[REG_74]
612F  1116                clrb  REG_16
6131  6BF24014            sub   REG_14,$40[REG_F2]
6135  D904                jh    L613B
6137  0314                neg   REG_14
6139  1716                incb  REG_16
613B  89800014      L613B cmp   REG_14,#$0080
613F  D103                jnh   L6144
6141  B18014              ldb   REG_14,#$80
6144  9BF24414      L6144 cmpb  REG_14,$44[REG_F2]
6148  D902                jh    L614C
614A  1114                clrb  REG_14
614C  C7743C14      L614C stb   REG_14,$3C[REG_74]		; set $02BB - timer?
6150  A1D00738            ld    REG_38,#$07D0
6154  9FF24638            divub REG_38,$46[REG_F2]
6158  5C381418            mulub REG_18,REG_14,REG_38
615C  65800018            add   REG_18,#$0080
6160  303802              jbc   REG_38,BIT_00,L6165
6163  1738                incb  REG_38
6165  180138        L6165 shrb  REG_38,#$01
6168  FA                  di
6169  FF                  nop
616A  301605              jbc   REG_16,BIT_00,L6172
616D  3EC405              jbs   REG_C4,BIT_06,L6175
6170  2012                sjmp  L6184
6172  3EC40F        L6172 jbs   REG_C4,BIT_06,L6184
6175  9540C4        L6175 xorb  REG_C4,#$40
6178  71FE46              andb  REG_46,#$FE			; LSO output line 0 OFF (Speed Control Vacuum)
617B  911046              orb   REG_46,#$10			; LSO output line 4 ON (Speed Control Vent)
617E  71F7C4              andb  REG_C4,#$F7
6181  B1019B              ldb   REG_9B,#$01
6184  C7743B19      L6184 stb   REG_19,$3B[REG_74]
6188  781938              subb  REG_38,REG_19
618B  C7743A38            stb   REG_38,$3A[REG_74]
618F  FB                  ei
6190  F0                  ret
;
;*****************************************************************
; Cycling Routine at 2151, routine offset $3A
;*****************************************************************
;
6191  B3F61738            ldb   REG_38,$17[REG_F6]
6195  B3F61639            ldb   REG_39,$16[REG_F6]
6199  9838B0              cmpb  REG_B0,REG_38			; Engine Coolant Temperature - degrees F ?
619C  DA0A                jle   L61A8
619E  9839B1              cmpb  REG_B1,REG_39			; REG_B1 = ACT (ACT = REG_B1 * 4)
61A1  DA05                jle   L61A8
61A3  910829              orb   REG_29,#$08
61A6  201F                sjmp  L61C7
61A8  7BF61838      L61A8 subb  REG_38,$18[REG_F6]
61AC  D503                jnv   L61B1
61AE  B18038              ldb   REG_38,#$80
61B1  9838B0        L61B1 cmpb  REG_B0,REG_38			; Engine Coolant Temperature - degrees F ?
61B4  DE0E                jlt   L61C4
61B6  7BF61839            subb  REG_39,$18[REG_F6]
61BA  D503                jnv   L61BF
61BC  B18039              ldb   REG_39,#$80
61BF  9839B1        L61BF cmpb  REG_B1,REG_39			; REG_B1 = ACT (ACT = REG_B1 * 4)
61C2  D603                jge   L61C7
61C4  71F729        L61C4 andb  REG_29,#$F7
61C7  918025        L61C7 orb   REG_25,#$80
61CA  3B291F              jbs   REG_29,BIT_03,L61EC
61CD  31ED11              jbc   REG_ED,BIT_01,L61E1
61D0  B3FE1630            ldb   REG_30,$16[REG_FE]		; ROM $9E70 number_of_HEGOs
61D4  990130              cmpb  REG_30,#$01
61D7  DF13                je    L61EC
61D9  990230              cmpb  REG_30,#$02
61DC  D703                jne   L61E1
61DE  38ED0B              jbs   REG_ED,BIT_00,L61EC
61E1  9901D0        L61E1 cmpb  REG_D0,#$01				; is throttle is wide open?
61E4  D709                jne   L61EF
61E6  9BF615CB            cmpb  REG_CB,$15[REG_F6]		; timer?
61EA  D303                jnc   L61EF
61EC  717F25        L61EC andb  REG_25,#$7F
61EF  B3FE0B30      L61EF ldb   REG_30,$0B[REG_FE]		; ROM $9E65 thermactor_present_switch = 1.0
61F3  990130              cmpb  REG_30,#$01
61F6  DF0C                je    L6204
61F8  914025        L61F8 orb   REG_25,#$40
61FB  3F2503              jbs   REG_25,BIT_07,L6201
61FE  71BF25              andb  REG_25,#$BF
6201  E7B000        L6201 ljmp  L62B4
6204  717FCA        L6204 andb  REG_CA,#$7F
6207  51B8C530            andb  REG_30,REG_C5,#$B8		; clr bits 6, 2, 1, 0
620B  DF08                je    L6215
620D  71EF47              andb  REG_47,#$EF				; REG_47 bit 4 OFF (Air Management 2)
6210  71F747              andb  REG_47,#$F7				; REG_47 bit 3 OFF (Air Management 1)
6213  27E3                sjmp  L61F8
6215  A3F62C38      L6215 ld    REG_38,$2C[REG_F6]
6219  4BF62E38            sub   REG_3A,REG_38,$2E[REG_F6]
      3A
621E  DB02                jc    L6222
6220  013A                clr   REG_3A
6222  8B74DE3A      L6222 cmp   REG_3A,$DE[REG_74]	    ; engine load (VE?)
6226  D105                jnh   L622D
6228  910229              orb   REG_29,#$02
622B  2009                sjmp  L6236
622D  8B74DE38      L622D cmp   REG_38,$DE[REG_74]	    ; engine load (VE?)
6231  DB03                jc    L6236
6233  71FD29              andb  REG_29,#$FD
6236  3FA110        L6236 jbs   REG_A1,BIT_07,L6249		; jump if CRANKING
6239  37250D              jbc   REG_25,BIT_07,L6249
623C  450E00F6            add   REG_30,REG_F6,#$000E	; $93B6
      30
6241  EF0BD5              lcall L374F
6244  DB03                jc    L6249
6246  32E70B              jbc   REG_E7,BIT_02,L6254
6249  71BF25        L6249 andb  REG_25,#$BF
624C  71EF47        L624C andb  REG_47,#$EF				; REG_47 bit 4 OFF (Air Management 2)
624F  71F747              andb  REG_47,#$F7				; REG_47 bit 3 OFF (Air Management 1)
6252  2060                sjmp  L62B4
6254  452600F6      L6254 add   REG_30,REG_F6,#$0026	; $93CE
      30
6259  EFF3D4              lcall L374F
625C  DB4A                jc    L62A8
625E  9BF61FC8            cmpb  REG_C8,$1F[REG_F6]		; (REG_C8 may be a byte size counter for ATMR1)
6262  D90B                jh    L626F
6264  9901D0              cmpb  REG_D0,#$01				; is throttle wide open?
6267  D706                jne   L626F
6269  9BF62BCB            cmpb  REG_CB,$2B[REG_F6]		; timer?
626D  D339                jnc   L62A8
626F  33EB0A        L626F jbc   REG_EB,BIT_03,L627C
6272  B372B838            ldb   REG_38,$B8[REG_72]		; $0138 timer?
6276  9BF61E38            cmpb  REG_38,$1E[REG_F6]
627A  DB2C                jc    L62A8
627C  32EB10        L627C jbc   REG_EB,BIT_02,L628F
627F  B372B738            ldb   REG_38,$B7[REG_72]		; $0137 timer?
6283  9BF62038            cmpb  REG_38,$20[REG_F6]
6287  D906                jh    L628F
6289  9BF61FC8            cmpb  REG_C8,$1F[REG_F6]		; (REG_C8 may be a byte size counter for ATMR1)
628D  D119                jnh   L62A8
628F  914025        L628F orb   REG_25,#$40
6292  9BF637CE            cmpb  REG_CE,$37[REG_F6]		; REG_CE timer? 
6296  D9B4                jh    L624C
6298  392908              jbs   REG_29,BIT_01,L62A3
629B  9BF630CD            cmpb  REG_CD,$30[REG_F6]		; timer?
629F  D102                jnh   L62A3
62A1  27A9                sjmp  L624C
62A3  71EF47        L62A3 andb  REG_47,#$EF				; REG_47 bit 4 OFF (Air Management 2)
62A6  2009                sjmp  L62B1
62A8  9180CA        L62A8 orb   REG_CA,#$80
62AB  71BF25              andb  REG_25,#$BF
62AE  911047              orb   REG_47,#$10				; REG_47 bit 4 ON (Air Management 2)
62B1  910847        L62B1 orb   REG_47,#$08				; REG_47 bit 3 ON (Air Management 1)
62B4  F0            L62B4 ret
;
;*****************************************************************
; Cycling Routine at 2151, routine offset $3C
;*****************************************************************
;
62B5  9BF63900      L62B5 cmpb  Zero,$39[REG_F6]		; ROM $93E1 - ECADHP
62B9  DF79                je    L6334					; return if h/w not present
62BB  9BF63AB0            cmpb  REG_B0,$3A[REG_F6]		; Engine Coolant Temperature - degrees F ? : ROM $93E2 - ECADECT
62BF  D605                jge   L62C6
62C1  9140CA              orb   REG_CA,#$40				; set ECADQ1
62C4  2009                sjmp  L62CF

62C6  9BF63DB0      L62C6 cmpb  REG_B0,$3D[REG_F6]		; Engine Coolant Temperature - degrees F ? : ROM $93E5 - EDETHYS
62CA  DA03                jle   L62CF
62CC  71BFCA              andb  REG_CA,#$BF				; clr ECADQ1

62CF  B3742142      L62CF ldb   REG_42,$21[REG_74]		; $29F - N_BYTE
62D3  9BF63B42            cmpb  REG_42,$3B[REG_F6]		; ROM $93E3 - ECADN
62D7  D105                jnh   L62DE
62D9  9120CA              orb   REG_CA,#$20				; set ECADQ2
62DC  2009                sjmp  L62E7

62DE  9BF63E42      L62DE cmpb  REG_42,$3E[REG_F6]		; ROM $93E6 - EDNHYS
62E2  DB03                jc    L62E7
62E4  71DFCA              andb  REG_CA,#$DF				; clr ECADQ2
62E7  B3743F30      L62E7 ldb   REG_30,$3F[REG_74]		; $2BD - vehicle speed filtered(1) (MPH) $02BC is 8.8 format
62EB  9BF63C30            cmpb  REG_30,$3C[REG_F6]		; ROM $93E4 - ECADVS
62EF  D105                jnh   L62F6
62F1  9110CA              orb   REG_CA,#$10				; set ECADQ3
62F4  2009                sjmp  L62FF

62F6  9BF63F30      L62F6 cmpb  REG_30,$3F[REG_F6]		; ROM $93E7 - EDVSHYS
62FA  DB03                jc    L62FF
62FC  71EFCA              andb  REG_CA,#$EF				; clr ECADQ3
62FF  51B8C542      L62FF andb  REG_42,REG_C5,#$B8
6303  D72C                jne   L6331
6305  B3FE0B42            ldb   REG_42,$0B[REG_FE]		; ROM $9E65 thermactor_present_switch = 1.0
6309  990142              cmpb  REG_42,#$01
630C  D703                jne   L6311					; jmp if no Thermactor present
630E  37CA0F              jbc   REG_CA,BIT_07,L6320		; jmp if not USAFLG
6311  454000F6      L6311 add   REG_30,REG_F6,#$0040	; ROM $93E8 - EDTM3
      30
6316  EF36D4              lcall L374F
6319  D316                jnc   L6331
631B  984200              cmpb  Zero,REG_42
631E  D711                jne   L6331
6320  32DF0E        L6320 jbc   REG_DF,BIT_02,L6331		; jmp if not ECADI
6323  36CA0B              jbc   REG_CA,BIT_06,L6331		; jmp if not ECADQ1
6326  35CA08              jbc   REG_CA,BIT_05,L6331		; jmp if not ECADQ2
6329  34CA05              jbc   REG_CA,BIT_04,L6331		; jmp if not ECADQ3
632C  71BF47              andb  REG_47,#$BF				; REG_47 bit 6 OFF (Fan)HI_FAN
632F  2003                sjmp  L6334

6331  914047        L6331 orb   REG_47,#$40				; REG_47 bit 6 ON (Fan)HI_FAN
6334  F0            L6334 ret
;
;*****************************************************************
; Cycling Routine at 2151, routine offset $3E
; Update Canister Purge timing
;*****************************************************************
;
6335  B3F64514      L6335 ldb   REG_14,$45[REG_F6]
6339  9814B0              cmpb  REG_B0,REG_14			; Engine Coolant Temperature - degrees F ?
633C  DA03                jle   L6341
633E  71F7ED              andb  REG_ED,#$F7
6341  7BF64614      L6341 subb  REG_14,$46[REG_F6]
6345  9814B0              cmpb  REG_B0,REG_14			; Engine Coolant Temperature - degrees F ?
6348  D603                jge   L634D
634A  9108ED              orb   REG_ED,#$08
634D  71BFE9        L634D andb  REG_E9,#$BF
6350  454E00F6            add   REG_30,REG_F6,#$004E	; $93F6 - Canister purge hot startup delay time.
      30
6355  EFF7D3              lcall L374F
6358  D302                jnc   L635C
635A  2059                sjmp  L63B5
635C  33ED56        L635C jbc   REG_ED,BIT_03,L63B5
635F  9BF648CD            cmpb  REG_CD,$48[REG_F6]		; timer?
6363  D350                jnc   L63B5
6365  32EE06              jbc   REG_EE,BIT_02,L636E
6368  9BF64700            cmpb  Zero,$47[REG_F6]
636C  DF47                je    L63B5
636E  45CA02FA      L636E add   REG_32,REG_FA,#$02CA	; TABLE $9A72 - Canister Purge Duty Cycle vs. AM, X-input = AM, Y-output = Purge Duty Cycle.
      32
6373  A0A234              ld    REG_34,REG_A2			; REG_A2 = AM = Air mass flow for the engine (lb/min)
6376  090134              shl   REG_34,#$01
6379  D303                jnc   L637E
637B  B1FF35              ldb   REG_35,#$FF
637E  B03534        L637E ldb   REG_34,REG_35
6381  EF33D2              lcall L35B7					; Interpolate Single var Table R32-table,R34-in,R38-out
6384  983800              cmpb  Zero,REG_38
6387  DF2C                je    L63B5
6389  B03840              ldb   REG_40,REG_38
638C  45B202FA            add   REG_32,REG_FA,#$02B2	; TABLE $9A5A - Canister Purge Duty Cycle Multiplier, X-input = PRGTMR. Y-output = Duty Cycle Multiplier.
      32
6391  B372C934            ldb   REG_34,$C9[REG_72]		; $0149 - timer Canister Purge Timer - cannister purge accumulation time in seconds
6395  EF1FD2              lcall L35B7					; Interpolate Single var Table R32-table,R34-in,R38-out
6398  7C3840              mulub REG_40,REG_38
639B  090140              shl   REG_40,#$01
639E  45BE02FA            add   REG_32,REG_FA,#$02BE	; TABLE $9A66 - Canister Purge Duty Cycle Multiplier, X-input = CPRGTMR, Y-output = Duty Cycle Multiplier.
      32
63A3  B372CA34            ldb   REG_34,$CA[REG_72]		; $014A - timer?
63A7  EF0DD2              lcall L35B7					; Interpolate Single var Table R32-table,R34-in,R38-out
63AA  7C4138              mulub REG_38,REG_41
63AD  080738              shr   REG_38,#$07
63B0  9140EF              orb   REG_EF,#$40
63B3  2009                sjmp  L63BE
63B5  1138          L63B5 clrb  REG_38
63B7  71BFEF              andb  REG_EF,#$BF
63BA  C772CA00            stb   Zero,$CA[REG_72]		; zero $014A - timer - Current Purge on time.
63BE  C772AC38      L63BE stb   REG_38,$AC[REG_72]
63C2  980038              cmpb  REG_38,Zero
63C5  DF03                je    L63CA
63C7  9140E9              orb   REG_E9,#$40
;
;*****************************************************************
; Cycling Routine at 2151, routine offset $70				Fall thru???
; Update Canister Purge
;*****************************************************************
;
63CA  B1A338        L63CA ldb   REG_38,#$A3
63CD  C772AE38            stb   REG_38,$AE[REG_72]		; $012E - PURGE_PERIOD
63D1  7F72AC38            mulub REG_38,$AC[REG_72]		; $012C - PURGDC - Canister Purge Duty Cycle.
63D5  090138              shl   REG_38,#$01
63D8  C772AD39            stb   REG_39,$AD[REG_72]		; $012D - PURG_ON_TIME
63DC  F0                  ret
;
;*****************************************************************
; Cycling Routine at 2151, routine offset $16
; Update A/C cutout and idle slowdown flag
;*****************************************************************
;
63DD  B3F65A42      L63DD ldb   REG_42,$5A[REG_F6]
63E1  98B042              cmpb  REG_42,REG_B0			; Engine Coolant Temperature - degrees F ?
63E4  D605                jge   L63EB
63E6  9140EB              orb   REG_EB,#$40
63E9  2026                sjmp  L6411
63EB  7BF65B42      L63EB subb  REG_42,$5B[REG_F6]
63EF  98B042              cmpb  REG_42,REG_B0			; Engine Coolant Temperature - degrees F ?
63F2  DA03                jle   L63F7
63F4  71BFEB              andb  REG_EB,#$BF
63F7  A3F65C42      L63F7 ld    REG_42,$5C[REG_F6]
63FB  88AE42              cmp   REG_42,REG_AE			; REG_AE = engine RPM * 4
63FE  D105                jnh   L6405
6400  9120EB              orb   REG_EB,#$20
6403  200C                sjmp  L6411
6405  67F65E42      L6405 add   REG_42,$5E[REG_F6]
6409  88AE42              cmp   REG_42,REG_AE			; REG_AE = engine RPM * 4
640C  DB03                jc    L6411
640E  71DFEB              andb  REG_EB,#$DF
6411  37EE3A        L6411 jbc   REG_EE,BIT_07,L644E		; jmp if A/C is off
6414  3EEB03              jbs   REG_EB,BIT_06,L641A
6417  35EB02              jbc   REG_EB,BIT_05,L641C
641A  2025          L641A sjmp  L6441
641C  9BF653C8      L641C cmpb  REG_C8,$53[REG_F6]		; (REG_C8 may be a byte size counter for ATMR1)
6420  DB02                jc    L6424
6422  201D                sjmp  L6441
6424  B3F65442      L6424 ldb   REG_42,$54[REG_F6]
6428  31EA08              jbc   REG_EA,BIT_01,L6433		; BIFLG =  If equal to 1, Brake is on.
642B  9B749542            cmpb  REG_42,$95[REG_74]		; $0213 - A/C Clutch Brake Timer (sec)
642F  D102                jnh   L6433
6431  200E                sjmp  L6441
6433  B3F65542      L6433 ldb   REG_42,$55[REG_F6]
6437  9B749742            cmpb  REG_42,$97[REG_74]		; $0215 - A/C Clutch WOT Cutout Timer (sec)
643B  D102                jnh   L643F
643D  2002                sjmp  L6441
643F  2018          L643F sjmp  L6459
6441  A3F66442      L6441 ld    REG_42,$64[REG_F6]
6445  33EA06              jbc   REG_EA,BIT_03,L644E
6448  8B749842            cmp   REG_42,$98[REG_74]		; $0216 - A/C CLUTCH TRANSITION TIMER 
644C  D90B                jh    L6459
644E  914046        L644E orb   REG_46,#$40				; LSO output line 6 setting bit turns ON relay which turns AC OFF!
6451  71F7EA              andb  REG_EA,#$F7
6454  71FBEA              andb  REG_EA,#$FB
6457  2032                sjmp  L648B
6459  A3F60A42      L6459 ld    REG_42,$0A[REG_F6]
645D  8B762E42            cmp   REG_42,$2E[REG_76]		; $03A8 timer?
6461  DB28                jc    L648B
6463  A3F65642            ld    REG_42,$56[REG_F6]
6467  8B749842            cmp   REG_42,$98[REG_74]		; $0216 - A/C CLUTCH TRANSITION TIMER 
646B  D91E                jh    L648B
646D  37D00A              jbc   REG_D0,BIT_07,L647A		; jmp if throttle is not closed
6470  A3F65842            ld    REG_42,$58[REG_F6]
6474  8B749A42            cmp   REG_42,$9A[REG_74]		; $0218 - A/C CLUTCH TURN-ON DELAY TIMER (msec resolution)
6478  D90B                jh    L6485
647A  71BF46        L647A andb  REG_46,#$BF				; LSO output line 6 clearing bit turns OFF relay which turns AC ON!
647D  9108EA              orb   REG_EA,#$08
6480  71FBEA              andb  REG_EA,#$FB
6483  2006                sjmp  L648B
6485  3BEA03        L6485 jbs   REG_EA,BIT_03,L648B		; jmp if ACCFLG
6488  9104EA              orb   REG_EA,#$04				; set ACIFLG - A/C engagement impending flag:1=A/C about to engage - adjust airflow and fuel immediately
648B  F0            L648B ret
;
;*****************************************************************
; Cycling Routine at 2151, routine offset $38
; update ect cooling fans
;*****************************************************************
;
648C  9BF67400            cmpb  Zero,$74[REG_F6]		; ROM $941C Calibration:fan_control_enable
6490  D701                jne   L6493
6492  F0                  ret

6493  37A102        L6493 jbc   REG_A1,BIT_07,L6498		; jump if not CRANKING
6496  20C1                sjmp  L6559

6498  71DFE9        L6498 andb  REG_E9,#$DF				; bit 5 OFF not at high speed?
649B  9BF677B0            cmpb  REG_B0,$77[REG_F6]		; ECT - degrees F Hi limit: ROM $941F (242DegF)
649F  D624                jge   L64C5					; jmp if we're hotter
64A1  9BF676B0            cmpb  REG_B0,$76[REG_F6]		; ECT - degrees F Lo limit: ROM $941E (234DegF)
64A5  DE21                jlt   L64C8					; jmp if we're colder

64A7  B3742142            ldb   REG_42,$21[REG_74]		; $012F = byte size RPM(N)
64AB  9BF67842            cmpb  REG_42,$78[REG_F6]		; ROM $9420 = min RPM for Grade Load High Speed Fan
64AF  D317                jnc   L64C8					; jmp if RPM too low
64B1  A374DE42            ld    REG_42,$DE[REG_74]	    ; engine load (VE)
64B5  8BF67A42            cmp   REG_42,$7A[REG_F6]		; ROM $9422 = min  LOAD for Grade Load High Speed Fan
64B9  D30D                jnc   L64C8					; jmp if too little load
64BB  B3743F42            ldb   REG_42,$3F[REG_74]		; $2BD - filtered vehicle speed filtered (MPH) $02BC is 8.8 format
64BF  9BF67942            cmpb  REG_42,$79[REG_F6]		; ROM $9421 = max filtered vehicle speed for Grade Load High Speed Fan
64C3  D903                jh    L64C8					; jmp if speed too high
64C5  9120E9        L64C5 orb   REG_E9,#$20				; bit 5 - set at high_Speed_fan_flag

64C8  35E90D        L64C8 jbc   REG_E9,BIT_05,L64D8		; bit 5 - check at high_Speed_fan_flag
64CB  B3F67140            ldb   REG_40,$71[REG_F6]		; ROM $9419 = min low speed fan time to turn on high speed fan in secs
64CF  9B72CE40            cmpb  REG_40,$CE[REG_72]		; $014E timer = Electro-Drive fan (sec)
64D3  D903                jh    L64D8
64D5  9108E9              orb   REG_E9,#$08				; REG_E9 bit 3 ON - hysteresis, engine is above fan on temp?
64D8  B3F67642      L64D8 ldb   REG_42,$76[REG_F6]		; ROM $941E fan_high_speed_temp_1(234DegF)
64DC  7BF66D42            subb  REG_42,$6D[REG_F6]		; ROM $9415 = hysteresis control, deg F
64E0  98B042              cmpb  REG_42,REG_B0			; Engine Coolant Temperature - degrees F ?
64E3  DA03                jle   L64E8
64E5  71F7E9              andb  REG_E9,#$F7				; REG_E9 bit 3 OFF - hysteresis, engine is above fan on temp?
64E8  9BF66CB0      L64E8 cmpb  REG_B0,$6C[REG_F6]		; Engine Coolant Temperature - degrees F ? : ROM $9414 fan_low_speed_temp (220DegF)
64EC  DA03                jle   L64F1
64EE  9104E9              orb   REG_E9,#$04				; REG_E9 bit 3 ON hysteresis, engine is above fan on temp?
64F1  B3F66C42      L64F1 ldb   REG_42,$6C[REG_F6]		; ROM $9414 fan_low_speed_temp (220DegF)
64F5  7BF66E42            subb  REG_42,$6E[REG_F6]		; ROM $9416 = hysteresis control, deg F
64F9  98B042              cmpb  REG_42,REG_B0			; Engine Coolant Temperature - degrees F ?
64FC  DA03                jle   L6501
64FE  71FBE9              andb  REG_E9,#$FB				; REG_E9 bit 2 OFF something with ECT hysteresis?
6501  33E909        L6501 jbc   REG_E9,BIT_03,L650D		; bit 3 hysteresis, engine is above fan on temp?
6504  B3F67540            ldb   REG_40,$75[REG_F6]		; ROM $941D fan_high_speed_enable
6508  990140              cmpb  REG_40,#$01
650B  DF44                je    L6551
650D  B3F66F42      L650D ldb   REG_42,$6F[REG_F6]		; ROM $9417 = fan cooling not needed under this vehicle speed, MPH
6511  7BF67042            subb  REG_42,$70[REG_F6]		; ROM $9418 = hysteresis for fan
6515  9B743F42            cmpb  REG_42,$3F[REG_74]		; $2BD - vehicle speed filtered(1) (MPH) $02BC is 8.8 format
6519  D105                jnh   L6520
651B  33EA02              jbc   REG_EA,BIT_03,L6520		; check is AC compressor ON
651E  2006                sjmp  L6526
6520  3AE903        L6520 jbs   REG_E9,BIT_02,L6526		; REG_E9 bit 2 - something with ECT hysteresis?
6523  37C504              jbc   REG_C5,BIT_07,L652A		; ECT sensor with range test?
6526  719F47        L6526 andb  REG_47,#$9F				; REG_47 bits 5 and 6 OFF (Fans?)
6529  F0                  ret

652A  3BEA0C        L652A jbs   REG_EA,BIT_03,L6539		; check is AC compressor ON
652D  A3F67240            ld    REG_40,$72[REG_F6]		; ROM $941A = sec the AC must be off to start fan
6531  8B749840            cmp   REG_40,$98[REG_74]		; $0216 - timer = AC clutch on time?
6535  D902                jh    L6539
6537  2014                sjmp  L654D
6539  B3F65540      L6539 ldb   REG_40,$55[REG_F6]		; ROM $93FD = delay for AC after WOT in 1/8 sec units
653D  9B749740            cmpb  REG_40,$97[REG_74]		; $0215 timer = time sinc in WOT mode
6541  D90A                jh    L654D
6543  B3F66F40            ldb   REG_40,$6F[REG_F6]		; ROM $9417 = fan cooling not needed under this vehicle speed, MPH
6547  9B743F40            cmpb  REG_40,$3F[REG_74]		; $2BD - vehicle speed filtered(1) (MPH) $02BC is 8.8 format
654B  DB02                jc    L654F
654D  2010          L654D sjmp  L655F
654F  2007          L654F sjmp  L6558
6551  71DF47        L6551 andb  REG_47,#$DF				; REG_47 bit 5 OFF (BiDir control REG Fan A OFF)
6554  914047              orb   REG_47,#$40				; REG_47 bit 6 ON (BiDir control REG Fan B ON)
6557  F0                  ret

6558  F0            L6558 ret

6559  71F7E9        L6559 andb  REG_E9,#$F7				; REG_E9 bit 3 OFF hysteresis, engine is above fan on temp?
655C  71FBE9              andb  REG_E9,#$FB				; REG_E9 bit 2 OFF something with ECT hysteresis?
655F  912047        L655F orb   REG_47,#$20				; REG_47 bit 5 ON (BiDir control REG Fan A ON)
6562  71BF47              andb  REG_47,#$BF				; REG_47 bit 6 OFF (BiDir control REG Fan B OFF)
6565  F0                  ret
;
;*****************************************************************
; Cycling Routine at 2151, routine offset $40
;*****************************************************************
;
6566  B3FE0B30            ldb   REG_30,$0B[REG_FE]		; ROM $9E65 thermactor_present_switch = 1.0
656A  990230              cmpb  REG_30,#$02
656D  D731                jne   L65A0
656F  3CC52B              jbs   REG_C5,BIT_04,L659D
6572  3FA128              jbs   REG_A1,BIT_07,L659D		; jump if CRANKING
6575  3AA125              jbs   REG_A1,BIT_02,L659D		; UNDSP = Run/Underspeed Flag.  (1 = Underspeed (or CRANK), 0 = Run)
6578  A3F20A30            ld    REG_30,$0A[REG_F2]
657C  6772A630            add   REG_30,$A6[REG_72]		; $0126 - RATCH=Closed TP
6580  D304                jnc   L6586
6582  A1C0FF30            ld    REG_30,#$FFC0
6586  8830AA        L6586 cmp   REG_AA,REG_30			; REG_AA is Throttle position
6589  D105                jnh   L6590
658B  910847              orb   REG_47,#$08				; REG_47 bit 3 ON (Air management1)
658E  2010                sjmp  L65A0
6590  6BF20C30      L6590 sub   REG_30,$0C[REG_F2]
6594  DB02                jc    L6598
6596  0130                clr   REG_30
6598  8830AA        L6598 cmp   REG_AA,REG_30			; REG_AA is Throttle position
659B  DB03                jc    L65A0
659D  71F747        L659D andb  REG_47,#$F7				; REG_47 bit 3 OFF (Air management1)
65A0  F0            L65A0 ret
;
;*****************************************************************
; Cycling Routine at 2151, routine offset $4A
; Update Air Management
;*****************************************************************
;
65A1  B3FE0B30      L65A1 ldb   REG_30,$0B[REG_FE]		; ROM $9E65 thermactor_present_switch = 1.0
65A5  990330              cmpb  REG_30,#$03
65A8  D729                jne   L65D3
65AA  A3F20E30            ld    REG_30,$0E[REG_F2]		; ROM $8E68 - NIAC
65AE  8830AE              cmp   REG_AE,REG_30			; REG_AE = engine RPM * 4
65B1  D105                jnh   L65B8
65B3  911029              orb   REG_29,#$10				; set IACFLG
65B6  2010                sjmp  L65C8
65B8  6BF21030      L65B8 sub   REG_30,$10[REG_F2]		; ROM $8E6A - NIACH
65BC  DB02                jc    L65C0
65BE  0130                clr   REG_30
65C0  8830AE        L65C0 cmp   REG_AE,REG_30			; REG_AE = engine RPM * 4
65C3  DB03                jc    L65C8
65C5  71EF29              andb  REG_29,#$EF				; clr IACFLG
65C8  3C2905        L65C8 jbs   REG_29,BIT_04,L65D0
65CB  71EF47              andb  REG_47,#$EF				; REG_47 bit 4 OFF (Air management2)
65CE  2003                sjmp  L65D3
65D0  911047        L65D0 orb   REG_47,#$10				; REG_47 bit 4 ON (Air management2)
65D3  F0            L65D3 ret
;
;*****************************************************************
; Cycling Routine at 2151, routine offset $18
;*****************************************************************
;
65D4  3D2B04              jbs   REG_2B,BIT_05,L65DB		; jump if STI input high
65D7  C7724800            stb   Zero,$48[REG_72]		; zero $01C8 timer - STI input line low timer

65DB  37A11E        L65DB jbc   REG_A1,BIT_07,L65FC		; jump if not CRANKING
65DE  11C8                clrb  REG_C8					; (REG_C8 may be a byte size counter for ATMR1)
65E0  71BF24              andb  REG_24,#$BF
65E3  11C9                clrb  REG_C9					; REG_C9 is some kind of timer ATMR2 = Time since ECT became greater than TEMPBF sec
65E5  71DF24              andb  REG_24,#$DF
65E8  11CD                clrb  REG_CD					; zero timer? NACTMR = Not at Closed Throttle Timer, sec
65EA  71FB24              andb  REG_24,#$FB
65ED  11CB                clrb  REG_CB					; zero timer? AWOTMR = Time at WOT, sec
65EF  71DFA1              andb  REG_A1,#$DF
65F2  C772C900            stb   Zero,$C9[REG_72]		; zero $0149 - timer Canister Purge Timer - cannister purge accumulation time in seconds
65F6  C772CE00            stb   Zero,$CE[REG_72]		; zero $014E timer? EDFTMR = Set to 0 when the EDF (low speed fan) is de-energized or  CRKFLG = 1.  Otherwise, it is free-running
65FA  22C4                sjmp  L68C0

65FC  37D00A        L65FC jbc   REG_D0,BIT_07,L6609		; jmp if closed throttle = false
65FF  9140A1              orb   REG_A1,#$40
6602  71DF24              andb  REG_24,#$DF
6605  11CD                clrb  REG_CD					; zero timer = time since closed throttle
6607  200A                sjmp  L6613

6609  912024        L6609 orb   REG_24,#$20
660C  71BFA1              andb  REG_A1,#$BF
660F  C772AA00            stb   Zero,$AA[REG_72]		; zero $012A timer = time throttle has been closed

6613  30240D        L6613 jbc   REG_24,BIT_00,L6623		; check WOT flag
6616  910424              orb   REG_24,#$04
6619  99FECB              cmpb  REG_CB,#$FE				; timer?
661C  D303                jnc   L6621
661E  71FB24              andb  REG_24,#$FB
6621  2005          L6621 sjmp  L6628

6623  71FB24        L6623 andb  REG_24,#$FB
6626  11CB                clrb  REG_CB					; zero timer?

6628  9BFE06B0      L6628 cmpb  REG_B0,$06[REG_FE]		; Engine Coolant Temperature - degrees F ?
662C  DA08                jle   L6636
662E  3E2405              jbs   REG_24,BIT_06,L6636
6631  914024              orb   REG_24,#$40
6634  11C9                clrb  REG_C9					; REG_C9 is some kind of timer

6636  354704        L6636 jbc   REG_47,BIT_05,L663D		; if REG_47 bit 5 OFF (Fan?)
6639  C772CE00            stb   Zero,$CE[REG_72]		; zero $014E - timer

663D  A3FC3838      L663D ld    REG_38,$38[REG_FC]		; $9AB6 = IDLRPM = Maximum RPM for Closed Throttle Mode Idle, rpm
6641  8838AE              cmp   REG_AE,REG_38			; REG_AE = engine RPM * 4
6644  DB05                jc    L664B
6646  9102A1              orb   REG_A1,#$02				; engine_idling = true
6649  200C                sjmp  L6657
664B  67FC3A38      L664B add   REG_38,$3A[REG_FC]		; $9AB8 = IDRPMH = Hysteresis for IDLRPM
664F  8838AE              cmp   REG_AE,REG_38			; REG_AE = engine RPM * 4
6652  D103                jnh   L6657
6654  71FDA1        L6654 andb  REG_A1,#$FD				; engine_idling = false

6657  71F7EF        L6657 andb  REG_EF,#$F7
665A  362609              jbc   REG_26,BIT_06,L6666
665D  37D006              jbc   REG_D0,BIT_07,L6666		; jmp if throttle is not closed
6660  31A103              jbc   REG_A1,BIT_01,L6666
6663  9108EF              orb   REG_EF,#$08
6666  B372C434      L6666 ldb   REG_34,$C4[REG_72]
666A  452A01F8            add   REG_32,REG_F8,#$012A	; FILTER $955A
      32
666F  EF45CF              lcall L35B7					; Interpolate Single var Table R32-table,R34-in,R38-out
6672  090538              shl   REG_38,#$05
6675  67F63238            add   REG_38,$32[REG_F6]
6679  8838AE              cmp   REG_AE,REG_38			; REG_AE = engine RPM * 4
667C  DB05                jc    L6683
667E  910224              orb   REG_24,#$02
6681  200C                sjmp  L668F
6683  67F63438      L6683 add   REG_38,$34[REG_F6]
6687  8838AE              cmp   REG_AE,REG_38			; REG_AE = engine RPM * 4
668A  D103                jnh   L668F
668C  71FD24              andb  REG_24,#$FD
668F  71FBE8        L668F andb  REG_E8,#$FB
6692  71FDE8              andb  REG_E8,#$FD
6695  9101E8              orb   REG_E8,#$01
6698  9BFE04B0            cmpb  REG_B0,$04[REG_FE]		; Engine Coolant Temperature - degrees F ?
669C  DA2C                jle   L66CA
669E  37D029              jbc   REG_D0,BIT_07,L66CA		; jmp if throttle is not closed
66A1  3FE726              jbs   REG_E7,BIT_07,L66CA
66A4  312423              jbc   REG_24,BIT_01,L66CA
66A7  9104E8              orb   REG_E8,#$04
66AA  9102E8              orb   REG_E8,#$02
66AD  71FEE8              andb  REG_E8,#$FE
66B0  B3F47238            ldb   REG_38,$72[REG_F4]
66B4  77F47338            addb  REG_38,$73[REG_F4]
66B8  D303                jnc   L66BD
66BA  B1FF38              ldb   REG_38,#$FF
66BD  9B72C438      L66BD cmpb  REG_38,$C4[REG_72]
66C1  D907                jh    L66CA
66C3  C772C438            stb   REG_38,$C4[REG_72]
66C7  71FDE8              andb  REG_E8,#$FD
66CA  A374E23A      L66CA ld    REG_3A,$E2[REG_74]		; $0260 Volumetric Efficiency
66CE  A3F62238            ld    REG_38,$22[REG_F6]
66D2  47F62438            add   REG_3C,REG_38,$24[REG_F6]
      3C
66D7  D303                jnc   L66DC
66D9  BDFF3C              ldbse REG_3C,#$FF
66DC  883A3C        L66DC cmp   REG_3C,REG_3A
66DF  D30E                jnc   L66EF
66E1  883A38              cmp   REG_38,REG_3A
66E4  D10C                jnh   L66F2
66E6  C772B700            stb   Zero,$B7[REG_72]		; zero $0137 timer?
66EA  71FBEB              andb  REG_EB,#$FB
66ED  2003                sjmp  L66F2
66EF  9104EB        L66EF orb   REG_EB,#$04
66F2  717FEC        L66F2 andb  REG_EC,#$7F
66F5  450200F4            add   REG_30,REG_F4,#$0002	; $8FD8
      30
66FA  EF52D0              lcall L374F
66FD  DB56                jc    L6755
66FF  38D053              jbs   REG_D0,BIT_00,L6755		; jmp if throttle is not closed
6702  3AEE50              jbs   REG_EE,BIT_02,L6755
6705  8BF40EAE            cmp   REG_AE,$0E[REG_F4]		; REG_AE = engine RPM * 4
6709  D14A                jnh   L6755
670B  8BF410AE            cmp   REG_AE,$10[REG_F4]		; REG_AE = engine RPM * 4
670F  DB44                jc    L6755
6711  4B74FEAE            sub   REG_38,REG_AE,$FE[REG_74]	; REG_AE = engine RPM * 4 from filtered sensor output - in place ($027c) - filtered(2) RPM
      38
6716  DB02                jc    L671A
6718  0338                neg   REG_38
671A  8BF41238      L671A cmp   REG_38,$12[REG_F4]
671E  DB35                jc    L6755
6720  8BF4143A            cmp   REG_3A,$14[REG_F4]
6724  DB2F                jc    L6755
6726  37E72C              jbc   REG_E7,BIT_07,L6755
6729  B3F42038            ldb   REG_38,$20[REG_F4]
672D  77F42138            addb  REG_38,$21[REG_F4]
6731  D303                jnc   L6736
6733  B1FF38              ldb   REG_38,#$FF
6736  9B748038      L6736 cmpb  REG_38,$80[REG_74]		; BP - barometric pressure
673A  D919                jh    L6755
673C  9BF24700            cmpb  Zero,$47[REG_F2]
6740  DF16                je    L6758
6742  B3F24238            ldb   REG_38,$42[REG_F2]
6746  77F24338            addb  REG_38,$43[REG_F2]
674A  D303                jnc   L674F
674C  B1FF38              ldb   REG_38,#$FF
674F  9B743F38      L674F cmpb  REG_38,$3F[REG_74]		; $2BD - vehicle speed filtered(1) (MPH) $02BC is 8.8 format
6753  D103                jnh   L6758
6755  30EC03        L6755 jbc   REG_EC,BIT_00,L675B
6758  9180EC        L6758 orb   REG_EC,#$80
675B  B372C838      L675B ldb   REG_38,$C8[REG_72]
675F  30EE02              jbc   REG_EE,BIT_00,L6764
6762  1738                incb  REG_38
6764  3FEC02        L6764 jbs   REG_EC,BIT_07,L6769
6767  1138                clrb  REG_38
6769  C772C838      L6769 stb   REG_38,$C8[REG_72]
676D  9BF41638            cmpb  REG_38,$16[REG_F4]
6771  D303                jnc   L6776
6773  9101EC              orb   REG_EC,#$01
6776  382455        L6776 jbs   REG_24,BIT_00,L67CE		; check WOT flag
6779  A3F41038            ld    REG_38,$10[REG_F4]
677D  67F41838            add   REG_38,$18[REG_F4]
6781  8838AE              cmp   REG_AE,REG_38			; REG_AE = engine RPM * 4
6784  D948                jh    L67CE
6786  A3F40E38            ld    REG_38,$0E[REG_F4]
678A  6BF41A38            sub   REG_38,$1A[REG_F4]
678E  8838AE              cmp   REG_AE,REG_38			; REG_AE = engine RPM * 4
6791  D33B                jnc   L67CE
6793  8BF41C3A            cmp   REG_3A,$1C[REG_F4]
6797  D335                jnc   L67CE
6799  A3F41438            ld    REG_38,$14[REG_F4]
679D  67F41E38            add   REG_38,$1E[REG_F4]
67A1  D303                jnc   L67A6
67A3  BDFF38              ldbse REG_38,#$FF
67A6  88383A        L67A6 cmp   REG_3A,REG_38
67A9  D923                jh    L67CE
67AB  37E720              jbc   REG_E7,BIT_07,L67CE
67AE  51A8C534            andb  REG_34,REG_C5,#$A8
67B2  D71A                jne   L67CE
67B4  B3748040            ldb   REG_40,$80[REG_74]		; BP - barometric pressure
67B8  9BF42040            cmpb  REG_40,$20[REG_F4]
67BC  D310                jnc   L67CE
67BE  9BF24700            cmpb  Zero,$47[REG_F2]
67C2  DF10                je    L67D4
67C4  B3F24238            ldb   REG_38,$42[REG_F2]
67C8  9B743F38            cmpb  REG_38,$3F[REG_74]		; $2BD - vehicle speed filtered(1) (MPH) $02BC is 8.8 format
67CC  D106                jnh   L67D4
67CE  C4CE00        L67CE stb   Zero,REG_CE				; zero REG_CE timer?
67D1  71FEEC              andb  REG_EC,#$FE
67D4  71FB26        L67D4 andb  REG_26,#$FB
67D7  37D006              jbc   REG_D0,BIT_07,L67E0		; jmp if throttle is not closed
67DA  3FE703              jbs   REG_E7,BIT_07,L67E0
67DD  910426              orb   REG_26,#$04
67E0  1138          L67E0 clrb  REG_38
67E2  30EC12              jbc   REG_EC,BIT_00,L67F7
67E5  B3F42238            ldb   REG_38,$22[REG_F4]
67E9  7774F438            addb  REG_38,$F4[REG_74]
67ED  DB05                jc    L67F4
67EF  998038              cmpb  REG_38,#$80
67F2  D103                jnh   L67F7
67F4  B18038        L67F4 ldb   REG_38,#$80
67F7  C774F438      L67F7 stb   REG_38,$F4[REG_74]
67FB  302904              jbc   REG_29,BIT_00,L6802
67FE  C772CC00            stb   Zero,$CC[REG_72]		; High load timer - 1/8 seconds under high load so far
6802  3AEE08        L6802 jbs   REG_EE,BIT_02,L680D
6805  3B2705              jbs   REG_27,BIT_03,L680D
6808  918027              orb   REG_27,#$80
680B  2007                sjmp  L6814
680D  717F27        L680D andb  REG_27,#$7F
6810  C774E800            stb   Zero,$E8[REG_74]		; zero timer?
6814  3AEE08        L6814 jbs   REG_EE,BIT_02,L681F
6817  382705              jbs   REG_27,BIT_00,L681F
681A  914027              orb   REG_27,#$40
681D  2007                sjmp  L6826
681F  71BF27        L681F andb  REG_27,#$BF
6822  C774E900            stb   Zero,$E9[REG_74]		; zero timer?
6826  B374E814      L6826 ldb   REG_14,$E8[REG_74]		; timer?
682A  9BF63614            cmpb  REG_14,$36[REG_F6]
682E  D303                jnc   L6833
6830  9102ED              orb   REG_ED,#$02
6833  B374E914      L6833 ldb   REG_14,$E9[REG_74]		; timer?
6837  9BF63614            cmpb  REG_14,$36[REG_F6]
683B  D303                jnc   L6840
683D  9101ED              orb   REG_ED,#$01
6840  B3F63814      L6840 ldb   REG_14,$38[REG_F6]
6844  980014              cmpb  REG_14,Zero
6847  DF0C                je    L6855
6849  332703              jbc   REG_27,BIT_03,L684F
684C  71FDED              andb  REG_ED,#$FD
684F  302703        L684F jbc   REG_27,BIT_00,L6855
6852  71FEED              andb  REG_ED,#$FE
6855  33EA05        L6855 jbc   REG_EA,BIT_03,L685D
6858  38EA02              jbs   REG_EA,BIT_00,L685D
685B  2006                sjmp  L6863
685D  3BEA0A        L685D jbs   REG_EA,BIT_03,L686A
6860  30EA07              jbc   REG_EA,BIT_00,L686A
6863  C3749800      L6863 st    Zero,$98[REG_74]		; zero $0216 - timer?
6867  9501EA              xorb  REG_EA,#$01
686A  A372A636      L686A ld    REG_36,$A6[REG_72]		; $0126 - RATCH=Closed TP
686E  47F66036            add   REG_42,REG_36,$60[REG_F6]
      42
6873  88AA42              cmp   REG_42,REG_AA			; REG_AA is Throttle position
6876  DB03                jc    L687B
6878  9180EB              orb   REG_EB,#$80
687B  6BF66242      L687B sub   REG_42,$62[REG_F6]
687F  88AA42              cmp   REG_42,REG_AA			; REG_AA is Throttle position
6882  D103                jnh   L6887
6884  717FEB              andb  REG_EB,#$7F
6887  3FEB06        L6887 jbs   REG_EB,BIT_07,L6890
688A  C7749600            stb   Zero,$96[REG_74]		; zero $0214 - timer?
688E  200F                sjmp  L689F
6890  B3749642      L6890 ldb   REG_42,$96[REG_74]		; $0214 - timer?
6894  99FF42              cmpb  REG_42,#$FF
6897  D706                jne   L689F
6899  1542                decb  REG_42
689B  C7749642            stb   REG_42,$96[REG_74]		; set $0214 - timer?
689F  4836AA34      L689F sub   REG_34,REG_AA,REG_36	; REG_AA is Throttle position
68A3  DB02                jc    L68A7
68A5  0134                clr   REG_34
68A7  455601F0      L68A7 add   REG_32,REG_F0,#$0156	; TABLE $9056
      32
68AC  EF5DCD              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
68AF  9B749638            cmpb  REG_38,$96[REG_74]		; $0214 - timer?
68B3  D104                jnh   L68B9
68B5  C7749700            stb   Zero,$97[REG_74]		; zero $0215 timer?
68B9  302404        L68B9 jbc   REG_24,BIT_00,L68C0		; check WOT flag
68BC  C774A200            stb   Zero,$A2[REG_74]		; zero $0220 timer?
68C0  A3F61C32      L68C0 ld    REG_32,$1C[REG_F6]
68C4  67F61A32            add   REG_32,$1A[REG_F6]
68C8  8832AE              cmp   REG_AE,REG_32			; REG_AE = engine RPM * 4
68CB  D105                jnh   L68D2
68CD  9110EB              orb   REG_EB,#$10
68D0  2009                sjmp  L68DB
68D2  8BF61CAE      L68D2 cmp   REG_AE,$1C[REG_F6]		; REG_AE = engine RPM * 4
68D6  DB03                jc    L68DB
68D8  71EFEB              andb  REG_EB,#$EF
68DB  37D008        L68DB jbc   REG_D0,BIT_07,L68E6		; jmp if throttle is not closed
68DE  34EB05              jbc   REG_EB,BIT_04,L68E6
68E1  9108EB              orb   REG_EB,#$08
68E4  2007                sjmp  L68ED
68E6  C772B800      L68E6 stb   Zero,$B8[REG_72]		; zero $0138 timer?
68EA  71F7EB              andb  REG_EB,#$F7
68ED  8800AE        L68ED cmp   REG_AE,Zero				; REG_AE = engine RPM * 4
68F0  D704                jne   L68F6
68F2  C772CF00            stb   Zero,$CF[REG_72]		; zero $014F timer?
68F6  3AEA04        L68F6 jbs   REG_EA,BIT_02,L68FD
68F9  C3749A00            st    Zero,$9A[REG_74]		; zero $0218 - timer?
68FD  F0            L68FD ret

;
;*****************************************************************
	update 32 bit master io time
	calc new time seconds BP 16
	xor to last time seconds BP 16
	each on bit says time has changes


what if we keep time in msecs 0 to 1024 msec

set bits in xor to partial seconds - at every full second we reset the count - be carefull on exact rollover time
timer & 0xFFFF is millsec update
timer & 0xFF80 is 1/8th sec - 007F
timer & 0xFC00 is seconds   - 03FF

rollover - sub off 1 sec in IOtimes 

;*****************************************************************
; Cycling Routine at 2151, routine offset $1A
;
; Update Timers
;
; Read a table of timer address and flags 
;		3 byte entries count up/down in 1/1024(ms), 1/8 sec or secs
;       5 byte entries are additionally conditioned to a flag bit
; 
; Assumptions:
; - EEC crystal clock is 15.0 MHz
; - 3 crystal clocks per state time clock
; - 12 state clocks per IOTime clock
;
; if 15.0MHz clock then 
;
; if 3 cycles per state, state time freq is 5MHz
;
; if 12 states per IOTime, then IOTime is 416666.67 Hz
;    and 128/$CB73 * 416,666 = 1024.00 Hz
;    so smallest time unit is 1/1024 sec
;
; $C0[REG_72] is remainders, (R3C)low  byte is msec over last full 1/8th sec
;                            (R3D)high byte is 1/8ths over last full second
; $C2[REG_72] is the last msec sample time in IOTimes
;
;*****************************************************************
;
68FE  A372C03C      L68FE ld    REG_3C,$C0[REG_72]	; partial extra times for 1/8ths and seconds
6902  A1B16930            ld    REG_30,#$69B1		; Ptr - table of input entries
6906  A00636              ld    REG_36,Master_IO_Timer  ; 16 bit current IO time
6909  4B72C23638          sub   REG_38,REG_36,$C2[REG_72] ; delta time since last exact sample time to 1/1024 sec

>>> REG_38 is delta time from $C2[REG_72] to current Master_IO_Timer

690E  013A                clr   REG_3A				; delta time long Hi
6910  0D0738              shll  REG_38,#$07			; delta time * 128
6913  8D73CB38            divu  REG_38,#$CB73		; 52083 dec - time 1/1024 second

>>> REG_38 delta time in 1/1024 ths seconds
>>> REG_3A is remainder Master_IO_Timer units that don't make a whole 1/1024 second * 128

6917  880038              cmp   REG_38,Zero			; do we need to update timers yet?
691A  D702                jne   L691E				; jmp if at least one 1/1024th sec has passed
691C  2092                sjmp  L69B0				; if it hasn't been 1/1024 - return
	
691E  C7745E38      L691E stb   REG_38,$5E[REG_74]	; time (Ms since last update?) 1/1024 second - (BACKGROUND_LOOP_TIMER)

>>> $5E[REG_74] is LSB of 1/1024ths sec for one background loop thru the procs (~msec - used for filtering)

6922  6540003A            add   REG_3A,#$0040		; remainder IO times + 64 (round vs truncation)
6926  08073A              shr   REG_3A,#$07			; div by 128 w/rounded result

>>> REG_3A is remainder Master_IO_Timer ticks in Master_IO_Timer units * 128

6929  483A3632            sub   REG_32,REG_36,REG_3A ; time of last update in 1/1024s second(clock - remainder)

>>> REG_32 is the EXACT Master_IO_Time for the 1/1024 sample time we use
>>> REG_3C is the parial times in REG_3C for 1/8ths, and REG_3D for seconds
>>> REG_3A is remainder Master_IO_Timer ticks in Master_IO_Timer units  * 128 
>>> REG_38 delta time in 1/1024 ths seconds

692D  B1203E              ldb   REG_3E,#$20			; set flag to update all 1/1024 second timers
6930  74383C              addb  REG_3C,REG_38		; add current msec delta time to partail msec for next full 1/8th

>>> REG_3C BYTE is current time in 1/1024ths seconds resolution + remainder portion of an 1/8th

6933  59803C3F            subb  REG_3F,REG_3C,#$80	; BYTE do we have 128 1024ths? = 1/8 second
6937  D30F                jnc   L6948				; jmp if time interval < 1/8 second - leave new partial in REG_3C
; one 1/8 second has passed
6939  B03F3C              ldb   REG_3C,REG_3F		; new partial 1/8th in msec
693C  91403E              orb   REG_3E,#$40			; add flag to update all 1/8 second timers
693F  E03D06              djnz  REG_3D,L6948		; REG_3D is partial 1/8s for 1 sec, if zero reset count to 8
; one full second has passed (REG_3D was at 0 (means 0.875 sec and we add another 1/8 for this pass)
6942  91803E              orb   REG_3E,#$80			; update in seconds flag mask
6945  B1083D              ldb   REG_3D,#$08			; reset partial 1/8ths to none(=8:we count down)

6948  C372C03C      L6948 st    REG_3C,$C0[REG_72]	; partial remainders
694C  C372C232            st    REG_32,$C2[REG_72]	; save time of last time sample truncated to whole 1/1024 second

6950  B2313C        L6950 ldb   REG_3C,[REG_30]+	; load flag byte from $69B1 TABLE entry
6953  98003C              cmpb  REG_3C,Zero			; if all flag bits == 0 - exit - done
6956  DF58                je    L69B0				; return (exit)
6958  AE3132              ldbze REG_32,[REG_30]+	; Lo byte of save address
695B  B23133              ldb   REG_33,[REG_30]+	; Hi byte of save address
695E  303C12              jbc   REG_3C,BIT_00,L6973	; short entry? test BIT 0 of FLAG byte in entry

6961  B2313D              ldb   REG_3D,[REG_30]+	; load flag bits byte from entry
6964  AE3134              ldbze REG_34,[REG_30]+	; create SFR address
6967  72343D              andb  REG_3D,[REG_34]		; read data from SFR loc and mask with REG_3D
696A  333C04              jbc   REG_3C,BIT_03,L6971
696D  DF04                je    L6973				; if AND operation == 0 process entry
696F  27DF                sjmp  L6950				; loop - next entry - flag condition not met - flag bit not clr yet

6971  DFDD          L6971 je    L6950				; loop - next entry - flag condition not met - flag bit not set yet

6973  503C3E00      L6973 andb  Zero,REG_3E,REG_3C	; time unit flags - has this time increment passed?
6977  DFD7                je    L6950				; loop - next entry

6979  313C05              jbc   REG_3C,BIT_01,L6981	; flag bit - 8 or 16 bit timer
; READ NEXT TIMER VALUE LOC
697C  A23236              ld    REG_36,[REG_32]		; read current value of a 16 bit timer
697F  2003                sjmp  L6984
6981  BE3236        L6981 ldbse REG_36,[REG_32]		; read current value of a 8 bit timer
; APPLY TIME DELTA FOR THIS TIMER
6984  323C04        L6984 jbc   REG_3C,BIT_02,L698B	; jmp if timing up
6987  0336                neg   REG_36				; negate value
6989  DF18                je    L69A3				; jmp to save word/byte clamp countdown timer value to zero
698B  3D3C04        L698B jbs   REG_3C,BIT_05,L6992 ; jmp if timer is in msec
698E  0736                inc   REG_36				; add one what time unit? SB 1.0 second?
6990  2003                sjmp  L6995

6992  643836        L6992 add   REG_36,REG_38		; add 1/1024 seconds to word(may be multiple)(format is 8.8)
6995  D307          L6995 jnc   L699E				; jmp if timer did NOT overflow
6997  0136                clr   REG_36				; zero value - clamp
6999  3A3C07              jbs   REG_3C,BIT_02,L69A3	; jmp to save word/byte
699C  0536                dec   REG_36				; decrement value
699E  323C02        L699E jbc   REG_3C,BIT_02,L69A3	; jmp to save word/byte
69A1  0336                neg   REG_36
69A3  313C05        L69A3 jbc   REG_3C,BIT_01,L69AB
; SAVE BACK UPDATED TIME
69A6  C23236              st    REG_36,[REG_32]		; writes WORD to address	
69A9  27A5                sjmp  L6950				; loop
69AB  C63236        L69AB stb   REG_36,[REG_32]		; writes BYTE to $215 = $95[REG_72] = start value for ACT calc
69AE  27A0                sjmp  L6950				; loop

69B0  F0            L69B0 ret

; data table of TIMERS
; entry size = 2 if bit 0 of first byte = 0
; else entry size = 5
; in follow table the 15 bit address field is byte flipped for correct word order
; 0 byte is flags
;   bit 0 = 0 if short entry
;   bit 1 = 1 if 16 bit timer else 0 = 8 bit timer
;   bit 2 = 0 timer count up vs down
;   bit 3 = 0 if flag bit must be set to update timer loc
;
;   bit 4 not used
;   bit 5 = 1 update in 1/1024 seconds (~msec)
;   bit 6 = update in 1/8 seconds
;   bit 7 = update in seconds
; So
;	8X = timer in seconds
;	4X = timer in 1/8 seconds
;	2X = timer in 1/1024 seconds (~msec)
;
; 1 word save address
; 3 byte flag data mask - selects bit in flag address to mask out
; 4 address for flag data to start timer

69B1  20 0136 		; time since last BP pulse?
69B4  89 00C8 80 A1 ; ATMR1 - Time since start (time since exiting crank mode) (sec) REG_A1 bit 7 is cranking flag
69B9  81 00C9 40 24 ; ATMR2 - Time since engine coolant temperature became greater than TEMPFB (sec) REG_24 bit 6 is ATMR2 flag
69BE  89 014D 04 A1	; ATMR3 - Time since Entering RUN Mode (sec) REG_A1 bit 6 is Time since entering Closed throttle mode, secs
69C3  81 0266 80 27 ; LESTMR1 - timer for EGO1 switches, or lack of switching if you prefer
69C8  81 0267 40 27	; LESTMR2
69CD  81 00CB 04 24 ; AWOTMR - Time at WOT, sec.
69D2  81 00CD 20 24 ; NACTMR - Not at Closed throttle Timer, sec.
69D7  83 013A 01 A1	; ADPTMR - time at operating temp ( 170 < ECT temp < 226 ) Adaptive fuel timer (sec)
69DC  41 0145 80 ED ; LUGTMR - LOM load transition timer (sec)
69E1  45 0145 40 ED ; LUGTMR
69E6  80 014E		; EDFTMR - ELECTRO-DRIVE FAN TIMER (SEC)
69E9  40 01CA		; VIP_TIMER_EX
69EC  42 01C0		; MILTMR - a .125 second timer, is used to control the MIL  logic. 
69EF  22 0134		; PUTMR  - Time since CPU power-up - word (msec)
69F2  41 01C8 20 2B ; TSSTIL - REG_2B bit 5 is STIFLG - time since STI low?
69F7  83 01C2 40 2A ; OUTTMR - time since NO_START flag set?
69FC  22 013E		; TSLPIP - time since last PIP recieved
69FF  22 01C4		; TSLIDM - time since last idm
6A02  81 0137 04 EB ; HMTMR  - High Power Demand Timer, sec.
6A07  49 014C 01 29	; HLTMR  - High load timer - 1/8 seconds **
6A0C  80 0138		; CTATMR - Closed Throttle Upstream Air Timer (sec)
6A0F  41 012A 40 A1 ; CTTMR  - Time at closed throttle timer (sec)(CTTMR_FLG)
6A14  81 0144 02 E8 ; CTNTMR - Closed throttle neutral timer UP
6A19  85 0144 01 E8 ; CTNTMR - Closed throttle neutral timer DOWN
6A1E  89 0220 01 24	; NWOTMR - Not at Wide Open Throttle Timer. (sec) (WOT)
6A23  81 00CE 01 EC	; MFATMR - Managed Fuel Air Timer, sec.
6A28  81 0264 80 24	; TSEGRE - Accumulated time EGR is enabled (sec)
6A2D  23 021E 40 4F	; TSLADV - Free-running millisecond timer which counts the time since the spark was last advanced by the KNOCK Strategy(KNOCK_ENABLED)
6A32  80 0146		; ISCTMR - ??RPM sampling timer
6A35  20 0147		; MULTMR - Time since incrementing LAMMUL (msec)
6A38  40 00CC		; TDDTIM
6A3B  42 0216		; ACCTMR - A/C CLUTCH TRANSITION TIMER (0.125 SEC RESOLUTION)
6A3E  80 0214		; ACWTMR - A/C CLUTCH WIDE OPEN THROTTLE TIMER (SECONDS) (SEC RESOLUTION)
6A41  40 0215 		; WCOTMR - A/C CLUTCH WOT CUTOUT TIMER (0.125 SEC RESOLUTION)
6A44  23 0218 04 EA	; ACITMR - Time since Idle Speed Control system was warned of impending increase in load (ACIFLG)
6A49  41 0213 02 EA	; ACBTMR - Time since brake went on.(BIFLG)
6A4E  41 0139 40 EC ; SLTMR  - Shift Light Timer.(SLTMR_FLG)
6A53  26 02A8		; DEBTMR - VSCCS Debounce timer, sec.
6A56  20 02BB 		; TSLMPH - timer since last VSS click
6A59  40 014F		; CRKTMR - Time in CRANK Mode (sec)(SB 1/8 sec???)
6A5C  81 0149 40 EF ; PRGTMR - Canister purge accumulation timer (sec) (PRGFLG)
6A61  41 014A 40 EF ; CPRGTMR - Current Purge on time.(PRGFLG)
6A66  21 0150 08 A1 ; DLTMR  - Decel fuel low load timer, sec.(DMFLG)
6A6B  22 0132		; FFMTMR - FAM filter timer (sec)
6A6E  40 01C9		; VSSTMR - VEHICLE SPEED SENSOR TIMER (.125 SEC) (TESTING ONLY???)
6A71  40 01C6		; VIP_PFMTMR
6A74  22 03AA		; HWTMR - Free running timer that is reset to 0 on if A3CTMR > H/W switching frequency
6A77  22 03A8		; 3ACTMR
6A7A  00	- END OF TIMER TABLE
;
; Reformatted timer table in sorted order
;
    C8  8 bit timer, one second ,counts down ,trigger address   A1 ,trigger mask 80 ,trigger on set
    C9  8 bit timer, one second ,counts down ,trigger address   24 ,trigger mask 40 ,trigger on clear
    CB  8 bit timer, one second ,counts down ,trigger address   24 ,trigger mask  4 ,trigger on clear
    CC  8 bit timer, 1/8 second ,counts down
    CD  8 bit timer, one second ,counts down ,trigger address   24 ,trigger mask 20 ,trigger on clear
    CE  8 bit timer, one second ,counts down ,trigger address   EC ,trigger mask  1 ,trigger on clear
   12A  8 bit timer, 1/8 second ,counts down ,trigger address   A1 ,trigger mask 40 ,trigger on clear
   132 16 bit timer, 1/1024 sec ,counts down
   134 16 bit timer, 1/1024 sec ,counts down
   136  8 bit timer, 1/1024 sec ,counts down
   137  8 bit timer, one second ,counts down ,trigger address   EB ,trigger mask  4 ,trigger on clear
   138  8 bit timer, one second ,counts down
   139  8 bit timer, 1/8 second ,counts down ,trigger address   EC ,trigger mask 40 ,trigger on clear
   13A 16 bit timer, one second ,counts down ,trigger address   A1 ,trigger mask  1 ,trigger on clear
   13E 16 bit timer, 1/1024 sec ,counts down
   144  8 bit timer, one second ,counts down ,trigger address   E8 ,trigger mask  2 ,trigger on clear
   144  8 bit timer, one second ,counts   up ,trigger address   E8 ,trigger mask  1 ,trigger on clear
   145  8 bit timer, 1/8 second ,counts down ,trigger address   ED ,trigger mask 80 ,trigger on clear
   145  8 bit timer, 1/8 second ,counts   up ,trigger address   ED ,trigger mask 40 ,trigger on clear
   146  8 bit timer, one second ,counts down
   147  8 bit timer, 1/1024 sec ,counts down
   149  8 bit timer, one second ,counts down ,trigger address   EF ,trigger mask 40 ,trigger on clear
   14A  8 bit timer, 1/8 second ,counts down ,trigger address   EF ,trigger mask 40 ,trigger on clear
   14C  8 bit timer, 1/8 second ,counts down ,trigger address   29 ,trigger mask  1 ,trigger on set
   14D  8 bit timer, one second ,counts down ,trigger address   A1 ,trigger mask  4 ,trigger on set
   14E  8 bit timer, one second ,counts down
   14F  8 bit timer, 1/8 second ,counts down
   150  8 bit timer, 1/1024 sec ,counts down ,trigger address   A1 ,trigger mask  8 ,trigger on clear
   1C0 16 bit timer, 1/8 second ,counts down
   1C2 16 bit timer, one second ,counts down ,trigger address   2A ,trigger mask 40 ,trigger on clear
   1C4 16 bit timer, 1/1024 sec ,counts down
   1C6  8 bit timer, 1/8 second ,counts down
   1C8  8 bit timer, 1/8 second ,counts down ,trigger address   2B ,trigger mask 20 ,trigger on clear
   1C9  8 bit timer, 1/8 second ,counts down
   1CA  8 bit timer, 1/8 second ,counts down
   213  8 bit timer, 1/8 second ,counts down ,trigger address   EA ,trigger mask  2 ,trigger on clear
   214  8 bit timer, one second ,counts down
   215  8 bit timer, 1/8 second ,counts down
   216 16 bit timer, 1/8 second ,counts down
   218 16 bit timer, 1/1024 sec ,counts down ,trigger address   EA ,trigger mask  4 ,trigger on clear
   21E 16 bit timer, 1/1024 sec ,counts down ,trigger address   4F ,trigger mask 40 ,trigger on clear
   220  8 bit timer, one second ,counts down ,trigger address   24 ,trigger mask  1 ,trigger on set
   264  8 bit timer, one second ,counts down ,trigger address   24 ,trigger mask 80 ,trigger on clear
   266  8 bit timer, one second ,counts down ,trigger address   27 ,trigger mask 80 ,trigger on clear
   267  8 bit timer, one second ,counts down ,trigger address   27 ,trigger mask 40 ,trigger on clear
   2A8 16 bit timer, 1/1024 sec ,counts   up
   2BB  8 bit timer, 1/1024 sec ,counts down
   3A8 16 bit timer, 1/1024 sec ,counts down
   3AA 16 bit timer, 1/1024 sec ,counts down
;
;*****************************************************************
; Cycling Routine at 2151, routine offset $46
;  Update shift light
;*****************************************************************
;
6A7B  B3FE0330     L6A7B  ldb   REG_30,$03[REG_FE]		; ROM $9E5D=0(Manual trans) - TSTRAT - transmission stratagey
6A7F  990130              cmpb  REG_30,#$01				; SIL (Shift Indicator Light)
6A82  D755                jne   L6AD9
6A84  38D02D              jbs   REG_D0,BIT_00,L6AB4		; jmp if throttle is closed
6A87  453400F032          add   REG_32,REG_F0,#$0034	; TABLE $8C34 - Incremental Indicated RPM shift point as a function of ECT
6A8C  BCB034              ldbse REG_34,REG_B0			; Engine Coolant Temperature - degrees F ?
6A8F  EF6FCB              lcall L3601					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
6A92  C01438              st    REG_38,REG_14
6A95  455000F032          add   REG_32,REG_F0,#$0050	; TABLE $8C50 - Indicated RPM shift point as a function of LOAD.
6A9A  A374DE34            ld    REG_34,$DE[REG_74]	   	; engine load (VE?)
6A9E  EF6BCB              lcall L360C					; Table interpolation routine (R32=Table,R34=InVar,R38=OutVar)
6AA1  643814              add   REG_14,REG_38			; add RPM shift points
6AA4  8BF00CAE            cmp   REG_AE,$0C[REG_F0]		; REG_AE = engine RPM * 4 : ROM $8C0C - SPTRPM
6AA8  D905                jh    L6AAF
6AAA  8814AE              cmp   REG_AE,REG_14			; REG_AE = engine RPM * 4
6AAD  D105                jnh   L6AB4
6AAF  9140EC        L6AAF orb   REG_EC,#$40				; set SLTMR_FLG
6AB2  2007                sjmp  L6ABB
6AB4  71BFEC        L6AB4 andb  REG_EC,#$BF				; clr SLTMR_FLG
6AB7  C772B900            stb   Zero,$B9[REG_72]		; zero $0139 timer - SLTMR
6ABB  3FA11B        L6ABB jbs   REG_A1,BIT_07,L6AD9		; jump if CRANKING
6ABE  8BF00EAE            cmp   REG_AE,$0E[REG_F0]		; REG_AE = engine RPM * 4
6AC2  D910                jh    L6AD4
6AC4  B372B930            ldb   REG_30,$B9[REG_72]		; $0139 Shift Light Timer
6AC8  9BF01030            cmpb  REG_30,$10[REG_F0]
6ACC  D10B                jnh   L6AD9
6ACE  9BF01130            cmpb  REG_30,$11[REG_F0]
6AD2  D905                jh    L6AD9
6AD4  910447        L6AD4 orb   REG_47,#$04				; REG_47 bit 2 ON Shift Light
6AD7  2003                sjmp  L6ADC
6AD9  71FB47        L6AD9 andb  REG_47,#$FB				; REG_47 bit 2 OFF Shift Light
6ADC  F0            L6ADC ret
;
;*****************************************************************
; Cycling Routine at 2151, routine offset $48
;*****************************************************************
;
6ADD  9BF66600      L6ADD cmpb  Zero,$66[REG_F6]		; ROM $940E - HPACL
6AE1  DF25                je    L6B08					; return if no Thermactor present
6AE3  3FA10A              jbs   REG_A1,BIT_07,L6AF0		; jump if CRANKING
6AE6  A374D430            ld    REG_30,$D4[REG_74]		; $0252 ARCHG = Air Charge Mass inducted per Intake Stroke, lbm/Intake.
6AEA  8BF66830            cmp   REG_30,$68[REG_F6]
6AEE  DB10                jc    L6B00
6AF0  A3012601      L6AF0 ld    REG_30,$0126[Zero]		; $0126 - Filtered TP
      30
6AF5  67F66A30            add   REG_30,$6A[REG_F6]		; ROM $9412 - SHKTP
6AF9  DB0A                jc    L6B05
6AFB  8830AA              cmp   REG_AA,REG_30			; REG_AA is Throttle position
6AFE  D305                jnc   L6B05
6B00  911047        L6B00 orb   REG_47,#$10				; REG_47 bit 4 ON (Air management2)
6B03  2003                sjmp  L6B08
6B05  71EF47        L6B05 andb  REG_47,#$EF				; REG_47 bit 4 OFF (Air management2)
6B08  F0            L6B08 ret

6B09  31EB03        L6B09 jbc   REG_EB,BIT_01,L6B0F		; jmp if not SIGPIP
6B0C  3E2E02              jbs   REG_2E,BIT_06,L6B11		; jmp if SYNFLG
6B0F  207D          L6B0F sjmp  L6B8E
6B11  4B76C6BA      L6B11 sub   REG_50,REG_BA,$C6[REG_76]	; REG_BA - PIP time lo 16 bits
      50
6B16  DB02                jc    L6B1A
6B18  0350                neg   REG_50
6B1A  C376C6BA      L6B1A st    REG_BA,$C6[REG_76]		; REG_BA - PIP time lo 16 bits
6B1E  A3F00A54            ld    REG_54,$0A[REG_F0]
6B22  6CBA54              mulu  REG_54,REG_BA			; REG_BA - PIP time lo 16 bits
6B25  885650              cmp   REG_50,REG_56
6B28  DB64                jc    L6B8E
6B2A  4B76BABA            sub   REG_50,REG_BA,$BA[REG_76]	; REG_BA - PIP time lo 16 bits
      50
6B2F  DB02                jc    L6B33
6B31  0350                neg   REG_50
6B33  885650        L6B33 cmp   REG_50,REG_56
6B36  DB56                jc    L6B8E
6B38  A376C250            ld    REG_50,$C2[REG_76]
6B3C  C05450              st    REG_50,REG_54
6B3F  C05850              st    REG_50,REG_58
6B42  6B76C450            sub   REG_50,$C4[REG_76]
6B46  DB02                jc    L6B4A
6B48  0350                neg   REG_50
6B4A  A3F00A56      L6B4A ld    REG_56,$0A[REG_F0]		; ROM $8C0A - SSFCTR
6B4E  6C5654              mulu  REG_54,REG_56
6B51  885650              cmp   REG_50,REG_56
6B54  DB38                jc    L6B8E
6B56  A0BA56              ld    REG_56,REG_BA			; REG_BA - PIP time lo 16 bits
6B59  0154                clr   REG_54
6B5B  0C0254              shrl  REG_54,#$02
6B5E  8C5854              divu  REG_54,REG_58
6B61  DD2B                jv    L6B8E
6B63  A3F20450            ld    REG_50,$04[REG_F2]		; ROM $8E5E - FKSKAY
6B67  6C5054              mulu  REG_54,REG_50
6B6A  0350                neg   REG_50
6B6C  A376C052            ld    REG_52,$C0[REG_76]
6B70  6C5250              mulu  REG_50,REG_52
6B73  645256              add   REG_56,REG_52
6B76  8BF20656            cmp   REG_56,$06[REG_F2]		; ROM $8E60 - SIGKLL
6B7A  DB04                jc    L6B80
6B7C  A3F20656            ld    REG_56,$06[REG_F2]		; ROM $8E60 - SIGKLL
6B80  8BF20856      L6B80 cmp   REG_56,$08[REG_F2]		; ROM $8E62 - SIGKLU
6B84  D104                jnh   L6B8A
6B86  A3F20856            ld    REG_56,$08[REG_F2]		; ROM $8E62 - SIGKLU
6B8A  C376C056      L6B8A st    REG_56,$C0[REG_76]
6B8E  9BFE07BD      L6B8E cmpb  REG_BD,$07[REG_FE]		; REG_BD=KAYCTR, ROM $9E5A+7 = 9E61 value = $08=ENGCYL=Number of cylinders per engine revolution
6B92  D10C                jnh   L6BA0
6B94  B101BD              ldb   REG_BD,#$01
6B97  C37422BA            st    REG_BA,$22[REG_74]		; REG_BA - PIP time lo 16 bits
6B9B  C37424BE            st    REG_BE,$24[REG_74]
6B9F  F0                  ret

; calc MKAY

6BA0  17BD          L6BA0 incb  REG_BD						; KAYCTR =  = A counter to indicate how often to update MKAY (MKAY = Half period multiplier to correct for average error caused by hall effect sensor in distributor and armature)
6BA2  9BFE07BD            cmpb  REG_BD,$07[REG_FE]			; ROM $9E5A+7 = 9E61 value = $08=ENGCYL=Number of cylinders per engine revolution
6BA6  D16B                jnh   L6C13
6BA8  39EB68              jbs   REG_EB,BIT_01,L6C13			; SIGPIP =  = A flag that indicates that signature PIP half period has been identified
6BAB  4B7422BA50          sub   REG_50,REG_BA,$22[REG_74]	; REG_BA - PIP time lo 16 bits
6BB0  DB02                jc    L6BB4
6BB2  0350                neg   REG_50						; FGTMP0L = ???
6BB4  A3F00A52      L6BB4 ld    REG_52,$0A[REG_F0]			; $8C0A = SSFCTR = Steady state factor for MKAY and signature KAY calculations
6BB8  4C52BA54      L6BB8 mulu  REG_54,REG_BA,REG_52		; REG_BA - PIP time lo 16 bits
6BBC  885650              cmp   REG_50,REG_56
6BBF  D952                jh    L6C13
6BC1  4B7424BE50          sub   REG_50,REG_BE,$24[REG_74]	; $02A2 = HFPCYC = Period from PIP up to down-edge ENGCYL * 2 cylinders previous
6BC6  DB02                jc    L6BCA
6BC8  0350                neg   REG_50
6BCA  4C52BE54      L6BCA mulu  REG_54,REG_BE,REG_52		; REG_BE = HFDLTA = Latest elapsed time from PIP_UP_EDGE to PIP_DOWN_EDGE, clock ticks
6BCE  885650              cmp   REG_50,REG_56
6BD1  D940                jh    L6C13
6BD3  0154                clr   REG_54
6BD5  477422BA            add   REG_56,REG_BA,$22[REG_74]	; REG_BA - PIP time lo 16 bits
      56
6BDA  DB37                jc    L6C13
6BDC  0C0254              shrl  REG_54,#$02
6BDF  477424BE            add   REG_50,REG_BE,$24[REG_74]	; $02A2 = HFPCYC = Period from PIP up to down-edge ENGCYL * 2 cylinders previous
      50
6BE4  DB2D                jc    L6C13
6BE6  8C5054              divu  REG_54,REG_50
6BE9  DD28                jv    L6C13
6BEB  89999954            cmp   REG_54,#$9999
6BEF  DB22                jc    L6C13
6BF1  4D00E0C0            mulu  REG_50,REG_C0,#$E000
      50
6BF6  6D002054            mulu  REG_54,#$2000
6BFA  445256C0            add   REG_C0,REG_56,REG_52
6BFE  893373C0            cmp   REG_C0,#$7333				; MKAY - Half period multiplier to correct for average error caused by Hall effect sensor in distributor and armature
6C02  DB05                jc    L6C09
6C04  A13373C0            ld    REG_C0,#$7333				; MKAY - Half period multiplier
6C08  F0                  ret

6C09  89CD8CC0      L6C09 cmp   REG_C0,#$8CCD				; MKAY - Half period multiplier
6C0D  D104                jnh   L6C13
6C0F  A1CD8CC0            ld    REG_C0,#$8CCD				; MKAY - Half period multiplier
6C13  F0            L6C13 ret

6C14  A0BE54        L6C14 ld    REG_54,REG_BE				; HFDLTA
6C17  6CC054              mulu  REG_54,REG_C0				; MKAY
6C1A  994057              cmpb  REG_57,#$40
6C1D  D302                jnc   L6C21
6C1F  206D          L6C1F sjmp  L6C8E
6C21  0D0254        L6C21 shll  REG_54,#$02
6C24  4856BA50            sub   REG_50,REG_BA,REG_56		; REG_BA - PIP time lo 16 bits
6C28  DB02                jc    L6C2C
6C2A  0350                neg   REG_50
6C2C  A376BA54      L6C2C ld    REG_54,$BA[REG_76]			; $334 - DT23S = Previous PIP period before DT12S
6C30  6B76BC54            sub   REG_54,$BC[REG_76]			; $336 - PHFDLT = Previous time elapsed between up-edge to down-edge of PIP
6C34  6CBE54              mulu  REG_54,REG_BE
6C37  8F76BC54            divu  REG_54,$BC[REG_76]			; $336 - PHFDLT = Previous time elapsed between up-edge to down-edge of PIP
6C3B  DD51                jv    L6C8E
6C3D  64BE54              add   REG_54,REG_BE
6C40  DB4C                jc    L6C8E
6C42  4854BA52            sub   REG_52,REG_BA,REG_54
6C46  DB02                jc    L6C4A
6C48  0352                neg   REG_52
6C4A  B376BE54      L6C4A ldb   REG_54,$BE[REG_76]			; $0338 - TL0FLG = Transient Spark calculation flag
6C4E  1156                clrb  REG_56
6C50  885250              cmp   REG_50,REG_52
6C53  D91B                jh    L6C70
6C58  B376BF56            ldb   REG_56,$BF[REG_76]			; DIFCTR = Counter for TL0FLG state changes
6C5C  1756                incb  REG_56
6C5E  D302                jnc   L6C62
6C60  1556                decb  REG_56
6C62  C776BF56      L6C62 stb   REG_56,$BF[REG_76]			; DIFCTR = Counter for TL0FLG state changes
6C66  9BFE1456            cmpb  REG_56,$14[REG_FE]			; DFMIN0 = Minimum number of TS0FLG 1 to 0 state changes
6C6A  D322                jnc   L6C8E
6C6C  1154                clrb  REG_54
6C6E  201A                sjmp  L6C8A
6C70  3F540A        L6C70 jbs   REG_54,BIT_07,L6C7D
6C73  B376BF56            ldb   REG_56,$BF[REG_76]			; DIFCTR = Counter for TL0FLG state changes
6C77  1756                incb  REG_56
6C79  D302                jnc   L6C7D
6C7B  1556                decb  REG_56
6C7D  C776BF56      L6C7D stb   REG_56,$BF[REG_76]			; DIFCTR = Counter for TL0FLG state changes
6C81  9BFE1556            cmpb  REG_56,$15[REG_FE]			; ROM $9E6F - DFMIN1 = Minimum number of TS0FLG 0 to 1 state changes.
6C85  D307                jnc   L6C8E
6C87  B18054              ldb   REG_54,#$80
6C8A  C776BE54      L6C8A stb   REG_54,$BE[REG_76]			; $0338 - TL0FLG = Transient Spark calculation flag
6C8E  F0            L6C8E ret

;*****************************************************************
; handle HSI line 1 data - Knock sensor
;*****************************************************************
6C8F  71FD87        L6C8F andb  REG_87,#$FD				; mask HSI data
6C92  9BF84A00            cmpb  Zero,$4A[REG_F8]		; ROM $947A KIHP = 00 ( is there a knock sensor )
6C96  DF06                je    L6C9E					; jump if line data = 0
6C98  91084F              orb   REG_4F,#$08				; set KNOCK_DETECTED 
6C9B  9108D9              orb   REG_D9,#$08				; set VIP_KNOCK
6C9E  F0            L6C9E ret

;*****************************************************************
; check for Knock
6C9F  9BF84A00            cmpb  Zero,$4A[REG_F8]		; ROM $947A KIHP = 00 ( is there a knock sensor )
6CA3  D701                jne   L6CA6
6CA5  F0                  ret

6CA6  8BF844AE      L6CA6 cmp   REG_AE,$44[REG_F8]		; REG_AE = engine RPM * 4 : ROM $9474 - RPMCNL
6CAA  D112                jnh   L6CBE					; jmp if N <= RPMCNL
6CAC  9BF849DD            cmpb  REG_DD,$49[REG_F8]		; KWCTR : ROM $9479 - WINCLD
6CB0  DB0C                jc    L6CBE					; jmp if KWCTR >= WINCLD
6CB2  334F03              jbc   REG_4F,BIT_03,L6CB8		; jmp if not KNOCK_DETECTED
6CB5  17DD                incb  REG_DD					; KWCTR
6CB7  F0                  ret

6CB8  31EB03        L6CB8 jbc   REG_EB,BIT_01,L6CBE		; SIGPIP
6CBB  17DD                incb  REG_DD					; KWCTR
6CBD  F0                  ret

6CBE  11DD          L6CBE clrb  REG_DD					; KWCTR
6CC0  A122037E            ld    REG_7E,#$0322			; QUEUE_9
6CC4  9B7E0100            cmpb  Zero,$01[REG_7E]		; $0323 = QUEUE_9[1]
6CC8  DF04                je    L6CCE
6CCA  91024E              orb   REG_4E,#$02				; set KTS_PENDING (0000 0010)
6CCD  F0                  ret

6CCE  2815          L6CCE scall L6CE5
6CD0  A1862292            ld    REG_92,#$2286			; ROM KNOCK and SPOUT PWN timing tables
6CD4  EF22B8              lcall L24F9
6CD7  F0                  ret

; $2284 proc address
6CD8  394E07        L6CD8 jbs   REG_4E,BIT_01,L6CE2		; KTS_PENDING flag
6CDB  C77E0100            stb   Zero,$01[REG_7E]
6CDF  CC00                pop   Zero
6CE1  F0                  ret

6CE2  71FD4E        L6CE2 andb  REG_4E,#$FD				; clr REG_4E bit 1 KTS_PENDING
6CE5  4CC0BE50      L6CE5 mulu  REG_50,REG_BE,REG_C0
6CE9  994053              cmpb  REG_53,#$40
6CEC  DB12                jc    L6D00
6CEE  0D0250              shll  REG_50,#$02
6CF1  A05250              ld    REG_50,REG_52
6CF4  6F74A850            mulu  REG_50,$A8[REG_74]		; $226 - WINDOW_BETA = Fraction of PIP period at which to issue knock window
6CF8  3F5305              jbs   REG_53,BIT_07,L6D00
6CFB  0D0150              shll  REG_50,#$01
6CFE  2003                sjmp  L6D03
6D00  BDFF52        L6D00 ldbse REG_52,#$FF
6D03  4774505280    L6D03 add   REG_80,REG_52,$50[REG_74] ; $50[REG_74] - last saved PIP IO event time lo 16 bits
6D08  B3745282            ldb   REG_82,$52[REG_74]		; $52[REG_74] - last saved PIP IO event time hi 8 bits

6D0C  B40082        L6D0C addcb REG_82,Zero
6D0F  F8                  clrc
6D10  F0                  ret

; Add $AA[REG_74] time to $02C5 entry 24 bit time
6D11  6774AA80      L6D11 add   REG_80,$AA[REG_74]		; WINDOW_DELTA = Knock window width, clock ticks
6D15  27F5                sjmp  L6D0C
;
;*****************************************************************
; Cycling Routine at 2151, routine offset $36
;*****************************************************************
;
6D17  3F4E02              jbs   REG_4E,BIT_07,L6D1C		; New PIP received flag
6D1A  208E                sjmp  L6DAA

6D1C  456203F832    L6D1C add   REG_32,REG_F8,#$0362	; TABLE $9792 - unknown function
6D21  A0AE34              ld    REG_34,REG_AE			; REG_AE = engine RPM * 4
6D24  080734              shr   REG_34,#$07				; = RPM / 128
6D27  EF8DC8              lcall L35B7					; Interpolate Single var Table R32-table,R34-in,R38-out
6D2A  090738              shl   REG_38,#$07				; table output * 128
6D2D  67F84038            add   REG_38,$40[REG_F8]		; ROM $9470 - WOPEN
6D31  C374A838            st    REG_38,$A8[REG_74]		; WINDOW BETA

6D35  455403F832          add   REG_32,REG_F8,#$0354	; TABLE $9784 - Variable knock Threshold window open time, msec. Input is Engine speed in RPM; output is fraction of PIP Period.
6D3A  A0AE34              ld    REG_34,REG_AE			; REG_AE = engine RPM * 4
6D3D  080734              shr   REG_34,#$07				; table output * 128
6D40  EF74C8              lcall L35B7					; Interpolate Single var Table R32-table,R34-in,R38-out
6D43  6CBA38              mulu  REG_38,REG_BA			; REG_BA - PIP time lo 16 bits
6D46  0D0638              shll  REG_38,#$06				; multiply by 64
6D49  67F8423A            add   REG_3A,$42[REG_F8]		; ROM $9472 - WINLEN
6D4D  C374AA3A            st    REG_3A,$AA[REG_74]		; $0228 - WINDOW DELTA

6D51  454803F832          add   REG_32,REG_F8,#$0348	; TABLE $9778 - Retard increment versus RPM, deg.
6D56  A0AE34              ld    REG_34,REG_AE			; REG_AE = engine RPM * 4
6D59  080734              shr   REG_34,#$07				; table output * 128
6D5C  EF58C8              lcall L35B7					; Interpolate Single var Table R32-table,R34-in,R38-out
6D5F  C4E238              stb   REG_38,REG_E2			; RET INC

6D62  364F45              jbc   REG_4F,BIT_06,L6DAA		; Knock Enabled
6D65  456C03F832          add   REG_32,REG_F8,#$036C	; TABLE $979C - Spark Advance Rate vs RPM 
6D6A  A0AE34              ld    REG_34,REG_AE			; REG_AE = engine RPM * 4 RPM * 4
6D6D  080734              shr   REG_34,#$07				; RPM / 128
6D70  EF44C8              lcall L35B7					; Interpolate Single var Table R32-table,R34-in,R38-out
6D73  090438              shl   REG_38,#$04				; adv * 16
6D76  8B74A038            cmp   REG_38,$A0[REG_74]		; $021E - timer? TSL ADV
6D7A  D92E                jh    L6DAA
6D7C  A374A03C            ld    REG_3C,$A0[REG_74]		; $021E - timer? TSL ADV
6D80  68383C              sub   REG_3C,REG_38
6D83  C374A03C            st    REG_3C,$A0[REG_74]		; set $021E - timer? TSL ADV

; Advance all cylinders 1 degree of spark
6D87  FA                  di
6D88  FF                  nop
6D89  B10140              ldb   REG_40,#$01				; add 1 degree of advance to each cylinder
6D8C  AD0842              ldbze REG_42,#$08
6D8F  57432B024030  L6D8F addb  REG_30,REG_40,$022B[REG_42]	; $022B - SparkAdvance[ cylinder 1-8 ]
6D95  DD06                jv    L6D9D					; jmp overflow
6D97  9BF83130            cmpb  REG_30,$31[REG_F8]		; ROM $9461 - Advance Limit
6D9B  DA04                jle   L6DA1
6D9D  B3F83130      L6D9D ldb   REG_30,$31[REG_F8]		; ROM $9461 - Advance Limit - set adv for this cyl to max
6DA1  C7432B0230    L6DA1 stb   REG_30,$022B[REG_42]	; $022B - SparkAdvance[ cylinder 1-8 ] new advance for this cyl
6DA6  E042E6              djnz  REG_42,L6D8F			; LOOP

6DA9  FB                  ei

6DAA  EFA7C8        L6DAA lcall L3654				
6DAD  2A02                word  $022A					; Old AD sensor address - filtered TP
6DAF  AA00                word  $00AA					; new AD sensor address = REG_AA -  REG_AA is Throttle position
6DB1  5ED0                word  $D05E					; funny index for difference filter
6DB3  C374AC3E            st    REG_3E,$AC[REG_74] 		; filtered sensor output (22A)

6DB7  A374AC38            ld    REG_38,$AC[REG_74] 		; filtered sensor output (22A)
6DBB  A0AA3A              ld    REG_3A,REG_AA			; REG_AA is Throttle position
6DBE  0C0138              shrl  REG_38,#$01
6DC1  68383A              sub   REG_3A,REG_38
6DC4  C374003A            st    REG_3A,$00[REG_74]		; $27E - TCF
6DC8  98D000              cmpb  Zero,REG_D0				; is throttle partly open?
6DCB  DA0F                jle   L6DDC
6DCD  A3F83414            ld    REG_14,$34[REG_F8]		; ROM $9464 - TIPLOD
6DD1  8B74DE14            cmp   REG_14,$DE[REG_74]	    ; engine load (VE?)
6DD5  D105                jnh   L6DDC
6DD7  91202D              orb   REG_2D,#$20				; set CTFLG
6DDA  2016                sjmp  L6DF2

6DDC  A3F83638      L6DDC ld    REG_38,$36[REG_F8]		; ROM $9466 - TIPHS
6DE0  67F83438            add   REG_38,$34[REG_F8]		; ROM $9464 - TIPLOD
6DE4  D303                jnc   L6DE9
6DE6  BDFF38              ldbse REG_38,#$FF				; clamp max
6DE9  8B74DE38      L6DE9 cmp   REG_38,$DE[REG_74]	    ; engine load (VE?)
6DED  DB03                jc    L6DF2
6DEF  71DF2D              andb  REG_2D,#$DF				; clr CTFLG
6DF2  A3F82E14      L6DF2 ld    REG_14,$2E[REG_F8]		; ROM $945E - KACRAT
6DF6  8B740014            cmp   REG_14,$00[REG_74]		; $27E
6DFA  D211                jgt   L6E0D
6DFC  9BF83DB0            cmpb  REG_B0,$3D[REG_F8]		; Engine Coolant Temperature - degrees F ? : ROM $946D - ECTIP
6E00  DA0B                jle   L6E0D
6E02  8BF83EAE            cmp   REG_AE,$3E[REG_F8]		; REG_AE = engine RPM * 4 : ROM $946E - NTIP
6E06  DB05                jc    L6E0D
6E08  91402D              orb   REG_2D,#$40				; set TIPFLG
6E0B  2003                sjmp  L6E10
6E0D  71BF2D        L6E0D andb  REG_2D,#$BF				; clr TIPFLG
6E10  9BF83CB0      L6E10 cmpb  REG_B0,$3C[REG_F8]		; Engine Coolant Temperature - degrees F ? : ROM $946C - ECTNOK
6E14  DA1D                jle   L6E33
6E16  8BF838AE            cmp   REG_AE,$38[REG_F8]		; REG_AE = engine RPM * 4 : ROM $9468 - RPMMIN
6E1A  D117                jnh   L6E33
6E1C  A3F83A14            ld    REG_14,$3A[REG_F8]		; ROM $946A - LODNOK
6E20  B3F84A42            ldb   REG_42,$4A[REG_F8]		; ROM $947A KIHP = 00 ( is there a knock sensor )
6E24  8B74DE14            cmp   REG_14,$DE[REG_74]	    ; engine load (VE?)
6E28  DB09                jc    L6E33
6E2A  984200              cmpb  Zero,REG_42
6E2D  DB04                jc    L6E33
6E2F  91404F              orb   REG_4F,#$40				; set Knock Enabled
6E32  F0                  ret

6E33  364F12        L6E33 jbc   REG_4F,BIT_06,L6E48		; jmp if not Knock Enabled Flag - return
6E36  71BF4F              andb  REG_4F,#$BF				; clr Knock Enabled Flag
6E39  AD0842              ldbze REG_42,#$08
6E3C  C7432B0200    L6E3C stb   Zero,$022B[REG_42]		; clr SparkAdvance[ cylinder 1-8 ]
6E41  E042F8              djnz  REG_42,L6E3C

6E44  C374A000            st    Zero,$A0[REG_74]		; zero $021E - timer? TSL ADV
6E48  F0            L6E48 ret

;
;*****************************************************************
; Cycling Routine at 2151, routine offset $4E
;
; self test stuff
; There are 4 proc tables BASE A - BASE D - how do these correspond to 
;   Key On Engine Off, Engine Running, Continuous tests
;
;*****************************************************************
;
6E49  71FED9        L6E49 andb  REG_D9,#$FE				; clear VIP FP override
6E4C  2A48                scall L7096					; Set up EGR flags
6E4E  71F72C              andb  REG_2C,#$F7				; REG_2C bit 3 off - WIG? flag
6E51  3A2A0C              jbs   REG_2A,BIT_02,L6E60		; jump if VIP_mode_flag : VIP enable is set
6E54  A372B442            ld    REG_42,$B4[REG_72]		; $0134 - PUTMR - Time since CPU power-up - word (msec)
6E58  991043              cmpb  REG_43,#$10				; compare whole seconds 16
6E5B  D303                jnc   L6E60					; jmp if timer < $1000 msec = 4096 msec ~ 4 seconds
6E5D  91042A              orb   REG_2A,#$04				; set VIP_mode_flag : VIP enable

6E60  362A14        L6E60 jbc   REG_2A,BIT_06,L6E77		; jump if not VIP_mode_flag : NO_START
6E63  352B05              jbc   REG_2B,BIT_05,L6E6B		; jump if STI input is low - EEC reset
6E66  37A10B              jbc   REG_A1,BIT_07,L6E74		; jump if not CRANKING - EEC reset
6E69  20A7                sjmp  L6F12					; push proc B and execute it (ENTER ENGINE OFF TEST?)

; EEC reset!
6E6B  3BD603        L6E6B jbs   REG_D6,BIT_03,L6E71		; STO something STO_WORKING?
6E6E  322B03              jbc   REG_2B,BIT_02,L6E74		; jump if Self Test Output trigger clear
6E71  EF2C09        L6E71 lcall L77A0					; clear table $07C4 to $07D9
6E74  E7C915        L6E74 ljmp  L8440					; reboot system!!!!!

6E77  352A1E        L6E77 jbc   REG_2A,BIT_05,L6E98		; jump if normal strategy - not self test mode
6E7A  352BF7              jbc   REG_2B,BIT_05,L6E74		; jump if STI input is low - EEC reset
6E7D  B3FE0242            ldb   REG_42,$02[REG_FE]		; ROM $9E5C TRLOAD Transmission Load switch.(transmission type)
6E81  990342              cmpb  REG_42,#$03				; 3 = Manual Transmission, both clutch and gear switches.
6E84  D308                jnc   L6E8E
6E86  990442              cmpb  REG_42,#$04				; 4 = Auto Transmission, non-electronic, neutral drive switch.
6E89  D903                jh    L6E8E
6E8B  3FE7E6              jbs   REG_E7,BIT_07,L6E74		; NDS flag - Neutral/Drive Flag, 1 = Drive. - jmp to EEC reset
6E8E  36E605        L6E8E jbc   REG_E6,BIT_06,L6E96		; Pressure Feedback EGR HP flag?
6E91  EF4309              lcall L77D7					; use mangled filter at $00CA[REG_78] use blend $0116(EVP) to $0380
6E94  80                  byte  $80
6E95  03                  byte  $03
6E96  206D          L6E96 sjmp  L6F05

6E98  302A1A        L6E98 jbc   REG_2A,BIT_00,L6EB5		; jump if not VIP_mode_flag : VSCDT
6E9B  352B12              jbc   REG_2B,BIT_05,L6EB0		; jump if STI input is low
6E9E  B3733D0142          ldb   REG_42,$013D[REG_72]	; $02BD - Vehicle speed, MPH
6EA3  990442              cmpb  REG_42,#$04
6EA6  D908                jh    L6EB0					; jump if Vehicle speed > 4 MPH
6EA8  37A005              jbc   REG_A0,BIT_07,L6EB0		; SCCS on (Cruise Control)
6EAB  3DA002              jbs   REG_A0,BIT_05,L6EB0		; SCCS brake (cruise control)
6EAE  2091                sjmp  L6F41					; VSCDT? push proc D and execute it

6EB0  91202A        L6EB0 orb   REG_2A,#$20				; set (VIP_mode_flag : )running self tests
6EB3  27BF                sjmp  L6E74					; EEC reset

6EB5  312A08        L6EB5 jbc   REG_2A,BIT_01,L6EC0		; jump if not VIP_mode_flag : VSCST
6EB8  3D2BB9              jbs   REG_2B,BIT_05,L6E74		; jump if STI input is high to EEC reset
6EBB  37A1B6              jbc   REG_A1,BIT_07,L6E74		; jump if not CRANKING to EEC reset
6EBE  207A                sjmp  L6F3A					; VSCST? push proc C and execute it(STI low and engine off or starting)

6EC0  3FA149        L6EC0 jbs   REG_A1,BIT_07,L6F0C		; jump if CRANKING
6EC3  3AA103              jbs   REG_A1,BIT_02,L6EC9		; jump if underspeed/cranking - UNDSP = Run/Underspeed Flag.  (1 = Underspeed (or CRANK), 0 = Run)
6EC6  3D2B02              jbs   REG_2B,BIT_05,L6ECB		; jump if STI input is high
6EC9  2082          L6EC9 sjmp  L6F4D

6ECB  B3724842      L6ECB ldb   REG_42,$48[REG_72]		; $01C8 timer - STI input line low timer (1/8sec)
6ECF  990842              cmpb  REG_42,#$08				; 1 second
6ED2  D379                jnc   L6F4D					; jmp if STI low timer < 1 second
6ED4  322A76              jbc   REG_2A,BIT_02,L6F4D		; jump if not VIP_mode_flag : VIP enable
6ED7  A372B442            ld    REG_42,$B4[REG_72]		; $0134 - PUTMR - Counts up after hardware reset
6EDB  991843              cmpb  REG_43,#$18				; compare whole seconds $1800 msec (1/1024) = 6 seconds
6EDE  D36D                jnc   L6F4D					; jmp if timer < 6 sec
6EE0  B378C742            ldb   REG_42,$C7[REG_78]
6EE4  990242              cmpb  REG_42,#$02
6EE7  D716                jne   L6EFF
6EE9  37A013              jbc   REG_A0,BIT_07,L6EFF		; SCCS on (Cruise Control)
6EEC  3F2A10              jbs   REG_2A,BIT_07,L6EFF		; jump if VIP_mode_flag : disable VSCDT set
6EEF  A372B442            ld    REG_42,$B4[REG_72]		; $0134 - PUTMR - Counts up after hardware reset
6EF3  9B79F20043          cmpb  REG_43,$00F2[REG_78]	; compare whole seconds
6EF8  DB05                jc    L6EFF					; jmp if timer >= VVSCET???
6EFA  91092A              orb   REG_2A,#$09				; VIP mode flag : set VSCDT and DISABLE_RUNNING
6EFD  2042                sjmp  L6F41					; jmp to BASE D procs

6EFF  3B2A48        L6EFF jbs   REG_2A,BIT_03,L6F4A		; jump if VIP_mode_flag : disable running set

; ENTER DYNAMIC TEST
6F02  91A02A              orb   REG_2A,#$A0				; Set VIP_mode_flag : disable no start and disable VSCDT
6F05  2847                scall L6F4E
6F07  CB3B7E71            push  $717E[REG_3A]		; @@@@ BASE A - computed jump
6F0B  F0                  ret

6F0C  352B0A        L6F0C jbc   REG_2B,BIT_05,L6F19		; jump if STI input is low
6F0F  3C2A38              jbs   REG_2A,BIT_04,L6F4A		; jump VIP_mode_flag : disable no start

; ENTER ENGINE OFF TEST?
6F12  283A          L6F12 scall L6F4E
6F14  CB3B6871            push  $7168[REG_3A]		; @@@@ BASE B - push self test function proc ?
6F18  F0                  ret							; test code - KOEO self test and others?

6F19  B378C742      L6F19 ldb   REG_42,$C7[REG_78]
6F1D  990242              cmpb  REG_42,#$02
6F20  D72B                jne   L6F4D					; return 
6F22  37A028              jbc   REG_A0,BIT_07,L6F4D		; if SCCS ON state - return  (exit if cruise control is ON)
6F25  A372B442            ld    REG_42,$B4[REG_72]		; $0134 - PUTMR - Counts up after hardware reset (msec)
6F29  992843              cmpb  REG_43,#$28				; compare msec - $2800 * 1/1024 = 10 seconds
6F2C  DB1F                jc    L6F4D					; if Eng Runnung Timer >= 10seconds then return 
6F2E  A372BE42            ld    REG_42,$BE[REG_72]		; $013E - timer? time since last PIP recieved (msec)
6F32  990443              cmpb  REG_43,#$04				; $0400 msec(1/1024) seconds ~ 1 second
6F35  D116                jnh   L6F4D					; if time since PIP <= 1 sec then return 
6F37  91022A              orb   REG_2A,#$02				; Set VIP_mode_flag : VSCST

; ENGINE OFF VCS TEST?
6F3A  2812          L6F3A scall L6F4E
6F3C  CB3BC871            push  $71C8[REG_3A]		; @@@@ BASE C - computed jump in $7000 area
6F40  F0                  ret							; run the test routine

; ENTER ENGINE RUNNING TEST
6F41  280B          L6F41 scall L6F4E
6F43  CB3BD671            push  $71D6[REG_3A]		; @@@@ BASE D - computed jump in $7000 area
6F47  F0                  ret							; run the test routine
		
; computed diagnostic calls return here
6F48  212B          L6F48 sjmp  L7075					; Save diagnostic testing registers 

6F4A  91082C        L6F4A orb   REG_2C,#$08				; WIG flag???
6F4D  F0            L6F4D ret

; gets jump function index int REG_3A
6F4E  2900          L6F4E scall L7050					; load diagnostic testing registers
6F50  AC383A              ldbze REG_3A,REG_38			; function address index
6F53  09013A              shl   REG_3A,#$01				; X 2 - make into word index
6F56  CC42                pop   REG_42					; return address
6F58  C9486F              push  #$6F48					; add a return address to stack (L7075 - SAVE SFR SET ) $57[REG_72] = REG_38
6F5B  880040              cmp   REG_40,Zero				; Zero 1st time only, This is return address of call @7026
6F5E  DF02                je    L6F62					; jump if first time thru here
6F60  20DA                sjmp  L703C					; return to 1st or 3rd caller
	
6F62  C842          L6F62 push  REG_42					; restore return address
6F64  F0                  ret
;
; Diagnostic Proc table A
;
6F65  A11055D4      L6F65 ld    REG_D4,#$5510			; Diagn Proc table A proc #2
6F69  7BFE07D4            subb  REG_D4,$07[REG_FE]		; ROM $9E5A+7 = 9E61 value = $08=ENGCYL=Number of cylinders per engine revolution
6F6D  08D4D4              shr   REG_D4,REG_D4
6F70  2808                scall L6F7A					; call ?
6F72  206F                sjmp  L6FE3

6F74  AD02D4        L6F74 ldbze REG_D4,#$02
 
6F77  9102D9        L6F77 orb   REG_D9,#$02
6F7A  9104D9        L6F7A orb   REG_D9,#$04				; set REG_D9 bit 2 ONEDIGIT_OUT
6F7D  28A7                scall L7026					; call ?
6F7F  71FBD9              andb  REG_D9,#$FB				; clr REG_D9 bit 2 ONEDIGIT_OUT
6F82  F0                  ret
;
;********************************************************************
; Diagnostic proc table A
; sensor error stack processing - dump out errors?
;
6F83  B11019              ldb   REG_19,#$10
6F86  983000              cmpb  Zero,REG_30			; is error stack empty?
6F89  D704                jne   L6F8F
;
; EEC trouble code : 11 - System PASS
;
6F8B  EF200C              lcall L7BAE				; push error $11 to $0342 error stack
6F8E  11                  byte  $11					; Trouble Code : System PASS (no errors)

6F8F  EF1C0C        L6F8F lcall L7BAE				; push error $00 (end of errors?)  to $0342 error stack
6F92  00                  byte  $00

6F93  A1420330      L6F93 ld    REG_30,#$0342		; top of big loop - $0342 is base of Hard Trouble Code Error Table
6F97  AE3132        L6F97 ldbze REG_32,[REG_30]+	; top of small loop - load next trouble code byte into word REG_32
6F9A  980032              cmpb  REG_32,Zero
6F9D  DF08                je    L6FA7				; zero is end of error codes?
6F9F  2845                scall L6FE6				; call this for every error in the Hard Error stack
6FA1  89550330            cmp   REG_30,#$0355		; $0342 + $13
6FA5  D3F0                jnc   L6F97				; loop back small
; end of error codes stack
6FA7  30D615        L6FA7 jbc   REG_D6,BIT_00,L6FBF ; HIGH_SPEED
6FAA  34D905              jbc   REG_D9,BIT_04,L6FB2 ; KAM_CODES
6FAD  B10433              ldb   REG_33,#$04
6FB0  2106                sjmp  L70B8

6FB2  2867          L6FB2 scall L701B				; ???
6FB4  71FED6              andb  REG_D6,#$FE			; REG_D6 bit 0 off - HIGH_SPEED
6FB7  32D624              jbc   REG_D6,BIT_02,L6FDE ; LOW_SPEED
6FBA  B10819              ldb   REG_19,#$08
6FBD  27D4                sjmp  L6F93				; loop back big

6FBF  32D60E        L6FBF jbc   REG_D6,BIT_02,L6FD0 ; LOW_SPEED
6FC2  71FBD6              andb  REG_D6,#$FB			; CLR REG_D6 bit 2 - LOW_SPEED
6FC5  362A03              jbc   REG_2A,BIT_06,L6FCB	; jump if not VIP_mode_flag : no start
6FC8  9110D9              orb   REG_D9,#$10			; set KAM_CODES
6FCB  31D610        L6FCB jbc   REG_D6,BIT_01,L6FDE	; LOW_SPEED_REPEAT
6FCE  27C3                sjmp  L6F93				; loop back big

6FD0  31D613        L6FD0 jbc   REG_D6,BIT_01,L6FE6	; LOW_SPEED_REPEAT
6FD3  34D908              jbc   REG_D9,BIT_04,L6FDE	; KAM_CODES
6FD6  9104D6              orb   REG_D6,#$04			; LOW_SPEED
6FD9  B10A33              ldb   REG_33,#$0A
6FDC  20DA                sjmp  L70B8
6FDE  71FDD6        L6FDE andb  REG_D6,#$FD			; clr REG_D6 bit 1 LOW_SPEED_REPEAT
6FE1  2838                scall L701B				; ???
6FE3  E7280F        L6FE3 ljmp  L7F0E				; incr REG_38, zero $1CA timer, return
;
;*******************************************************
; ???DUMPS OUT HARD ERROR CODES???
; 
; REG_32 byte has trouble code - called for every trouble code in 342 stack
;
6FE6  090432        L6FE6 shl   REG_32,#$04			; error code x 16 (left one hex digit)

6FE9  1733          L6FE9 incb  REG_33
6FEB  2004                sjmp  L6FF1

6FED  2820          L6FED scall L700F				; execute this loop error code X 16 + 1? times
6FEF  2821                scall L7012
6FF1  E033F9        L6FF1 djnz  REG_33,L6FED		; LOOP

6FF4  B10333              ldb   REG_33,#$03

6FF7  2819          L6FF7 scall L7012
6FF9  E033FB              djnz  REG_33,L6FF7		; LOOP

6FFC  383207              jbs   REG_32,BIT_00,L7006
6FFF  090432              shl   REG_32,#$04			; REG_32 << 4 (one hex digit)
7002  1732                incb  REG_32
7004  27E3                sjmp  L6FE9				; LOOP

7006  B10433        L7006 ldb   REG_33,#$04

7009  2807          L7009 scall L7012
700B  E033FB              djnz  REG_33,L7009		; LOOP
700E  F0                  ret
;
;*******************************************************
; shift D4 right 16 times or until REG_19 == 0
; entry point 1
700F  9180D5        L700F orb   REG_D5,#$80			; set bit 15 in REG_D4 word

; entry point 2
7012  E01902        L7012 djnz  REG_19,L7017
7015  200F                sjmp  L7026				; what is this?

7017  0801D4        L7017 shr   REG_D4,#$01			; REG_D4 word  >> 1
701A  F0                  ret
;
;*******************************************************
;
701B  3C1907        L701B jbs   REG_19,BIT_04,L7025		; return
701E  1519                decb  REG_19
7020  0819D4              shr   REG_D4,REG_19
7023  2801                scall L7026					; what is this?
7025  F0            L7025 ret
;
;*******************************************************
;
7026  CC40          L7026 pop   REG_40					; save caller1
7028  CC14                pop   REG_14					; save caller2

702A  71EFD6              andb  REG_D6,#$EF				; REG_D6 bit 4 = 0 (STO fast codes)
702D  30D603              jbc   REG_D6,BIT_00,L7033		; jump if STO high speed
7030  9110D6              orb   REG_D6,#$10				; REG_D6 bit 4 = 1 (STO fast codes)

7033  B11019        L7033 ldb   REG_19,#$10
7036  9120D6              orb   REG_D6,#$20				; STO_CODE?
7039  91042B              orb   REG_2B,#$04				; set Self Test Output trigger

703C  3A2B10        L703C jbs   REG_2B,BIT_02,L704F		; jump if Self Test Output trigger set - returns back skipping 2 callers
703F  32D903              jbc   REG_D9,BIT_02,L7045		; jump on one digit out
7042  3BD60A              jbs   REG_D6,BIT_03,L704F		; returns back skipping 2 callers if STO working

7045  C814          L7045 push  REG_14					; restore caller2
7047  C840                push  REG_40					; restore caller2
7049  0140                clr   REG_40
704B  2828                scall L7075					; Save diagnostic testing registers
704D  01D4                clr   REG_D4
704F  F0            L704F ret
;
;*************************************************************
;
; Things like continious tests require preserving registers
; Here we retore the registers we used
; load diagnostic testing registers
7050  A3725030      L7050 ld    REG_30,$50[REG_72]		; 0030 = 01D0 W - CODE_CNT_EX
7054  A3725A32            ld    REG_32,$5A[REG_72]		; 0032 = 01DA W - CODE_ONES_EX
7058  A3726234            ld    REG_34,$62[REG_72]		; 0034 = 01E2 W - VIP_NRM_EX
705C  A3726436            ld    REG_36,$64[REG_72]		; 0036 = 01E4 W - VIP_NRM2_EX
7060  B3725738            ldb   REG_38,$57[REG_72]		; 0038 = 01D7 B - VIP_CNT_EX - this is the function number to run
7064  A3725240            ld    REG_40,$52[REG_72]		; 0040 = 01D2 W - VIP_STACK_EX
7068  A3725414            ld    REG_14,$54[REG_72]		; 0014 = 01D4 W - VIP_STACK_X2

706C  B3724A18            ldb   REG_18,$4A[REG_72]		; 0018 = 01CA B - VIP_TIMER_EX timer! <<<< NO REVERSE OPERATION

7070  B3726619            ldb   REG_19,$66[REG_72]		; 0019 = 01E6 B - SHIFT_CNT_EX
7074  F0                  ret
;
; Here we save the registers we use for testing
; Save diagnostic testing registers
7075  C3725030      L7075 st    REG_30,$50[REG_72]		; 01D0 = 0030
7079  C3725A32            st    REG_32,$5A[REG_72]		; 01DA = 0032
707D  C3726234            st    REG_34,$62[REG_72]		; 01E2 = 0034
7081  C3726436            st    REG_36,$64[REG_72]		; 01E4 = 0036
7085  C7725738            stb   REG_38,$57[REG_72]		; 01D7 = 0038
7089  C3725240            st    REG_40,$52[REG_72]		; 01D2 = 0040
708D  C3725414            st    REG_14,$54[REG_72]		; 01D4 = 0014

7091  C7726619            stb   REG_19,$66[REG_72]		; 01E6 = 0019
7095  F0                  ret

;**********************************************************
; change flag bit 6 in REG_D9 and REG_E6 based on ROM $97D9(EGR_Type) = egr_type ( 0=sonic, 1=PFE, 2=none)
;
; Since ROM does not change this proc ALWAYS clr both bit 6 flags
;
; resets REG_72 = $0180 and sets REG_78 = $8EDA 
;
; Set up EGR flags
;
7096  458000F278    L7096 add   REG_78,REG_F2,#$0080; ROM $8EDA
709B  A1800172            ld    REG_72,#$0180		; why does this REG need resetting at all ? strange!
709F  B3FA3142            ldb   REG_42,$31[REG_FA]	; ROM $97D9 EGR_Type - CONTENTS = 0 - egr_type ( 0=sonic, 1=PFE, 2=none)

; If ROM $97D9(EGR_Type) = 2 then set bit 6 in REG_D9 else clear the bit
70A3  71BFD9              andb  REG_D9,#$BF			; clr bit 6 (EGR something)
70A6  990242              cmpb  REG_42,#$02			; compare EGR type to none
70A9  D703                jne   L70AE				; branch ALWAYS in this ROM 
70AB  9140D9              orb   REG_D9,#$40			; set bit 6 EGR? - never happens

; If ROM $97D9(EGR_Type) = 1 then set bit 6 in REG_E6 else clear the bit
70AE  71BFE6        L70AE andb  REG_E6,#$BF			; clr bit 6
70B1  E04203              djnz  REG_42,L70B7		; compare to 1 jump ALWAYS in this ROM
70B4  9140E6              orb   REG_E6,#$40			; set bit 6 - never happens

70B7  F0            L70B7 ret
;**********************************************************
70B8  2F4F          L70B8 scall L7009
70BA  AD1032              ldbze REG_32,#$10
70BD  2F27                scall L6FE6				; process? a trouble code? 10 = ?
70BF  285C          L70BF scall L711D				; load ptr REG_30 to end of trouble code stack
70C1  30D63F              jbc   REG_D6,BIT_00,L7103	; Low Speed Repeat
70C4  AD1532              ldbze REG_32,#$15
70C7  C23032              st    REG_32,[REG_30]		; REG_30 = #$356 WORD!
70CA  3ED836              jbs   REG_D8,BIT_06,L7103 ; VIP_KAM

70CD  AD1132              ldbze REG_32,#$11
70D0  C23032              st    REG_32,[REG_30]		; save start code???

70D3  011A                clr   REG_1A
70D5  A1C4071C            ld    REG_1C,#$07C4		; what is this table? - KAMINDEXLow

70D9  B1081E        L70D9 ldb   REG_1E,#$08
70DC  B21D34              ldb   REG_34,[REG_1C]+	; take next value from 7C4 table

70DF  071A          L70DF inc   REG_1A
70E1  8925001A            cmp   REG_1A,#$0025		; loop for $25 entries (37)
70E5  D918                jh    L70FF
70E7  190134              shlb  REG_34,#$01			; << 1
70EA  D30E                jnc   L70FA				; was bit bit set?
70EC  571B4271            addb  REG_1F,Zero,$7142[REG_1A]	; table (index starts at 1 not zero)
      001F
70F2  DF06                je    L70FA				; skip zeros - continue
70F4  C6311F              stb   REG_1F,[REG_30]+	; write to 356+
70F7  C63000              stb   Zero,[REG_30]		; mark as end in case we exit?
70FA  E01EE2        L70FA djnz  REG_1E,L70DF		; loop

70FD  27DA                sjmp  L70D9				; loop
	
70FF  281C          L70FF scall L711D				; sort ptr to $0356
7101  281F                scall L7122				; sort $0356 table of bytes

7103  56310032      L7103 addb  REG_32,Zero,[REG_30]+
7107  DF04                je    L710D
7109  2EDB                scall L6FE6
710B  27F6                sjmp  L7103

710D  38D608        L710D jbs   REG_D6,BIT_00,L7118
7110  32D605              jbc   REG_D6,BIT_02,L7118
7113  71FBD6              andb  REG_D6,#$FB
7116  27A7                sjmp  L70BF

7118  71EFD9        L7118 andb  REG_D9,#$EF
711B  2695                sjmp  L6FB2

711D  A1560330      L711D ld    REG_30,#$0356		; load ptr REG_30 to end of trouble code stack
7121  F0                  ret
; bubble sort
7122  5631001C      L7122 addb  REG_1C,Zero,[REG_30]+	; load ptr to ???
7126  DFF5                je    L711D				; exit
7128  A0301A              ld    REG_1A,REG_30
712B  561B001D      L712B addb  REG_1D,Zero,[REG_1A]+
712F  DFF1                je    L7122				; LOOP

7131  981C1D              cmpb  REG_1D,REG_1C
7134  DBF5                jc    L712B				; LOOP

7136  C71AFF1C            stb   REG_1C,$FF[REG_1A]
713A  B01D1C              ldb   REG_1C,REG_1D
713D  C730FF1C            stb   REG_1C,$FF[REG_30]
7141  27E8                sjmp  L712B				; LOOP

; data table - len $25
7143  51546164            
7147  53006387            
      00
714C  14                  
714D  180022              
7150  914100              
7153  313233             
7156  343500          
7159  0000         
715B  2900        
715D  0000           
715F  00FF             
7161  FF                 
7162  FF                 

7163  95
7164  9656              
7166  6667
;
; Diagnostic Proc table B
;
7168  0D78             	  word  $780D	; Key On Engine Off (KOEO) Self Tests (offset zero @ $6F14)

; This table is used by code @ 807E
716A  8C80                word  $808C 	; 
716C  0800                word  $0008	; interrupt mask address
; table end?

;
716E  7078                word  $7870	; ECT. BP, MAF sensor range tests
7170  D278                word  $78D2	; ACT, EGR, NPS, A/C on,PwrSteering,VCAL, TP sensor tests
7172  E479                word  $79E4	; force LSO and HSO outputs off set STO on jmp to (REG_34)
7174  AD79                word  $79AD	; Thermactor Air System test
7176  CE79                word  $79CE	; Fuel Pump Secondary circuit test
7178  836F                word  $6F83	; dump out all $0342 stack error codes to ???
717A  017B                word  $7B01	; incr REG_38 and set LSO and BiDI outputs?
717C  1B7B                word  $7B1B	; proc with funny hardware xor
;
; Diagnostic proc table A
;
717E  E07B                word  $7BE0	; clr STO, Hard Fault, ACT, ECT, TP, TPS
7180  656F                word  $6F65
7182  847C                word  $7C84	; high RPM test (this is a Engine RUnning only test)
7184  A37C                word  $7CA3
7185  C97C                word  $7CC9
7188  E57C                word  $7CE5
718A  117D                word  $7D11
718C  4A7D                word  $7D4A
718E  687D                word  $7D68
7190  917D                word  $7D91
7192  AA7D                word  $7DAA
7194  8580                word  $8085
7196  5A90                word  $905A	; ROM ?!
7198  4C7E                word  $7E4C
719A  8F7E                word  $7E8F
719C  157F                word  $7F15
719E  247F                word  $7F24
71A0  377F                word  $7F37
71A2  557F                word  $7F55
71A4  627F                word  $7F62
71A6  7F7F                word  $7F7F
71A8  B17F                word  $7FB1
71AA  C87F                word  $7FC8
71AC  836F                word  $6F83	; dump out all $0342 stack error codes to ??? 
71AE  A680                word  $80A6
71B0  C480                word  $80C4
71B2  F280                word  $80F2   ;
71B4  FE80                word  $80FE   ; 
71B6  2181                word  $8121
71B8  2D81                word  $812D
71BA  7781                word  $8177
71BC  8A81                word  $818A
71BE  BA81                word  $81BA
71C0  3484                word  $8434	; in all three tables at end
71C2  7980                word  $8079   ; clr $01CA timer, incr REG_38 self test index, set bit flag and return
71C4  836F                word  $6F83	; dump out all $0342 stack error codes to ???
71C6  3484                word  $8434	; in all three tables at end
;
; Diagnostic proc table C
;
71C8  9272                word  $7292	; STO off and output to low, zero VIP timer, incr REG_38 test index
71CA  F471                word  $71F4	; tweak flags
71CC  FF71                word  $71FF	; SCCS something
71CE  7372                word  $7273
71D0  7980				  word  $8079   ; clr $01CA timer, incr REG_38 self test index, set bit flag and return
71D2  836F                word  $6F83	; dump out all $0342 stack error codes to ???
71D4  3484                word  $8434	; in all three tables at end
;
; Diagnostic proc table D
;
71D6  9272                word  $7292	; STO off and output to low, zero VIP timer, incr REG_38 test index
71D8  FA71                word  $71FA
71DA  7E80                word  $807E
71DC  6991                word  $9169   ; ROM ????
71DE  A672                word  $72A6
71E0  CC72                word  $72CC
71E2  7E80                word  $7E80
71E4  6A91                word  $916A  ???
71E6  D672                word  $72D6
71E8  DC72                word  $72DC
71EA  0073                word  $7300
71EC  0473                word  $7304	; HEGO - A/F ratio test???
71EE  7980                word  $8079   ; clr $01CA timer, incr REG_38 self test index, set bit flag and return
71F0  836F                word  $6F83	; dump out all $0342 stack error codes to ???
71F2  3484                word  $8434	; in all three tables at end
;
;*********************************************************
;
71F4  91FBD7        L71F4 orrb  REG_D7,#$FB		; clr REG_D7 bit 2 - clr Trouble code flag 67 or 94 error 
71F7  9104D7              orrb  REG_D7,#$04		; set REG_D7 bit 3 - set Trouble code flag 45 or 92 error
;
; Diagnostic Proc table D
;
71FA  EF77FD              lcall L6F74
71FD  2098                sjmp  L7297
;
;***********
;
71FF  37B503        L71FF jbc   REG_B5,BIT_07,L7205	; SCCS OFF button
7202  717FD7              andb  REG_D7,#$7F
7205  35B503        L7205 jbc   REG_B5,BIT_05,L720B	; SCCS COAST button
7208  71BFD7              andb  REG_D7,#$BF
720B  34B503        L720B jbc   REG_B5,BIT_04,L7211	; SCCS ACCEL button
720E  71DFD7              andb  REG_D7,#$DF
7211  33B503        L7211 jbc   REG_B5,BIT_03,L7217	; SCCS RESUME button
7214  71EFD7              andb  REG_D7,#$EF
7217  9108D7        L7217 orb   REG_D7,#$08			; error bit code???
721A  98B500              cmpb  Zero,REG_B5			; no SCCS buttons
721D  D703                jne   L7222
721F  71F7D7              andb  REG_D7,#$F7
7222  31EA05        L7222 jbc   REG_EA,BIT_01,L722A	; BIFLG =  If equal to 1, Brake is on.
7225  71FDD7              andb  REG_D7,#$FD			; REG_D7 bit 1 clear
7228  2003                sjmp  L722D

722A  71FED7        L722A andb  REG_D7,#$FE			; REG_D7 bit 0 clear
722D  3FE703        L722D jbs   REG_E7,BIT_07,L7233	; VPT flag
7230  71FBD7              andb  REG_D7,#$FB
7233  51FBD742      L7233 andb  REG_42,REG_D7,#$FB
7237  D703                jne   L723C
7239  32D720              jbc   REG_D7,BIT_02,L725C
723C  EFFC0B        L723C lcall L7E3B
723F  66                  byte  $66
7240  91                  byte  $91
7241  3BD715              jbs   REG_D7,BIT_03,L7259
7244  51F0D742            andb  REG_42,REG_D7,#$F0
7248  DF12                je    L725C
724A  99F042              cmpb  REG_42,#$F0
724D  D705                jne   L7254
724F  2852                scall L72A3				; Post Trouble code to $0342 stack?
7251  49                  byte  $49					; Trouble code : 49 - SPOUT signal defaulted to 10 degress BTDC or 1-2 shift error on E40D
7252  2008                sjmp  L725C
7254  284D          L7254 scall L72A3				; Post Trouble code to $0342 stack?
7256  47                  byte  $47					; Trouble code : 47 - measured air flow low at base idle
7257  2003                sjmp  L725C
7259  2848          L7259 scall L72A3				; Post Trouble code to $0342 stack?
725B  48                  byte  $48					; Trouble code : 48 - measured air flow high at base idle
725C  EFE506        L725C lcall L7944
725F  32D703              jbc   REG_D7,BIT_02,L7265
7262  283F                scall L72A3				; Post Trouble code to $0342 stack?
7264  67                  byte  $67					; Trouble code : 67 - Nuetral Drive Switch (NDS) circuit open; A/C input high
7265  31D703        L7265 jbc   REG_D7,BIT_01,L726B
7268  2839                scall L72A3				; Post Trouble code to $0342 stack?
726A  74                  byte  $74					; Trouble code : 74 - BOO brake on/off circuit failure - not actuated during test
726B  30D703        L726B jbc   REG_D7,BIT_00,L7271
726E  2833                scall L72A3				; Post Trouble code to $0342 stack?
7270  75                  byte  $75					; Trouble code : 75 - BOO brake on/off circuit closed - always high
7271  2024          L7271 sjmp  L7297
;
;**** fall thru
; Diagnostic Proc table C
;
7273  EF7908        L7273 lcall L7AEF
7276  C97F72              push  #$727F

; SCCS vent Open Circuit Check
7279  2812                scall L728D			; Open Circuit Check function
727B  81                  byte  $81			; Trouble code 81 AM2 circuit failure
727C  06                  byte  $06			; ROM limit offset from $8F86 (word)
727D  10                  byte  $10			; bit mask - SCCS vent
727E  46                  byte  $46			; REG_46 outputs
727F  28A4                scall L7325
7281  911046              orb   REG_46,#$10	; LSO output line 4 ON (Speed Control Vent)
7284  C99772              push  #$7297		; we will return from 7A76 to this address

; Data Output Link (DOL) Open Circuit Check
7287  2806                scall L728F		; Open Circuit Check function
7289  82                  byte  $82			; Trouble code 81 AM1 circuit failure
728A  04                  byte  $04			; ROM limit offset from $8F86 (word)
728B  01                  byte  $01			; bit mask - Data Output Link
728C  46                  byte  $46			; REG_46 outputs

728D  288A          L728D scall L7319		; SCCS controls off & stuff?
728F  E7E407        L728F ljmp  L7A76		; Open Circuit Check function
;
;************************************************************
; jump table entry 71C8
; STO off and output to low, zero VIP timer, incr REG_38 test index
; 
7292  0130                clr   REG_30
7294  EF1D05              lcall L77B4			; set STO off flag, set STO output low, and set STO trigger
7297  C7724A00      L7297 stb   Zero,$4A[REG_72]	; zero $01CA timer? VIP_TIMER_EX?
729B  1738          L729B incb  REG_38			; incr test index
729D  F0                  ret
;
;***********
;
729E  EF0B05              lcall L77AC			; tweak flags, set STO on and return
72A1  27F4                sjmp  L7297
;
; EEC trouble code : 91 - Air/Fuel mixture not within Self test range (HEGO switching error)
;
72A3  E70809        L72A3 ljmp  L7BAE			; JUMP TO (use caller data) push error $91 to $0342 error stack
;
; Diagnostic Proc table D
;
72A6  9120D9              orb   REG_D9,#$20
72A9  A379E200            ld    REG_42,$00E2[REG_78]
      42
72AE  C3732E01            st    REG_42,$012E[REG_72]
      42
72B3  6B79E000            sub   REG_42,$00E0[REG_78]
      42
72B8  8B732C01            cmp   REG_42,$012C[REG_72]
      42
72BD  D1DC                jnh   L729B
72BF  EF790B              lcall L7E3B
72C2  67                  byte  $67
72C3  91                  byte  $91
72C4  2FDD                scall L72A3
72C6  36                  byte  $36
72C7                L72C7 ldb   REG_38,#$0C
                          sjmp  L7319
                     
//72C6  36B10C              jbc   REG_B1,BIT_06,L72D5
//72C9  38204D              jbs   REG_20,BIT_00,L7319
;
; Diagnostic Proc table D
;
72CC  B180A0        L72CC ldb   REG_A0,#$80
72CF  2848                scall L7319
72D1  911046              orb   REG_46,#$10				; LSO output line 4 ON (Speed Control Vent)
72D4  27C1                sjmp  L7297
;
; Diagnostic Proc table D
;
72D6  C37270AA      L72D6 st    REG_AA,$70[REG_72]		; REG_AA is Throttle position
72DA  27BB                sjmp  L7297
;
; Diagnostic Proc table D
;
72DC  4B7270AA      L72DC sub   REG_42,REG_AA,$70[REG_72]	; REG_AA is Throttle position
      42
72E1  8B79EE00            cmp   REG_42,$00EE[REG_78]
      42
72E6  DA05                jle   L72ED
72E8  2FB9                scall L72A3
72EA                      byte  $28
72EB                      sjmp  L72C7
72ED                L72ED neg   REG_42
                          cmp   REG_42,$00EC[REG_78]

//72EA  2827                scall L7313
//72EC  DA03                jle   L72F1
//72EE  428B79EC            and   REG_EC,REG_79,[REG_8A]+
//72F2  0042                skip  REG_42
72F4  DA05                jle   L72FB
72F6  2FAB                scall L72A3
72F8                      byte  $27
                          sjmp  L72C7
72FB                L72FB call  L7E3B
                          byte  $68
                          byte  $91
;
; Diagnostic Proc table D
;
7300                L7300 scall L7319                  

//72F8  2727                sjmp  L7221
//72FA  CCEF                pop   REG_EF
//72FC  3D0B68              jbs   HSI_Sample,BIT_05,L7367	; bit 5 is CID line 
//72FF  912817              orb   REG_17,#$28
7302  2793                sjmp  L7297
;
; Diagnostic Proc table D
; $716E Self test jump table entry
;
7304  A3FA6242            ld    REG_42,$62[REG_FA]
7308  8B732C0142          cmp   REG_42,$012C[REG_72]
730D  D908                jh    L7317
730F  EF290B              lcall L7E3B
7312  64                  byte  $64
7313  D0            L7313 byte  $D0
7314  2F8D                scall L72A3
7316  37                  byte  $37
7317  1738          L7317 incb  REG_38				; incr test index

; SCCS controls off & ???
7319  71DFD9        L7319 andb  REG_D9,#$DF			; clr REG_D9 bit 5 VVS flag1? 
731C  2807                scall L7325
731E  71EF46              andb  REG_46,#$EF			; LSO output line 4 OFF (Speed Control Vent)
7321  71FE46              andb  REG_46,#$FE			; LSO output line 0 OFF (Speed Control Vacuum)
7324  F0                  ret

7325  B1FF42        L7325 ldb   REG_42,#$FF
7328  C7731BFF            stb   REG_42,$FF1B[REG_72] ; SCCS Count? REG_9B = REG_42 why such a strange instruction?
      42
732D  F0                  ret
;
;*****************************************************************
; Cycling Routine at 2151, routine offset $??
; Diagnostics
;*****************************************************************
;

732E  2D66          L732E scall L7096				; Set up EGR flags
7330  EFAA10              lcall L83DD				; major flag testing - a lot of REG_2A
7333  71EF2B              andb  REG_2B,#$EF			; clr bit 5
7336  382A03              jbs   REG_2A,BIT_00,L733C	; jump if VIP_mode_flag : VSCDT
7339  71DFD9        L7339 andb  REG_D9,#$DF			; clr VVSFL1
733C  3A2A01        L733C jbs   REG_2A,BIT_02,L7340	; jump if VIP_mode_flag : VIP enable
733F  F0                  ret

7340  302A01        L7340 jbc   REG_2A,BIT_00,L7344	; jump if not VIP_mode_flag : VSCDT
7343  F0                  ret

7344  71F72B        L7344 andb  REG_2B,#$F7			; clear bit 3
7347  B378F342            ldb   REG_42,$F3[REG_78]
734B  E04213              djnz  REG_42,L7361
734E  374618              jbc   REG_46,BIT_07,L7369	; if LSO output line 7 is OFF (Fuel Pump)
7351  3AA103        L7351 jbs   REG_A1,BIT_02,L7357	; UNDSP = Run/Underspeed Flag.  (1 = Underspeed (or CRANK), 0 = Run)
7354  9180D9              orb   REG_D9,#$80
7357  C7724600      L7357 stb   Zero,$46[REG_72]	; zero $01C6 timer? VIP_FPMTMR - fuel pump timer?
735B  3CDF03              jbs   REG_DF,BIT_04,L7361
735E  91082B              orb   REG_2B,#$08			; set bit 3
7361  EF7C03        L7361 lcall L76E0				; Log a soft error to KAM (KAM addr info, KAM err mask, err index for calibr upcount & threshold)
7364  04                  byte  $04	; KAM addr info
7365  40                  byte  $40	; KAM err mask
7366  14                  byte  $14 ; err index - EVP OUT-OF-LIMIT
7367  202B          L7367 sjmp  L7394
;
;****
;
7369  37D918        L7369 jbc   REG_D9,BIT_07,L7384
736C  717FD9              andb  REG_D9,#$7F
736F  EFDEFC              lcall L7050				; load diagnostic testing registers
7372  EF7A07              lcall L7AEF				; call set HSO_Time_Hold = Master_IO_Timer_Lo + #$0003
7375  C97F73              push  #$737F				; we return to this address

; Fuel Pump Open Circuit Check
7378  EFFB06              lcall L7A76			; Open Circuit Check function
737B  08                  byte  $08			; Trouble Code 8 !!!!!!!!!!!!!!!!!!
737C  00                  byte  $00			; ROM limit offset from $8F86 (word)
737D  80                  byte  $80			; bit mask - Fuel Pump
737E  46                  byte  $46			; REG_46 outputs
737F  901A2B              orb   REG_2B,REG_1A
7382  2016          L7382 sjmp  L739A

7384  B3724642      L7384 ldb   REG_42,$46[REG_72]	; $01C6 timer?
7388  9B78F542            cmpb  REG_42,$F5[REG_78]
738C  D306                jnc   L7394
738E  34DF03              jbc   REG_DF,BIT_04,L7394
7391  91082B              orb   REG_2B,#$08

7394  EF4903        L7394 lcall L76E0				; Log a soft error to KAM (KAM addr info, KAM err mask, err index for calibr upcount & threshold)
7397  04                  byte  $04
7398  80                  byte  $80
7399  13                  byte  $13
739A  EF4303        L739A lcall L76E0				; Log a soft error to KAM (KAM addr info, KAM err mask, err index for calibr upcount & threshold)
739D  00                  byte  $00
739E  01                  byte  $01
739F  11                  byte  $11
73A0  3B2C04              jbs   REG_2C,BIT_03,L73A7
73A3  37A101              jbc   REG_A1,BIT_07,L73A7		; jump if not CRANKING
73A6  F0                  ret

73A7  717FD8        L73A7 andb  REG_D8,#$7F
73AA  EFB705              lcall L7964		; Compare two maggled values values in data following call word, word
73AD  7E                  byte  $7E	$001A
73AE  90                  byte  $90	$001B
73AF  12                  byte  $12	$001C	; $0112 - ECT raw from AD conversion
73B0  01                  byte  $01	$001D

73B1  EF2C03              lcall L76E0		; Log a soft error to KAM (KAM addr info, KAM err mask, err index for calibr upcount & threshold)
73B4  18                  byte  $18			; trouble code bit 2 - ECT open circuit trouble code
73B5  20                  byte  $20
73B6  0D                  byte  $0D

73B7  EFAA05              lcall L7964		; Compare two maggled values values in data following call word, word
73BA  12                  byte  $12	$001A	; $0112 - ECT raw from AD conversion
73BB  01                  byte  $01	$001B
73BC  80                  byte  $80	$001C
73BD  90                  byte  $90	$001D

73BE  EF1F03              lcall L76E0		; Log a soft error to KAM (KAM addr info, KAM err mask, err index for calibr upcount & threshold)
73C1  20                  byte  $20			; trouble code bit 3
73C2  80                  byte  $80
73C3  09                  byte  $09

73C4  EF9D05              lcall L7964		; Compare two maggled values values in data following call word, word
73C7  68                  byte  $68
73C8  90                  byte  $90
73C9  14                  byte  $14			; $0114
73CA  01                  byte  $01

73CB  2B13                scall L76E0		; Log a soft error to KAM (KAM addr info, KAM err mask, err index for calibr upcount & threshold)
73CD  08                  byte  $08			; trouble code bit 0 - 
73CE  10                  byte  $10
73CF  0F                  byte  $0F

73D0  EF9105              lcall L7964		; Compare two maggled values values in data following call word, word
73D3  14                  byte  $14			; $0114
73D4  01                  byte  $01
73D5  6A                  byte  $6A
73D6  90                  byte  $90

73D7  2B07                scall L76E0		; Log a soft error to KAM (KAM addr info, KAM err mask, err index for calibr upcount & threshold)
73D9  10                  byte  $10			; trouble code bit 1
73DA  40                  byte  $40
73DB  0B                  byte  $0B

73DC  9BF84B00            cmpb  Zero,$4B[REG_F8] ; ROM 
73E0  DF21                je    L7403
73E2  B372B642            ldb   REG_42,$B6[REG_72]	; $0136 - timer?
73E6  9B799600            cmpb  REG_42,$0096[REG_78]
      42
73EB  D105                jnh   L73F2
73ED  91082B              orb   REG_2B,#$08
73F0  2011                sjmp  L7403

73F2  EF6F05        L73F2 lcall L7964		; Compare two maggled values values in data following call word, word
73F5  0A                  byte  $0A	; $010A - MAP/BP
73F6  01                  byte  $01
73F7  04                  byte  $04
73F8  91                  byte  $91
73F9  3B2B07              jbs   REG_2B,BIT_03,L7403

73FC  EF6505              lcall L7964		; Compare two maggled values values in data following call word, word
73FF  02                  byte  $02
7400  91                  byte  $91
7401  0A                  byte  $0A	; $010A - MAP/BP
7402  01                  byte  $01

7403  2ADB          L7403 scall L76E0		; Log a soft error to KAM (KAM addr info, KAM err mask, err index for calibr upcount & threshold)
7405  59                  byte  $59
7406  08                  byte  $08
7407  01                  byte  $01
7408  8B799200            cmp   REG_AE,$0092[REG_78]
      AE
740D  DB07                jc    L7416
740F  EF5205              lcall L7964		; Compare two maggled values values in data following call word, word
7412  24                  byte  $24	; $0124 MAF sensor (raw?)
7413  01                  byte  $01
7414  0E                  byte  $0E
7415  91                  byte  $91
7416  2AC8          L7416 scall L76E0		; Log a soft error to KAM (KAM addr info, KAM err mask, err index for calibr upcount & threshold)
7418  54                  byte  $54
7419  20                  byte  $20
741A  0C                  byte  $0C
741B  3AA112              jbs   REG_A1,BIT_02,L7430		; UNDSP = Run/Underspeed Flag.  (1 = Underspeed (or CRANK), 0 = Run)
741E  A372BE42            ld    REG_42,$BE[REG_72]		; $013E - timer? time since last PIP recieved
7422  8B798600            cmp   REG_42,$0086[REG_78]
      42
7427  D907                jh    L7430
7429  EF3805              lcall L7964					; Compare two maggled values values in data following call word, word
742C  10                  byte  $10
742D  91                  byte  $91
742E  24                  byte  $24	; $0124 MAF sensor (raw?)
742F  01                  byte  $01
7430  2AAE          L7430 scall L76E0					; Log a soft error to KAM (KAM addr info, KAM err mask, err index for calibr upcount & threshold)
7432  4C                  byte  $4C	; 382 error bit 
7433  10                  byte  $10
7434  10                  byte  $10
7435  EF2C05              lcall L7964					; Compare two maggled values values in data following call word, word 
7438  70                  byte  $70
7439  90                  byte  $90
743A  22                  byte  $22	; $0122 - AD channel 7 = TPS?
743B  01                  byte  $01
743C  2AA2                scall L76E0					; Log a soft error to KAM (KAM addr info, KAM err mask, err index for calibr upcount & threshold)
743E  38                  byte  $38	; 382 error bit 8
743F  02                  byte  $02
7440  0E                  byte  $0E
7441  EF2005              lcall L7964					; Compare two maggled values values in data following call word, word 
7444  22                  byte  $22	; $0122 - AD channel 7 = TPS?
7445  01                  byte  $01
7446  6E                  byte  $6E
7447  90                  byte  $90
7448  2A96                scall L76E0					; Log a soft error to KAM (KAM addr info, KAM err mask, err index for calibr upcount & threshold)
744A  40                  byte  $40	; 382 error bit 9
744B  08                  byte  $08
744C  0A                  byte  $0A
744D  332C02              jbc   REG_2C,BIT_03,L7452
7450  2090                sjmp  L74E2

7452  B3782422      L7452 ldb   REG_22,$24[REG_78]
7456  E02239              djnz  REG_22,L7492

7459  B3725620            ldb   REG_20,$56[REG_72]		; test selector is $01D7 vs $01D6 BYTE here
745D  9800D0              cmpb  REG_D0,Zero				; is throttle partly open?
7460  D703                jne   L7465
7462  9180E6              orb   REG_E6,#$80				; set REG_D6 bit 7
7465  37D011        L7465 jbc   REG_D0,BIT_07,L7479		; jmp if throttle is not closed
7468  37E60E              jbc   REG_E6,BIT_07,L7479
746B  717FE6              andb  REG_E6,#$7F
746E  1720                incb  REG_20					; increment test routine selector (REG_38)
7470  D303                jnc   L7475
7472  B1FF20              ldb   REG_20,#$FF				; max test is $00FF
7475  C7725620      L7475 stb   REG_20,$56[REG_72]		; test selector is $01D7 not the 1D6 here

7479  9BF3A600      L7479 cmpb  REG_C9,$00A6[REG_F2]	; ROM - REG_C9 is some kind of timer
      C9
747E  D902                jh    L7482
7480  2010                sjmp  L7492

7482  B3FE0B32      L7482 ldb   REG_32,$0B[REG_FE]		; ROM $9E65 thermactor_present_switch = 1.0
7486  E03203              djnz  REG_32,L748C

7489  3C4706              jbs   REG_47,BIT_04,L7492		; if REG_47 bit 4 is ON (Air management2)
748C  51B8C532      L748C andb  REG_32,REG_C5,#$B8
7490  DF0F                je    L74A1

7492  C7725600      L7492 stb   Zero,$56[REG_72]		; test selector is $01D7 - reset to zero
7496  982200              cmpb  Zero,REG_22
7499  DF04                je    L749F
749B  201C                sjmp  L74B9
749D  2002                sjmp  L74A1					; this is odd 
749F  2041          L749F sjmp  L74E2
74A1  9BF3A700      L74A1 cmpb  REG_20,$00A7[REG_F2]
      20
74A6  D902                jh    L74AA
74A8  2038                sjmp  L74E2
74AA  B373250130    L74AA ldb   REG_30,$0125[REG_72]
74AF  9BF3A50030          cmpb  REG_30,$00A5[REG_F2]	; ROM $8EFF #ego switches requires to pass (8)
74B4  DB03                jc    L74B9					; jmp switches >= 8
74B6  91082B              orb   REG_2B,#$08				; not enough ego switches - set fail code

74B9  2A25          L74B9 scall L76E0					; Log a soft error to KAM (KAM addr info, KAM err mask, err index for calibr upcount & threshold)
74BB  01                  byte  $01
74BC  02                  byte  $02
74BD  08                  byte  $08
74BE  B3FE1642            ldb   REG_42,$16[REG_FE]		; ROM $9E70 number_of_HEGOs
74C2  982200              cmpb  Zero,REG_22
74C5  D705                jne   L74CC
74C7  990142              cmpb  REG_42,#$01
74CA  D702                jne   L74CE
74CC  200F          L74CC sjmp  L74DD
74CE  B373260130    L74CE ldb   REG_30,$0126[REG_72]
74D3  9BF3A50030          cmpb  REG_30,$00A5[REG_F2]	; ROM $8EFF #ego switches requires to pass (8)
74D8  DB03                jc    L74DD
74DA  91082B              orb   REG_2B,#$08

74DD  2A01          L74DD scall L76E0					; Log a soft error to KAM (KAM addr info, KAM err mask, err index for calibr upcount & threshold)
74DF  01                  byte  $01
74E0  04                  byte  $04
74E1  12                  byte  $12
74E2  B379F900      L74E2 ldb   REG_42,$00F9[REG_78]
      42
74E7  E04265              djnz  REG_42,L754F
74EA  B378C742            ldb   REG_42,$C7[REG_78]
74EE  980042              cmpb  REG_42,Zero
74F1  DF5C                je    L754F
74F3  B3FE0242            ldb   REG_42,$02[REG_FE]		; ROM $9E5C
74F7  990442              cmpb  REG_42,#$04
74FA  DB1A                jc    L7516
74FC  A373DC00            ld    REG_42,$00DC[REG_72]	; ROM
      42
7501  3CC50E              jbs   REG_C5,BIT_04,L7512
7504  37D00B              jbc   REG_D0,BIT_07,L7512		; jmp if throttle is not closed
7507  8BF31401            cmp   REG_42,$0114[REG_F2]	; ROM
      42
750C  D904                jh    L7512
750E  2018                sjmp  L7528
7510  2002                sjmp  L7514
7512  200E          L7512 sjmp  L7522
7514  200C          L7514 sjmp  L7522
7516  37E709        L7516 jbc   REG_E7,BIT_07,L7522
7519  8BF37401            cmp   REG_AE,$0174[REG_F2]	; ROM
      AE
751E  D302                jnc   L7522
7520  2006                sjmp  L7528
7522  C7724900      L7522 stb   Zero,$49[REG_72]		; zero $01C9 - timer?
7526  2027                sjmp  L754F
7528  8BF37601      L7528 cmp   REG_AE,$0176[REG_F2]
      AE
752D  DB04                jc    L7533
752F  201E                sjmp  L754F
7531  200D                sjmp  L7540
7533  B3724942      L7533 ldb   REG_42,$49[REG_72]		; $01C9 - timer?
7537  9BF37A01            cmpb  REG_42,$017A[REG_F2]
      42
753C  DB02                jc    L7540
753E  200F                sjmp  L754F
7540  B3733D01      L7540 ldb   REG_42,$013D[REG_72]
      42
7545  9BF37801            cmpb  REG_42,$0178[REG_F2]	; ROM
      42
754A  DB03                jc    L754F
754C  91082B              orb   REG_2B,#$08
754F  298F          L754F scall L76E0					; Log a soft error to KAM (KAM addr info, KAM err mask, err index for calibr upcount & threshold)
7551  03                  byte  $03
7552  80                  byte  $80
7553  02                  byte  $02
7554  36D902              jbc   REG_D9,BIT_06,L7559
7557  20D9                sjmp  L7632
7559  3EE60D        L7559 jbs   REG_E6,BIT_06,L7569
755C  EF7009              lcall L7ECF
755F  16                  byte  $16	; $116 - raw EGR
7560  01                  byte  $01
7561  B4                  byte  $B4	; Lo mangle limit
7562  90                  byte  $90
7563  B0                  byte  $B0	; Hi Mangle limit
7564  90                  byte  $90
7565  32                  byte  $32    	; Trouble Code on Lo limit - PFE/EVP/ (sonic) voltage below closed limit
7566  00                  byte  $00	; Trouble Code on Hi limit - none?
7567  201F                sjmp  L7588
7569  3FD002        L7569 jbs   REG_D0,BIT_07,L756E		; jmp if throttle is closed
756C  2080          L756C sjmp  L75EE
756E  A3728842      L756E ld    REG_42,$88[REG_72]	; filtered sensor output - in place ($0108) - filtered RPM
7572  8B79C800            cmp   REG_42,$00C8[REG_78]
      42
7577  DBF3                jc    L756C
7579  2A5C                scall L77D7		; filter $380 somehow
757B  80                  byte  $80
757C  03                  byte  $03
757D  EF4F09              lcall L7ECF
7580  80                  byte  $80	; $380 - ?
7581  03                  byte  $03
7582  40                  byte  $40	; Lo mangle limit
7583  91                  byte  $91
7584  34                  byte  $34	; Hi Mangle limit
7585  91                  byte  $91
7586  32                  byte  $32    	; Trouble Code on Lo limit - PFE/EVP/ (sonic) voltage below closed limit
7587  34                  byte  $34	; Trouble Code on Hi limit - ? Exhaust pressure high ; Defective PFE/EPT sensor ?
7588  B01A40        L7588 ldb   REG_40,REG_1A
758B  2A60                scall L77ED		; cmp param byte : REG_40, SET REG_2B bit 4 if equal
758D  31                  byte  $31
758E  2950                scall L76E0		; Log a soft error to KAM (KAM addr info, KAM err mask, err index for calibr upcount & threshold)
7590  2A                  byte  $2A
7591  80                  byte  $80
7592  03                  byte  $03
7593  2A58                scall L77ED		; cmp param byte : REG_40, SET REG_2B bit 4 if equal
7595  35                  byte  $35
7596  2948                scall L76E0		; Log a soft error to KAM (KAM addr info, KAM err mask, err index for calibr upcount & threshold)
7598  32                  byte  $32
7599  08                  byte  $08
759A  07                  byte  $07
759B  332C08              jbc   REG_2C,BIT_03,L75A6
759E  71BF2C        L759E andb  REG_2C,#$BF
75A1  717F2C              andb  REG_2C,#$7F
75A4  2087                sjmp  L762D
75A6  2A45          L75A6 scall L77ED		; cmp param byte : REG_40, SET REG_2B bit 4 if equal
75A8  32                  byte  $32
75A9  2935                scall L76E0		; Log a soft error to KAM (KAM addr info, KAM err mask, err index for calibr upcount & threshold)
75AB  02                  byte  $02
75AC  40                  byte  $40
75AD  04                  byte  $04
75AE  36E60A              jbc   REG_E6,BIT_06,L75BB
75B1  2A3A                scall L77ED		; cmp param byte : REG_40, SET REG_2B bit 4 if equal
75B3  34                  byte  $34
75B4  292A                scall L76E0		; Log a soft error to KAM (KAM addr info, KAM err mask, err index for calibr upcount & threshold)
75B6  02                  byte  $02
75B7  10                  byte  $10
75B8  06                  byte  $06
75B9  2033                sjmp  L75EE
75BB  3C40E0        L75BB jbs   REG_40,BIT_04,L759E
75BE  9800D3              cmpb  REG_D3,Zero
75C1  D728                jne   L75EB
75C3  717F2C              andb  REG_2C,#$7F
75C6  3E2C07              jbs   REG_2C,BIT_06,L75D0
75C9  C7724A00            stb   Zero,$4A[REG_72]	; zero $01CA timer?
75CD  91402C              orb   REG_2C,#$40
75D0  EF9103        L75D0 lcall L7964		; Compare two maggled values values in data following call word, word
75D3  16                  byte  $16	; $0116 AD channel $C - EGR valve
75D4  01                  byte  $01
75D5  B6                  byte  $B6
75D6  90                  byte  $90
75D7  332B0A              jbc   REG_2B,BIT_03,L75E4
75DA  B3724A18            ldb   REG_18,$4A[REG_72]		; $01CA timer?
75DE  9B783C18            cmpb  REG_18,$3C[REG_78]
75E2  D34E                jnc   L7632
75E4  28FA          L75E4 scall L76E0		; Log a soft error to KAM (KAM addr info, KAM err mask, err index for calibr upcount & threshold)
75E6  02                  byte  $02
75E7  10                  byte  $10
75E8  06                  byte  $06
75E9  2042                sjmp  L762D
75EB  71BF2C        L75EB andb  REG_2C,#$BF
75EE  9B7829D3      L75EE cmpb  REG_D3,$29[REG_78]
75F2  D3AA                jnc   L759E
75F4  A373DC00            ld    REG_42,$00DC[REG_72]
      42
75F9  8B782E42            cmp   REG_42,$2E[REG_78]
75FD  D99F                jh    L759E
75FF  3F2C07              jbs   REG_2C,BIT_07,L7609
7602  91802C              orb   REG_2C,#$80
7605  C7724A00            stb   Zero,$4A[REG_72]		; zero $01CA timer?
7609  3EE609        L7609 jbs   REG_E6,BIT_06,L7615
760C  EF5503              lcall L7964		; Compare two maggled values values in data following call word, word
760F  BA                  byte  $BA
7610  90                  byte  $90
7611  16                  byte  $16	; $0116 AD channel $C - EGR valve
7612  01                  byte  $01
7613  200B                sjmp  L7620
7615  29C0          L7615 scall L77D7		; filter $37E somehow
7617  7E                  byte  $7E
7618  03                  byte  $03
7619  EF4803              lcall L7964		; Compare two maggled values values in data following call word, word
761C  7E                  byte  $7E	; $037E ???????????????????????????????????????????????????????????????????????????
761D  03                  byte  $03
761E  46                  byte  $46
761F  91                  byte  $91
7620  332B0A        L7620 jbc   REG_2B,BIT_03,L762D
7623  B3724A18            ldb   REG_18,$4A[REG_72]		; $01CA timer?
7627  9B782818            cmpb  REG_18,$28[REG_78]
762B  D305                jnc   L7632
762D  28B1          L762D scall L76E0		; Log a soft error to KAM (KAM addr info, KAM err mask, err index for calibr upcount & threshold)
762F  02                  byte  $02
7630  20                  byte  $20
7631  05                  byte  $05
7632  71F72B        L7632 andb  REG_2B,#$F7
7635  8B78FAAE            cmp   REG_AE,$FA[REG_78]
7639  DB02                jc    L763D
763B  2036                sjmp  L7673
763D  2B25          L763D scall L7964		; Compare two maggled values values in data following call word, word
763F  3E                  byte  $3E	; $013E ????????????????????????????????????????????????????????????????????????????
7640  01                  byte  $01
7641  7C                  byte  $7C
7642  90                  byte  $90
7643  332B0B              jbc   REG_2B,BIT_03,L7651
7646  91012C              orb   REG_2C,#$01
7649  C7723F00            stb   Zero,$3F[REG_72]
764D  C3724400            st    Zero,$44[REG_72]	; timer? time in self test mode?
7651  288D          L7651 scall L76E0		; Log a soft error to KAM (KAM addr info, KAM err mask, err index for calibr upcount & threshold)
7653  01                  byte  $01
7654  40                  byte  $40
7655  00                  byte  $00
7656  382C0D              jbs   REG_2C,BIT_00,L7666
7659  2B09                scall L7964		; Compare two maggled values values in data following call word, word
765B  C4                  byte  $C4	; $01C4 ????????????????????????????????????????????????????????????????????????????
765C  01                  byte  $01
765D  78                  byte  $78
765E  90                  byte  $90
765F  287F                scall L76E0		; Log a soft error to KAM (KAM addr info, KAM err mask, err index for calibr upcount & threshold)
7661  01                  byte  $01
7662  20                  byte  $20
7663  15                  byte  $15
7664  2011                sjmp  L7677
7666  A3724442      L7666 ld    REG_42,$44[REG_72]	; timer? time in self test mode?
766A  9BF27643            cmpb  REG_43,$76[REG_F2]
766E  D107                jnh   L7677
7670  71FE2C              andb  REG_2C,#$FE
7673  C3724400      L7673 st    Zero,$44[REG_72]	; timer? time in self test mode?
7677  2980          L7677 scall L77F9		; 1st param word AND $0202[REG_72], if zero set bit mask REG_1C  in REG_C5 else clr it
7679  03                  byte  $03
767A  00                  byte  $00
767B  20                  byte  $20
767C  297B                scall L77F9		; 1st param word AND $0202[REG_72], if zero set bit mask REG_1C  in REG_C5 else clr it
767E  0C                  byte  $0C
767F  00                  byte  $00
7680  80                  byte  $80
7681  2976                scall L77F9		; 1st param word AND $0202[REG_72], if zero set bit mask REG_1C  in REG_C5 else clr it
7683  30                  byte  $30
7684  00                  byte  $00
7685  40                  byte  $40		; set/clrs REG_C5 effects ACT read
7686  2971                scall L77F9		; 1st param word AND $0202[REG_72], if zero set bit mask REG_1C  in REG_C5 else clr it
7688  C0                  byte  $C0
7689  00                  byte  $00
768A  10                  byte  $10
768B  296C                scall L77F9		; 1st param word AND $0202[REG_72], if zero set bit mask REG_1C  in REG_C5 else clr it
768D  00                  byte  $00
768E  04                  byte  $04
768F  02                  byte  $02
7690  2967                scall L77F9					; 1st param word AND $0202[REG_72], if zero set bit mask REG_1C  in REG_C5 else clr it
7692  00                  byte  $00
7693  03                  byte  $03
7694  08                  byte  $08
7695  332C09              jbc   REG_2C,BIT_03,L76A1
7698  37D804              jbc   REG_D8,BIT_07,L769F
769B  290F                scall L77AC					; tweak flags, set STO on and return
769D  2002                sjmp  L76A1
769F  2913          L769F scall L77B4					; set STO off flag, set STO output low, and set STO trigger
76A1  39253B        L76A1 jbs   REG_25,BIT_01,L76DF
76A4  3FA138              jbs   REG_A1,BIT_07,L76DF		; jump if CRANKING
76A7  3AA135              jbs   REG_A1,BIT_02,L76DF		; UNDSP = Run/Underspeed Flag.  (1 = Underspeed (or CRANK), 0 = Run)
76AA  B3732DFF            ldb   REG_14,$FF2D[REG_72]
      14
76AF  9BF26C14            cmpb  REG_14,$6C[REG_F2]
76B3  D62A                jge   L76DF
76B5  9BF3FE00            cmpb  REG_B0,$00FE[REG_F2]
      B0
76BA  DA23                jle   L76DF
76BC  910225              orb   REG_25,#$02
76BF  30EF1D              jbc   REG_EF,BIT_00,L76DF
76C2  3D2B1A              jbs   REG_2B,BIT_05,L76DF		; jump if STI input is high

76C5  A1170038            ld    REG_38,#$0017
; incr the # times the test has been run for index REG_38 and less ???
76C9  B339C9073A    L76C9 ldb   REG_3A,$07C9[REG_38]	; incr 22 bytes in table clamp at max of FF
76CE  173A                incb  REG_3A
76D0  D702                jne   L76D4
76D2  153A                decb  REG_3A					; clamp to $FF max
76D4  C739C9073A    L76D4 stb   REG_3A,$07C9[REG_38]
76D9  E038ED              djnz  REG_38,L76C9

76DC  71FEEF              andb  REG_EF,#$FE
76DF  F0            L76DF ret
;
;*******************************************************
; Log a soft error to KAM (KAM addr info, KAM err mask, err index for calibr upcount & threshold)
; first param byte (at $001A) bottom 3 bits are index in $07C4 KAM table - KAM ADDRESS FOR THIS ERROR BIT
;                        rest of bit >> 3 and - 1 are error flag bit 
; second param byte (REG_1B) is mask for bit error - KAM BIT MASK FOR THIS ERROR BIT
; third param byte (REG_1C) is calibr REG_F2 offset - gives upcount and threshold for this soft error code
;                         THIS IS THE ERROR INDEX TO GET THRESHOLD AND UPCOUNT INFO FROM THE CALIBRATION DATA
;
76E0  28DC          L76E0 scall L77BE					; copy byte following call count bytes from stackptr2 to $001A
76E2  03                  byte  $03						; copy the three bytes to REG_1A/1B/1C

76E3  BC1C14              ldbse REG_14,REG_1C			; 3rd param byte to word
76E6  44F21442            add   REG_42,REG_14,REG_F2	; ROM address $8E5A + data offset
76EA  B343D70042          ldb   REG_42,$00D7[REG_42]	; read ROM at lookup address - param3 + 8E5A + 00D7 = 8F31 UPCOUNT

76EF  44F2143A            add   REG_3A,REG_14,REG_F2	; same ROM address AGAIN
76F3  B33BC1003A          ldb   REG_3A,$00C1[REG_3A]	; what is this byte RAM table - param3 + 8E5A + 00C1 = 8F1B THRESHOLD

76F8  AC1A18              ldbze REG_18,REG_1A			; 1st param byte to word 
76FB  710718              andb  REG_18,#$07				; mask out bottom 3 bits of first param (0-7)
76FE  65C40718            add   REG_18,#$07C4			; REG_18 is now a pointer to ???KAM_INDEXL

7702  011C                clr   REG_1C
7704  18031A              shrb  REG_1A,#$03				; first param >> 3 (shift out offset bits) 5 bits left
7707  DF07                je    L7710					; zero value is special ( flag bits are biased up by one )
7709  151A                decb  REG_1A
770B  071C                inc   REG_1C					; REG_1C = $0001 now
770D  091A1C              shl   REG_1C,REG_1A			; creates a mask of bit # (REG_1A - 1)
7710  A373020234    L7710 ld    REG_34,$0202[REG_72]	; $0382 error bit flags word

7715  B315AA0130          ldb   REG_30,$01AA[REG_14]	; REG_14 is second param

771A  984200        L771A cmpb  Zero,REG_42				; is our uppcount zero?
771D  DF0D                je    L772C	
771F  332C07              jbc   REG_2C,BIT_03,L772F
7722  B378F23A            ldb   REG_3A,$F2[REG_78]
7726  B1FF42              ldb   REG_42,#$FF				; upcount
7729  3B2B2A        L7729 jbs   REG_2B,BIT_03,L7756
772C  980030        L772C cmpb  REG_30,Zero
772F  DF02                je    L7733
7731  1530                decb  REG_30
7733  5B787F3A3B    L7733 subb  REG_3B,REG_3A,$7F[REG_78]
7738  98303B              cmpb  REG_3B,REG_30
773B  D105                jnh   L7742
773D  021C                not   REG_1C					; invert mask
773F  601C34              and   REG_34,REG_1C			; clear the error bit
7742  B12842        L7742 ldb   REG_42,#$28				; upcount = 40
7745  9B15CA0742          cmpb  REG_42,$07CA[REG_14]	; check upcount for this error 
774A  D908                jh    L7754					; jump if 40 > err count

774C  121B                notb  REG_1B					; second param byte single bit mask
774E  72181B              andb  REG_1B,[REG_18]			; mask bit at [REG_18] OFF
7751  C6181B              stb   REG_1B,[REG_18]			; save byte w/ bit off
7754  2037          L7754 sjmp  L778D

7756  71F72B        L7756 andb  REG_2B,#$F7
7759  744230              addb  REG_30,REG_42			; add second param and upcount
775C  D303                jnc   L7761

775E  B1FF30              ldb   REG_30,#$FF				; clamp max value
7761  98303A        L7761 cmpb  REG_3A,REG_30			; compare second param sum and table lookup value 
7764  DB27                jc    L778D

7766  89C60718            cmp   REG_18,#$07C6			; what is this address ???KAM error address
776A  D713                jne   L777F

776C  51F81B33            andb  REG_33,REG_1B,#$F8		; clr bits 0,1,2
7770  DF0D                je    L777F

7772  B21833              ldb   REG_33,[REG_18]
7775  71F833              andb  REG_33,#$F8				; clr bits 0,1,2
7778  DF05                je    L777F

777A  701B33              andb  REG_33,REG_1B
777D  DF0B                je    L778A

777F  92181B        L777F orb   REG_1B,[REG_18]			; turn error bit code ON
7782  C6181B              stb   REG_1B,[REG_18]			; dave error byte with ON bit code back in KAM
7785  C715CA07            stb   Zero,$07CA[REG_14]
      00
778A  801C34        L778A or    REG_34,REG_1C			; set the error bit
778D  98303A        L778D cmpb  REG_3A,REG_30
7790  DB03                jc    L7795
7792  9180D8              orb   REG_D8,#$80

7795  C715AA0130    L7795 stb   REG_30,$01AA[REG_14]	; save ? REG_14 is second param (ie $01AA + $0D = $01B7)
779A  C373020234          st    REG_34,$0202[REG_72]	; $0382 error bit flags, bit 2 set = ECT grounded
779F  F0                  ret

77A0  AD1D16        L77A0 ldbze REG_16,#$1D
77A3  C717C30700    L77A3 stb   Zero,$07C3[REG_16]		; clear table $07C4 to $07D9
77A8  E016F8              djnz  REG_16,L77A3
77AB  F0                  ret

77AC  9180D6        L77AC orb   REG_D6,#$80				; tweak flags. set STO on and return
77AF  912046              orb   REG_46,#$20				; LSO output line 5 (STO) ON (MIL)
77B2  2006                sjmp  L77BA

; set STO off flag, set STO output low, and set STO trigger
77B4  9140D6        L77B4 orb   REG_D6,#$40				; set STO OFF flag
77B7  71DF46              andb  REG_46,#$DF				; LSO output line 5 (STO) OFF (MIL)

77BA  91042B        L77BA orb   REG_2B,#$04				; set Self Test Output trigger
77BD  F0                  ret
;
;****************************************************************
; copy stackptr 1 count bytes from stackptr2 to $001A
; pulls a count Byte from the return address of the first caller
; uses the count to copy count bytes from the return address of the next to last caller

77BE  A11A0016      L77BE ld    REG_16,#$001A	; default copy dest address

; entry point for supplying the copy 'to' address
; copy stackptr 1 count bytes from stackptr2 to REG_16
77C2  CC3C          L77C2 pop   REG_3C
77C4  B23D3A              ldb   REG_3A,[REG_3C]+
77C7  CC42                pop   REG_42
77C9  B2433B        L77C9 ldb   REG_3B,[REG_42]+
77CC  C6173B              stb   REG_3B,[REG_16]+
77CF  E03AF7              djnz  REG_3A,L77C9
77D2  C842                push  REG_42
77D4  C83C                push  REG_3C
77D6  F0                  ret

;****************************************************************
; L3663 is entry point for filtering
; REG_32 is OLD AD sensor value
; REG_34 is new AD sensor value
; REG_36 is manged filtering factor
77D7  2FE5          L77D7 scall L77BE				; copy byte following call count bytes from stackptr2 to $001A
77D9  02                  byte  $02					; copy this many bytes to $001A from this callers return address
77DA  A21A32              ld    REG_32,[REG_1A]		; OLD AD sensor value
77DD  A3729634            ld    REG_34,$96[REG_72]	; NEW AD sensor value $0216 - raw EVP
77E1  A379CA00            ld    REG_36,$00CA[REG_78] ; manged filter factor
      36
77E6  EF7ABE              lcall L3663				; filter
77E9  C21A3E              st    REG_3E,[REG_1A]		; save updated filtered value
77EC  F0                  ret

;****************************************************************
; cmp param byte : REG_40, SET REG_2B bit 4 if equal
77ED  2FCF          L77ED scall L77BE				; copy byte following call count bytes from stackptr2 to $001A
77EF  01                  byte  $01					; copy this many bytes to $001A from this callers return address
77F0  981A40              cmpb  REG_40,REG_1A
77F3  D703                jne   L77F8
77F5  91082B              orb   REG_2B,#$08
77F8  F0            L77F8 ret

;****************************************************************
; 1st param word AND $0202[REG_72], if zero set bit mask REG_1C  in REG_C5 else clr it
77F9  2FC3          L77F9 scall L77BE				; copy byte following call count bytes from stackptr2 to $001A
77FB  03                  byte  $03					; copy this many bytes to REG_1A/1B/1C from this callers return address
77FC  637302021A          and   REG_1A,$0202[REG_72] ; $0382 word
7801  DF04                je    L7807
7803  901CC5              orb   REG_C5,REG_1C
7806  F0                  ret

7807  121C          L7807 notb  REG_1C
7809  701CC5              andb  REG_C5,REG_1C
780C  F0                  ret

;****************************************************************
; Key On Engine Off (KOEO) Self-Tests
780D  3D2C25              jbs   REG_2C,BIT_05,L7835	; jmp if disable EOLT set
7810  EFA1FF              lcall L77B4			; set STO off flag, set STO output low, and set STO trigger
7813  EF670A              lcall L827D			; do h/w RAM/ROM/CPU checks
7816  EF37F8              lcall L7050			; load diagnostic testing registers 
7819  342A05              jbc   REG_2A,BIT_04,L7821	; jump if not VIP_mode_flag : disable no start

781C  EF8DFF        L781C lcall L77AC			; Set STO output on - diddle some flags - why - we're hung?
781F  27FB                sjmp  L781C			; *HANG* - h/w error

7821  EF2000        L7821 lcall L7844			; checksum the ROM
7824  1138                clrb  REG_38			; test selector set to zero
7826  38300C              jbs   REG_30,BIT_00,L7835
7829  91102C              orb   REG_2C,#$10		; STO very fast readout set
782C  AD05D4              ldbze REG_D4,#$05
782F  EF45F7              lcall L6F77			; the skip two returns do not return here 
7832  71EF2C              andb  REG_2C,#$EF		; clear STO very fast readout

7835  91202C        L7835 orb   REG_2C,#$20		; disable EOLT
7838  91402A              orb   REG_2A,#$40		; Set VIP_mode_flag : no start
783B  3F4605              jbs   REG_46,BIT_07,L7843	; if LSO output line 7 is ON (Fuel Pump)
783E  322A02              jbc   REG_2A,BIT_02,L7843	; jump if not VIP_mode_flag : VIP enable

7841  2088                sjmp  L78CB			; zero $01CA VIP_TIMER_EX, incr REG_38 self test index, and return

7843  F0            L7843 ret
;
;************************************************************
; Checksum the ROM
;************************************************************

7844  0130          L7844 clr   REG_30
7846  013C                clr   REG_3C				; clr sum
7848  A16A7842            ld    REG_42,#$786A		; param table address

784C  4643003A      L784C add   REG_3A,Zero,[REG_42]+	; start sum address - $2000
7850  DF0D                je    L785F
7852  A2433E              ld    REG_3E,[REG_42]+	; end sum address - $9FFE

7855  663B3C        L7855 add   REG_3C,[REG_3A]+	; add next ROM word to sum
7858  883E3A              cmp   REG_3A,REG_3E		; end address?
785B  D1F8                jnh   L7855				; loop

785D  27ED                sjmp  L784C				; load next ROM range
785F  883C00        L785F cmp   Zero,REG_3C			; checksum SB zero
7862  DF03                je    L7867               ; jmp good
;
; EEC trouble code : 15 - EEC Read Only Memory failed / EEC Keep Alive Memory failed
;
7864  2B48                scall L7BAE				; push error $15 to $0342 error stack
7866  15                  byte  $15					; checsum error
7867  2062          L7867 sjmp  L78CB				; zero $01CA timer, incr REG_38 self test index, and return
;*************************************************************
7869  FF                  nop						; word alignment byte
;******************** data table *****************************
786A  0020                word $2000				; start address of ROM checksum(set $786B=0 for no checksum test)
786C  FE9F                word $9FFE				; last address of ROM checksum
786E  0000                word $0000				; end of table
;
; $716E Self test jump table entry
;
7870  B03032        L7870 ldb   REG_32,REG_30
7873  28F7                scall L796C
7875  7E                  byte  $7E
7876  90                  byte  $90
7877  12                  byte  $12	; $0112 - ECT raw from AD conversion
7878  01                  byte  $01
7879  61                  byte  $61	; EEC trouble code : 61 - ECT sensor circuit grounded
787A  28F0                scall L796C
787C  12                  byte  $12	
787D  01                  byte  $01	; $0112 - ECT raw from AD conversion
787E  80                  byte  $80
787F  90                  byte  $90
7880  51                  byte  $51	; EEC trouble code : 51 - ECT circuit open
7881  983032              cmpb  REG_32,REG_30
7884  D709                jne   L788F
7886  2B38                scall L7BC0
7888  12                  byte  $12	; $0112 - ECT raw from AD conversion
7889  01                  byte  $01
788A  F8                  byte  $F8	; ROM mangled address range limit Lo
788B  90                  byte  $90
788C  F6                  byte  $F6	; ROM mangled address range limit Hi
788D  90                  byte  $90
788E  21                  byte  $21	; EEC trouble code : 21 - ECT out of range during self test
788F  9BF84B00      L788F cmpb  Zero,$4B[REG_F8]
7893  DF1A                je    L78AF
7895  B372B642            ldb   REG_42,$B6[REG_72]	; timer?
7899  9BF31601            cmpb  REG_42,$0116[REG_F2]
      42
789E  D105                jnh   L78A5
;
; EEC trouble code : MAP/BP sensor out of range during self test
;
78A0  2B0C                scall L7BAE	; push error $22 to $0342 error stack
78A2  22                  byte  $22
78A3  200A                sjmp  L78AF
78A5  EF1803        L78A5 lcall L7BC0
78A8  0A                  byte  $0A	; $010A MAP/BP	
78A9  01                  byte  $01
78AA  02                  byte  $02	; ROM mangled address range limit Lo
78AB  91                  byte  $91
78AC  04                  byte  $04	; ROM mangled address range limit Hi
78AD  91                  byte  $91
78AE  22                  byte  $22	; EEC trouble code : 22 - MAP/BP sensor out of range during self test
78AF  A372A442      L78AF ld    REG_42,$A4[REG_72]	; $0124 MAF raw
78B3  8B798800            cmp   REG_42,$0088[REG_78]
      42
78B8  D311                jnc   L78CB			; zero $01CA timer, incr REG_38 self test index, and return
78BA  8B798E00            cmp   REG_42,$008E[REG_78]
      42
78BF  D305                jnc   L78C6
78C1  B1561A              ldb   REG_1A,#$56	; EEC trouble code : 56 - MAF circuit above maximum voltage
78C4  2003                sjmp  L78C9
78C6  B1261A        L78C6 ldb   REG_1A,#$26	; EEC trouble code : 26 - MAF input out of self test range
78C9  2AE7          L78C9 scall L7BB2			; save REG_1A in $0342 TROUBLE CODE table
; zero $01CA timer, incr REG_38 self test index, and return
78CB  C7724A00      L78CB stb   Zero,$4A[REG_72]	; zero $01CA timer?
78CF  1738                incb  REG_38
78D1  F0                  ret
;
; $716E Self test jump table entry
;
78D2  2870          L78D2 scall L7944
78D4  B03032              ldb   REG_32,REG_30
78D7  2893                scall L796C
78D9  68                  byte  $68
78DA  90                  byte  $90
78DB  14                  byte  $14	; $0114
78DC  01                  byte  $01
78DD  64                  byte  $64	; EEC trouble code : ACT sensor circuit grounded
78DE  288C                scall L796C
78E0  14                  byte  $14	; $0114
78E1  01                  byte  $01
78E2  6A                  byte  $6A
78E3  90                  byte  $90
78E4  54                  byte  $54	; EEC trouble code : ACT sensor circuit open
78E5  983032              cmpb  REG_32,REG_30
78E8  D709                jne   L78F3
78EA  2AD4                scall L7BC0
78EC  14                  byte  $14	; $0114 ACT									
78ED  01                  byte  $01
78EE  F0                  byte  $F0	; ROM mangled address range limit Lo
78EF  90                  byte  $90
78F0  EE                  byte  $EE	; ROM mangled address range limit Hi
78F1  90                  byte  $90
78F2  24                  byte  $24	; EEC trouble code : 24 - ACT sensor out of range during self test
78F3  3ED91B        L78F3 jbs   REG_D9,BIT_06,L7911
78F6  3EE60D              jbs   REG_E6,BIT_06,L7906
78F9  EFD305              lcall L7ECF
78FC  16                  byte  $16	; raw EGR
78FD  01                  byte  $01
78FE  B4                  byte  $B4	; mangle Lo limit
78FF  90                  byte  $90
7900  B0                  byte  $B0	; mangle Hi limit
7901  90                  byte  $90
7902  32                  byte  $32	; EEC trouble code : 32 - EGR not controlling/not seated??
7903  34                  byte  $34	; EEC trouble code : 34 - Insufficient EGR flow
7904  200B                sjmp  L7911
7906  EFC605        L7906 lcall L7ECF
7909  16                  byte  $16	; raw EGR
790A  01                  byte  $01
790B  38                  byte  $38	; mangle Lo limit
790C  91                  byte  $91
790D  34                  byte  $34	; mangle Hi limit
790E  91                  byte  $91
790F  34                  byte  $34	; EEC trouble code : 34 - Insufficient EGR flow
7910  34                  byte  $34	; EEC trouble code : 34 - Insufficient EGR flow
7911  B3FE0242      L7911 ldb   REG_42,$02[REG_FE]		; ROM $9E5C
7915  990342              cmpb  REG_42,#$03
7918  D30B                jnc   L7925
791A  990442              cmpb  REG_42,#$04
791D  D906                jh    L7925
791F  37E703              jbc   REG_E7,BIT_07,L7925
;
; EEC trouble code : 67 - NPS circuit open with Air conditioning on during Self Test
;
7922  2A8A                scall L7BAE	; push error $67 to $0342 error stack
7924  67                  byte  $67	; EEC trouble code : 67 - Neutral Pressure switch (NPS) circuit open
7925  37EE03        L7925 jbc   REG_EE,BIT_07,L792B		; A3C - jump id AC is off
;
; EEC trouble code : 79 - A/C on / Defrost during self-test
;
7928  2A84                scall L7BAE		; push error $79 to $0342 error stack
792A  79                  byte  $79
792B  B3F61442      L792B ldb   REG_42,$14[REG_F6] ; ROM
792F  990142              cmpb  REG_42,#$01
7932  D707                jne   L793B
7934  342704              jbc   REG_27,BIT_04,L793B
;
; EEC trouble code : 52 - Power Steering Pressure Switch circuit open
;
7937  EF7402              lcall L7BAE		; push error $52 to $0342 error stack
793A  52                  byte  $52
793B  282F          L793B scall L796C
793D  52                  byte  $52
793E  90                  byte  $90
793F  0C                  byte  $0C	; $010C VCAL - reference voltage
7940  01                  byte  $01
7941  19                  byte  $19	; EEC trouble code : 19 - Failure in ECC reference voltage
7942  2097                sjmp  L79DB
7944  B03032        L7944 ldb   REG_32,REG_30
7947  2823                scall L796C
7949  70                  byte  $70
794A  90                  byte  $90
794B  22                  byte  $22	; $0122
794C  01                  byte  $01
794D  63                  byte  $63	; EEC trouble code : 63 - TP sensor circuit below minimum voltage
794E  281C                scall L796C
7950  22                  byte  $22	; $0122
7951  01                  byte  $01
7952  6E                  byte  $6E
7953  90                  byte  $90
7954  53                  byte  $53	; EEC trouble code : 53 - TP sensor circuit open, above maximum voltage
7955  983032              cmpb  REG_32,REG_30
7958  D709                jne   L7963
795A  2A64                scall L7BC0
795C  22                  byte  $22	; $0122 TP
795D  01                  byte  $01
795E  5C                  byte  $5C	; ROM mangled address range limit Lo
795F  90                  byte  $90
7960  5E                  byte  $5E	; ROM mangled address range limit Hi
7961  90                  byte  $90
7962  23                  byte  $23	; EEC trouble code : 23 - TP out of range during self test
7963  F0            L7963 ret
;
;*******************************************************
; Entry point for FOUR params
; 
; Compare two maggled values values
;
; from $73AA
;   data 1 = 907E - mangles into ROM address $8ED8
;   data 2 = 0121 (ECT AD value) - 'mangles' into $0121 (no mangle because bit 15 is clear)
;
7964  91082B        L7964 orb   REG_2B,#$08		; set REG_2B bit 3
7967  2E55                scall L77BE			; copy byte following call count bytes from stackptr2 to $001A
7969  04                  byte  $04				; copy this many bytes to $001A from this callers return address
796A  2003                sjmp  L796F
;
; entry point 2 for FIVE params
;
; Compare two mangled values and post trouble code if range error - data follows call
;
796C  2E50          L796C scall L77BE			; copy byte following call count bytes from stackptr2 to $001A
796E  05                  byte  $05				; copy this many bytes to $001A from this callers return address
                                                        ; 1st and 2nd bytes are 1st value to mangle
                                                        ; 3rd and 4th bytes are 2nd value to mangle
                                                        ; 5th byte is the trouble code if out of range

796F  281A          L796F scall L798B			; make 2 params into address, load contents, mangle? into ROM address back into param pointer
7971  1A                  byte  $1A
7972  00                  byte  $00

7973  2816                scall L798B			; make 2 params into address, load contents, mangle? into ROM address back into param pointer
7975  1C                  byte  $1C
7976  00                  byte  $00

7977  A21A42              ld    REG_42,[REG_1A]		; ROM address 1
797A  8A1C42              cmp   REG_42,[REG_1C]		; ROM address 2
797D  D108                jnh   L7987
797F  3B2B08              jbs   REG_2B,BIT_03,L798A	; jump if only FOUR params (not FIVE)
7982  B01E1A              ldb   REG_1A,REG_1E		; fifth param - the trouble code
7985  2A2B                scall L7BB2			; save REG_1A in $0342 TROUBLE CODE table
7987  71F72B        L7987 andb  REG_2B,#$F7		; clrs REG_2B bit 3 for next time we're called
798A  F0            L798A ret
;
;*******************************************************
; mangle word value [INDIRECT] behind caller
; 16 bit value field
; bit  15 flag to exit with operation
; bits 12-14 are ROM REG index
; bits 0-11 are ROM REG offset
798B  A13E0016      L798B ld    REG_16,#$003E
798F  2E31                scall L77C2			; copy byte following call count bytes from stackptr2 to [REG_16]
7991  02                  byte  $02
7992  A23E42              ld    REG_42,[REG_3E]		; reads value from caller data param address!
7995  374314              jbc   REG_43,BIT_07,L79AC	; return if neg ?
7998  AC433A              ldbze REG_3A,REG_43		; Hi byte of value
799B  710F43              andb  REG_43,#$0F		; Hi byte - mask off offset high bits
799E  71703A              andb  REG_3A,#$70		; mask out three ROM REG index bits
79A1  08033A              shr   REG_3A,#$03		; (shift >> 4 and *2 for word index) divide by 8
79A4  673BF000            add   REG_42,$00F0[REG_3A]	; add ROM REG to offset to get ROM pointer
      42
79A9  C23E42              st    REG_42,[REG_3E]		; saves ROM address to REG_3E address INDIRECT!
79AC  F0            L79AC ret
;
; $716E Self test jump table entry
;
79AD  B378F33A      L79AD ldb   REG_3A,$F3[REG_78]
79B1  E03A03              djnz  REG_3A,L79B7
79B4  30C404              jbc   REG_C4,BIT_00,L79BB
79B7  1738          L79B7 incb  REG_38
79B9  2710                sjmp  L78CB			; zero $01CA timer, incr REG_38 self test index, and return
79BB  9101D9        L79BB orb   REG_D9,#$01
79BE  918046              orb   REG_46,#$80		; LSO output line 7 ON (Fuel Pump)
79C1  EF7704              lcall L7E3B
79C4  74                  byte  $74
79C5  90                  byte  $90
79C6  3CDF03              jbs   REG_DF,BIT_04,L79CC
;
; EEC trouble code : 96 - Themactor Air System inoperative
;
79C9  29E3                scall L7BAE			; push error $96 to $0342 error stack
79CB  96                  byte  $96
79CC  26FD          L79CC sjmp  L78CB			; zero $01CA timer, incr REG_38 self test index, and return
;
; $716E Self test jump table entry
;
79CE  EF6A04        L79CE lcall L7E3B
79D1  74                  byte  $74
79D2  90                  byte  $90
79D3  34DF03              jbc   REG_DF,BIT_04,L79D9
;
; EEC trouble code : 95 - Fuel Pump secondary circuit failure
;
79D6  29D6                scall L7BAE			; push error $95 to $0342 error stack
79D8  95                  byte  $95
79D9  26F0          L79D9 sjmp  L78CB			; zero $01CA timer, incr REG_38 self test index, and return
79DB  71DFE6              andb  REG_E6,#$DF		; clr bit 6
79DE  A1F97934            ld    REG_34,#$79F9		; 'return' address
79E2  26E7                sjmp  L78CB			; zero $01CA timer, incr REG_38 self test index, and return
;
; $716E Self test jump table entry
;
; where does REG_34 come from?
;
79E4  3DE602              jbs   REG_E6,BIT_05,L79E9
79E7  2906                scall L7AEF			; force all LSO and HSO otputs off and STO on
79E9  B12042        L79E9 ldb   REG_42,#$20
79EC  C773A20042          stb   REG_42,$00A2[REG_72]	; $0202 set
79F1  C773A10042          stb   REG_42,$00A1[REG_72]	; $0201 
79F6  C834                push  REG_34			; address to jump to ???
79F8  F0                  ret

79F9  B3FE0B3A            ldb   REG_3A,$0B[REG_FE]	; ROM $9E65 thermactor_present_switch = 1.0
79FD  E03A0C              djnz  REG_3A,L7A0C

; Idle Air Control Open Circuit Check
7A00  2874                scall L7A76			; Open Circuit Check function
7A02  81                  byte  $81			; Trouble code 81 AM2 circuit failure
7A03  F6                  byte  $F6			; ROM limit offset from $8F86
7A04  10                  byte  $10			; output bit mask
7A05  47                  byte  $47			; output register - Idle Air Control

; Air Management 1 Open Circuit Check
7A06  286E                scall L7A76			; Open Circuit Check function
7A08  82                  byte  $82			; Trouble code 82 AM1 circuit failure
7A09  F8                  byte  $F8			; ROM limit offset from $8F86
7A0A  08                  byte  $08			; output bit mask
7A0B  47                  byte  $47			; output register - Air Management 1
7A0C  B11442        L7A0C ldb   REG_42,#$14
7A0F  C772AE42            stb   REG_42,$AE[REG_72]

; Canister purge Open Circuit Check
7A13  287C                scall L7A91			; Open Circuit Check function
7A15  85                  byte  $85			; Trouble code 85 Canister purge circuit failure
7A16  FE                  byte  $FE			; ROM limit offset from $8F86
7A17  2D                  byte  $2D			; $012D Canister Purge on time
7A18  01                  byte  $01

; Fuel Pump Open Circuit Check
7A19  285B                scall L7A76			; Open Circuit Check function
7A1B  87                  byte  $87			; Trouble code 87 Fuel pump primary circuit failure
7A1C  00                  byte  $00			; ROM limit offset from $8F86
7A1D  80                  byte  $80			; output bit mask
7A1E  46                  byte  $46			; output register - Fuel Pump
7A1F  983000              cmpb  Zero,REG_30
7A22  DF0D                je    L7A31
7A24  B3314103            ldb   REG_3A,$0341[REG_30]
      3A
7A29  99873A              cmpb  REG_3A,#$87
7A2C  D703                jne   L7A31
7A2E  9101C4              orb   REG_C4,#$01
7A31  3ED906        L7A31 jbs   REG_D9,BIT_06,L7A3A
7A34  285B                scall L7A91
7A36  84FCD3              xor   REG_D3,REG_FC
7A39  0091                skip  REG_91
7A3B  20E6                sjmp  L7B23
7A3D  B3F67442            ldb   REG_42,$74[REG_F6]	; ROM $941C fan_control_enable
7A41  E04211              djnz  REG_42,L7A55
7A44  C7724A00            stb   Zero,$4A[REG_72]	; zero $01CA timer?

; Electro Drive Fan Open Circuit Check
7A48  282C                scall L7A76			; Open Circuit Check function
7A4A  88                  byte  $88			; Trouble code 88 electro drive fan circuit failure???
7A4B  02                  byte  $02			; ROM limit offset from $8F86
7A4C  20                  byte  $20			; output bit mask
7A4D  47                  byte  $47			; output register - ElectroDriveFan
7A4E  EFEA03              lcall L7E3B
7A51  BD9028              ldbse REG_28,#$90
7A54  9AB3F6              cmpb  REG_F6,[REG_B2]+
7A57  7542E0              addb  REG_E0,#$42
7A5A  42                  byte  $42
7A5B  0F                  byte  $0F
7A5C  C7724A00            stb   Zero,$4A[REG_72]	; zero $01CA timer?

; Hi Fan Open Circuit Check
7A60  2814                scall L7A76			; Open Circuit Check function
7A62  83                  byte  $83				; Trouble code 83 fan circuit failure???
7A63  FA                  byte  $FA				; ROM limit offset from $8F86
7A64  40                  byte  $40				; output bit mask
7A65  47                  byte  $47				; REG_47 bit 6 - HiFan output line
7A66  EFD203              lcall L7E3B
7A69  BE                  byte  $BE
7A6A  90                  byte  $90
7A6B  71DFE6              andb  REG_E6,#$DF
7A6E  287F                scall L7AEF			; call set HSO_Time_Hold = Master_IO_Timer_Lo + #$0003
7A70  9110D9              orb   REG_D9,#$10
7A73  E70306              ljmp  L8079  			 ; clr $01CA timer, incr REG_38 self test index, set bit flag and return
;
;*****************************************************************
; This performs 'circuit' tests
;
; The OCC AD channel must be a supply voltage to the actuators
; We measure any variation in voltage when we switch the selected output line
;
; Four data byte follow calls to this function (REG_1A,1B,1C,1D)
; REG_1A - is Trouble Code if there is an error
; REG_1B - ROM loc for limit $8F86 + this offset (word)
; REG_1C - parameter flag - mask to select the device (Fan, CANP, FuelPump etc)
; REG_1D - pointer to SFR flag byte usually REG_46 or 47 for output lines
;
7A76  2829          L7A76 scall L7AA1			; load params from stack & OCC base line test of circuit
7A78  AC1D20              ldbze REG_20,REG_1D		; fourth param byte to word

; toggle output line for this device
7A7B  B2201D              ldb   REG_1D,[REG_20]		; load contents of SFR 
7A7E  941C1D              xorb  REG_1D,REG_1C		; mask contents with third param 
7A81  C6201D              stb   REG_1D,[REG_20]		; store back in [SFR]

7A84  2837                scall L7ABD		; read OCC and compre to level before - set Trouble code if out of range
7A86  3DE606              jbs   REG_E6,BIT_05,L7A8F	; jmp if ?

; UN-toggle output line for this same device
7A89  941C1D              xorb  REG_1D,REG_1C		; xor 3rd and fourth param (if calls did not change them)
7A8C  C6201D              stb   REG_1D,[REG_20]		; store fourth param? to [SFR]

7A8F  200D          L7A8F sjmp  L7A9E			; return to callers caller

; Four data byte follow calls to this function
7A91  280E          L7A91 scall L7AA1			; load params from stack & OCC base line test of circuit
7A93  B18042              ldb   REG_42,#$80
7A96  C61C42              stb   REG_42,[REG_1C]
7A99  2822                scall L7ABD		; read OCC and compre to level before - set Trouble code if out of range
7A9B  C61C00              stb   Zero,[REG_1C]

7A9E  CC34          L7A9E pop   REG_34
7AA0  F0                  ret
;
;****************************************************************
; Read reference base level OCC AD channel for the test circuit line
7AA1  2833          L7AA1 scall L7AD6			; Repeatedly read AD channels for $5161 IOtimes
7AA3  CC1E                pop   REG_1E			; back up stack by one call
7AA5  2D17                scall L77BE			; copy byte following call count bytes from stackptr2 to $001A
7AA7  04                  byte  $04			; copy this many bytes to $001A from this callers return address
7AA8  C81E                push  REG_1E			; restore stack

7AAA  BC1B1E              ldbse REG_1E,REG_1B		; circuit test param 2 - ROM loc selector
7AAD  652C011E            add   REG_1E,#$012C
7AB1  64F21E              add   REG_1E,REG_F2		; REG_1E + ROM $8E5A + $12C = $8F86 + REG_1E

7AB4  A3728E16            ld    REG_16,$8E[REG_72]	; $010E - OCC - Open Circuit Check AD value
7AB8  C3725E16            st    REG_16,$5E[REG_72]	; $01DE - OCC reference level save value
7ABC  F0                  ret
;
;***************************************************************
; Read the switched OCC level for the test circuit line
; Compare to the reference OCC level
7ABD  2817          L7ABD scall L7AD6				; Repeatedly read AD channels for $5161 IOtimes
7ABF  A3725E16            ld    REG_16,$5E[REG_72]	; $01DE - OCC reference level save value
7AC3  6B728E16      L7AC3 sub   REG_16,$8E[REG_72]	; $010E - OCC - Open Circuit Check AD value - difference
7AC7  DB02                jc    L7ACB				; jmp if positive
7AC9  0316                neg   REG_16				; ABS OCC value
7ACB  8A1E16        L7ACB cmp   REG_16,[REG_1E]		; ROM limit for this circuit
7ACE  DB03                jc    L7AD3				; jmp if OCC >= ROM Limit - GOOD!
7AD0  E73204              ljmp  L7F05				; Post REG_1A Trouble Code - open XXXX circuit error
7AD3  111A          L7AD3 clrb  REG_1A				; clr trouble code
7AD5  F0                  ret
;
;********************************************************
; Repeatedly read AD channels for $5161 IOtimes
; entry point
7AD6  C03C06        L7AD6 st    Master_IO_Timer_Lo,REG_3C ; read start time

7AD9  483C063E      L7AD9 sub   REG_3E,Master_IO_Timer_Lo,REG_3C ; calc time passed
7ADD  8961513E            cmp   REG_3E,#$5161		; loop until $5161 IO times have passed
7AE1  DB0B                jc    L7AEE			; return
7AE3  EF8FF5              lcall L7075			; Save diagnostic testing registers
7AE6  EF45A7              lcall L222E			; read all the AD channels <<<<<<<<<<<<<<<<<<<<<<<<<<<
7AE9  EF64F5              lcall L7050			; load diagnostic testing registers
7AEC  27EB                sjmp  L7AD9

7AEE  F0            L7AEE ret
;
;********************************************************
;
; This function is funny - it unilaterally forces all LSO lines and BiDir lines
;
7AEF  A1002046      L7AEF ld    REG_46,#$2000			; Electronic Control Assembly DOT
							; LSO output line 5 (STO) ONLY ON
							; all bidi lines OFF
7AF3  45030006            add   HSO_Time_Hold,Master_IO_Timer_Lo,#$0003
      0E
7AF8  01D2                clr   REG_D2
7AFA  01B8                clr   REG_B8
7AFC  C772AC00            stb   Zero,$AC[REG_72] 		; $012C ?
7B00  F0                  ret
;
; $716E Self test jump table entry
;
7B01  3BD608        L7B01 jbs   REG_D6,BIT_03,L7B0C
7B04  1738                incb  REG_38					; incr self test index

7B06  2FE7          L7B06 scall L7AEF					; call set HSO_Time_Hold = Master_IO_Timer_Lo + #$0003

7B08  85000046            xor   REG_46,#$0000			; What does this instruction do??????? LSO & BiDi outputs
								

7B0C  C3724200      L7B0C st    Zero,$42[REG_72]		; zero $01C2 timer OUTTMR
7B10  71F7D8              andb  REG_D8,#$F7				; bit 3 off
7B13  71CFE6              andb  REG_E6,#$CF				; bits 4,5 off
7B16  C7724A00      L7B16 stb   Zero,$4A[REG_72]		; zero $01CA timer? VIP_TIMER_EX
7B1A  F0            L7B1A ret
;
;********************************************************
;
7B1B  EF07F8        L7B1B lcall L7325
7B1E  3BD6F9              jbs   REG_D6,BIT_03,L7B1A
7B21  A378E41C            ld    REG_1C,$E4[REG_78]
7B25  8B72A21C            cmp   REG_1C,$A2[REG_72]		; compare to raw TP
7B29  DB3B                jc    L7B66
7B2B  9108D8              orb   REG_D8,#$08

7B2E  3D4635              jbs   REG_46,BIT_05,L7B66		; if LSO output line 5 (STO) is ON (MIL)

7B31  B3F67542            ldb   REG_42,$75[REG_F6]		; ROM $941D fan_high_speed_enable
7B35  E04217              djnz  REG_42,L7B4F
7B38  9B784018            cmpb  REG_18,$40[REG_78]
7B3C  D111                jnh   L7B4F
7B3E  3CE60C              jbs   REG_E6,BIT_04,L7B4D
7B41  71DFE6              andb  REG_E6,#$DF
7B44  9110E6              orb   REG_E6,#$10
7B47  AD05D4              ldbze REG_D4,#$05
7B4A  EF2AF4              lcall L6F77
7B4D  2016          L7B4D sjmp  L7B65					; return

7B4F  B3F67442      L7B4F ldb   REG_42,$74[REG_F6]		; ROM $941C fan_control_enable
7B53  E04210              djnz  REG_42,L7B66
7B56  9B783F18            cmpb  REG_18,$3F[REG_78]
7B5A  D109                jnh   L7B65
7B5C  3DE606              jbs   REG_E6,BIT_05,L7B65
7B5F  9120E6              orb   REG_E6,#$20
7B62  EF0FF4              lcall L6F74
7B65  F0            L7B65 ret

7B66  33D837        L7B66 jbc   REG_D8,BIT_03,L7BA0
7B69  A378E61C            ld    REG_1C,$E6[REG_78]
7B6D  8B72A21C            cmp   REG_1C,$A2[REG_72]		compare to raw TP
7B71  D12D                jnh   L7BA0
7B73  354602              jbc   REG_46,BIT_05,L7B78		; if LSO output line 5 (STO) is OFF (MIL)
7B76  278E                sjmp  L7B06				; funny hardware???

7B78  85711A46      L7B78 xor   REG_46,#$1A71			; funny instruction???

7B7C  35E603              jbc   REG_E6,BIT_05,L7B82
7B7F  952047              xorb  REG_47,#$20			; REG_47 bit 5 TOGGLE (Fan?)
7B82  34E603        L7B82 jbc   REG_E6,BIT_04,L7B88
7B85  954047              xorb  REG_47,#$40			; REG_47 bit 6 TOGGLE (Fan?)
7B88  A1008042      L7B88 ld    REG_42,#$8000
7B8C  C0D242              st    REG_42,REG_D2
7B8F  C0B842              st    REG_42,REG_B8
7B92  B1101E              ldb   REG_1E,#$10
7B95  45030006            add   HSO_Time_Hold,Master_IO_Timer_Lo,#$0003
      0E
7B9A  C772AC43            stb   REG_43,$AC[REG_72]		; REG_43 = $80
7B9E  276C                sjmp  L7B0C					; exit w/o funny hardware instruction

7BA0  A372421A      L7BA0 ld    REG_1A,$42[REG_72]		; $01C2 timer?
7BA4  8958021A            cmp   REG_1A,#$0258
7BA8  D102                jnh   L7BAC
7BAA  275A                sjmp  L7B06			

7BAC  2768          L7BAC sjmp  L7B16			; exit
;
;********************************************************
; pushes TROUBLE CODE behind caller op to error table @ $0342 
;
7BAE  EF0DFC        L7BAE lcall L77BE			; copy byte following call count bytes from stackptr2 to $001A
7BB1  01                  byte  $01				; copy this many bytes to $001A from this callers return address
;
; save REG_1A in $0342 TROUBLE CODE table
; save range error code up to index 19
; trouble code in REG_1A
;
7BB2  89130030      L7BB2 cmp   REG_30,#$0013		; 19 max error code positions in table
7BB6  DB07                jc    L7BBF
7BB8  C7314203            stb   REG_1A,$0342[REG_30] ; $0342 is base of Hard Trouble Code Error Table
      1A
7BBD  0730                inc   REG_30
7BBF  F0            L7BBF ret
;
;***************************************************************
; Range test word 0 to mangled ROM 1 and mangled ROM 2 - push error code to $0342 table 
;
7BC0  EFFBFB        L7BC0 lcall L77BE			; copy byte following call count bytes from stackptr2 to $001A - copies 7 bytes to $001A/1B/1C/1E/1F/20/21
7BC3  07                  byte  $07			; copy this many bytes to $001A from this callers return address
							; params are placed in REG_1A/1B/1C/1D/1E/1F/20
							; 1st and 2nd params are value to check
							; 3rd and 4th params are (mangles?) are value limit low
                                                        ; 5th and 6th params are (mangled?) are value limit high
                                                        ; 7th param is trouble code
7BC4  2DC5                scall L798B			; mangle the value at $001C into ROM if high bit set
7BC6  1C                  byte  $1C
7BC7  00                  byte  $00
7BC8  2DC1                scall L798B			; mangle the value at $001E into ROM if high bit set
7BCA  1E                  byte  $1E
7BCB  00                  byte  $00
7BCC  A21A42              ld    REG_42,[REG_1A]		; (AD conversion) value to check
7BCF  8A1C42              cmp   REG_42,[REG_1C]		; range limit low?
7BD2  D305                jnc   L7BD9			; err
7BD4  8A1E42              cmp   REG_42,[REG_1E]		; range limit high?
7BD7  D106                jnh   L7BDF			; range ok

7BD9  B0201A        L7BD9 ldb   REG_1A,REG_20		; save range trouble code in table
7BDC  EFD3FF              lcall L7BB2			; save REG_1A in $0342 TROUBLE CODE table

7BDF  F0            L7BDF ret
;
; $716E Self test jump table entry
;
7BE0  EFD1FB        L7BE0 lcall L77B4			; set STO off flag, set STO output low, and set STO trigger
7BE3  0130                clr   REG_30
7BE5  71FD2B              andb  REG_2B,#$FD		; clear Self Test Output trigger
7BE8  71FE2B              andb  REG_2B,#$FE
7BEB  C7739200            stb   Zero,$0092[REG_72]	; $0112 -  clear ECT raw ?????????????????????????
      00
7BF0  71EF2B              andb  REG_2B,#$EF
7BF3  9BF38E00      L7BF3 cmpb  Zero,$008E[REG_F2]	; ROM
      00
7BF8  D742                jne   L7C3C
7BFA  51B8C522            andb  REG_22,REG_C5,#$B8
7BFE  DF3C                je    L7C3C
;
; EEC trouble code : 98 - Hard Fault present
;
7C00  2FAC                scall L7BAE			; push error $98 to $0342 error stack
7C02  98                  byte  $98
7C03  A3730202            ld    REG_22,$0202[REG_72]	; $0382
      22
7C08  302203              jbc   REG_22,BIT_00,L7C0E
;
; EEC trouble code : 64 - ACT sensor fault or circuit grounded
;
7C0B  2FA1                scall L7BAE			; push error $64 to $0342 error stack
7C0D  64                  byte  $64
7C0E  312203        L7C0E jbc   REG_22,BIT_01,L7C14
;
; EEC trouble code : 54 - ACT sensor fault or circuit open
;
7C11  2F9B                scall L7BAE		; push error $54 to $0342 error stack
7C13  54                  byte  $54		
7C14  322203        L7C14 jbc   REG_22,BIT_02,L7C1A
;
; EEC trouble code : 61 - ECT sensor grounded
;
7C17  2F95                scall L7BAE		; push error $61 to $0342 error stack
7C19  61                  byte  $61
7C1A  332203        L7C1A jbc   REG_22,BIT_03,L7C20
;
; EEC trouble code : 51 - ECT sensor open
;
7C1D  2F8F                scall L7BAE		; push error $51 to $0342 error stack
7C1F  51                  byte  $51
7C20  362203        L7C20 jbc   REG_22,BIT_06,L7C26
;
; EEC trouble code : 63 - TP sensor circuit below minimum voltage
;
7C23  2F89                scall L7BAE		; push error $63 to $0342 error stack
7C25  63                  byte  $63
7C26  372203        L7C26 jbc   REG_22,BIT_07,L7C2C
;
; EEC trouble code : 53 - TP sensor circuit open, above maximum voltage
;
7C29  2F83                scall L7BAE		; push error $53 to $0342 error stack
7C2B  53                  byte  $53
7C2C  312303        L7C2C jbc   REG_23,BIT_01,L7C32
;
; EEC trouble code : 56 - TPS sensor circuit below minimum voltage
;
7C2F  2F7D                scall L7BAE		; push error $56 to $0342 error stack
7C31  56                  byte  $56
7C32  302303        L7C32 jbc   REG_23,BIT_00,L7C38
;
; EEC trouble code : 66 - TPS sensor circuit open, above maximum voltage
;
7C35  2F77                scall L7BAE		; push error $66 to $0342 error stack
7C37  66                  byte  $66
7C38  B12238        L7C38 ldb   REG_38,#$22
7C3B  F0                  ret
;
;**************************************************************
;
7C3C  A3FE2C1C      L7C3C ld    REG_1C,$2C[REG_FE]	; ROM
7C40  C3738A00            st    REG_1C,$008A[REG_72]	; HEGO1 delta time initial value??
      1C
7C45  C3738C00            st    REG_1C,$008C[REG_72]	; HEGO2 delta time initial value??
      1C
7C4A  A3FE323E            ld    REG_3E,$32[REG_FE]	; ROM
7C4E  C3726E3E            st    REG_3E,$6E[REG_72]
7C52  71BF4F              andb  REG_4F,#$BF				; clr Knock Enabled
7C55  019E                clr   REG_9E
7C57  A1000142            ld    REG_42,#$0100
7C5B  C3733406            st    REG_42,$0634[REG_72]
      42
7C60  C3733606            st    REG_42,$0636[REG_72]
      42
7C65  A378D0C2            ld    REG_C2,$D0[REG_78]
7C69  01D2                clr   REG_D2
7C6B  914046              orb   REG_46,#$40			; LSO output line 6 ON (Wide Open THrottle A/C cutout)
7C6E  71F746              andb  REG_46,#$F7			; LSO output line 3 OFF (Idle Speed Control)
7C71  71EF47              andb  REG_47,#$EF			; REG_47 bit 4 OFF (Air management2)
7C74  C772AC00            stb   Zero,$AC[REG_72]	; $012C
7C78  9103D7              orb   REG_D7,#$03			; DOO trouble codes ?
7C7B  71F3E6              andb  REG_E6,#$F3
7C7E  EF98F6              lcall L7319
7C81  E78A02              ljmp  L7F0E

7C84  29B5                scall L7E3B
7C86  30                  byte  $30
7C87  F0                  byte  $F0
7C88  A3FE3232            ld    REG_32,$32[REG_FE]
7C8C  090532              shl   REG_32,#$05
7C8F  6B728832            sub   REG_32,$88[REG_72]	; filtered sensor output - in place ($0108) - filtered RPM
7C93  D602                jge   L7C97
7C95  0332                neg   REG_32
7C97  2CD3          L7C97 scall L796C
7C99  32                  byte  $32	; $0032
7C9A  00                  byte  $00
7C9B  34                  byte  $34
7C9C  F0                  byte  $F0
7C9D  12                  byte  $12	; EEC trouble code : 12 - Cannot control RPM during high RPM test
7C9E  91102B              orb   REG_2B,#$10
7CA1  226B                sjmp  L7F0E
;
; Diagnostic Proc table A
;
7CA3  2F1B                scall L7BC0
7CA5  12                  byte  $12	; $0112 - ECT raw from AD conversion
7CA6  01                  byte  $01
7CA7  FC                  byte  $FC	; ROM mangled address range limit Lo							
7CA8  90                  byte  $90
7CA9  FA                  byte  $FA	; ROM mangled address range limit Hi
7CAA  90                  byte  $90
7CAB  21                  byte  $21	; EEC trouble code : 21 - ECT out of range during self test
7CAC  2F12                scall L7BC0
7CAE  24                  byte  $24	; $0124 MAF sensor (raw?)								
7CAF  01                  byte  $01
7CB0  0A                  byte  $0A	; ROM mangled address range limit Lo				
7CB1  91                  byte  $91
7CB2  0C                  byte  $0C	; ROM mangled address range limit Hi
7CB3  91                  byte  $91
7CB4  26                  byte  $26	; EEC trouble code : 26 - VAF? MAF ?sensor out of range during self test
7CB5  2F09                scall L7BC0
7CB7  22                  byte  $22	; $0122
7CB8  01                  byte  $01
7CB9  60                  byte  $60	; ROM mangled address range limit Lo
7CBA  90                  byte  $90
7CBB  62                  byte  $62	; ROM mangled address range limit Hi
7CBC  90                  byte  $90
7CBD  23                  byte  $23	; EEC trouble code : 23 - TP sensor out of range during self test
7CBE  2F00                scall L7BC0
7CC0  14                  byte  $14	; $0114 ACT
7CC1  01                  byte  $01
7CC2  F4                  byte  $F4	; ROM mangled address range limit Lo
7CC3  90                  byte  $90
7CC4  F2                  byte  $F2	; ROM mangled address range limit Hi
7CC5  90                  byte  $90
7CC6  24                  byte  $24	; EEC trouble code : 24 - ACT sensor out of range during self test
7CC7  2245                sjmp  L7F0E
;
; Diagnostic Proc table A
;
7CC9  A3728842            ld    REG_42,$88[REG_72]	; filtered sensor output - in place ($0108) - filtered RPM
7CCD  8B78D842            cmp   REG_42,$D8[REG_78]
7CD1  DB04                jc    L7CD7
7CD3  B11238              ldb   REG_38,#$12
7CD6  F0                  ret

7CD7  91E0D7        L7CD7 orb   REG_D7,#$E0
7CDA  28FF                scall L7DDB
7CDC  D703                jne   L7CE1
7CDE  911CD7              orb   REG_D7,#$1C
7CE1  2953          L7CE1 scall L7E36
7CE3  2229                sjmp  L7F0E
;
; Diagnostic Proc table A
;
7CE5  372B03              jbc   REG_2B,BIT_07,L7CEB	; jump if no HEGO1 cross over voltage detected yet
7CE8  71BFD7              andb  REG_D7,#$BF
7CEB  362B03        L7CEB jbc   REG_2B,BIT_06,L7CF1	; jump if no HEGO2 cross over voltage detected yet
7CEE  71F7D7              andb  REG_D7,#$F7
7CF1  3ED707        L7CF1 jbs   REG_D7,BIT_06,L7CFB
7CF4  3BD704              jbs   REG_D7,BIT_03,L7CFB
7CF7  293D                scall L7E36
7CF9  2213                sjmp  L7F0E
7CFB  28EB          L7CFB scall L7DE8
7CFD  5690293A            addb  REG_3A,REG_29,[REG_90]
7D01  2EF0                scall L7BF3
7D03  36D703              jbc   REG_D7,BIT_06,L7D09
;
; EEC trouble code : 42 - EGO sensor indicates system rich
;
7D06  2EA6                scall L7BAE		; push error $42 to $0342 error stack
7D08  42                  byte  $42
7D09  33D703        L7D09 jbc   REG_D7,BIT_03,L7D0F
;
; EEC trouble code : 92 - Air/Fuel mixture not within Self test range
;
7D0C  2EA0                scall L7BAE		; push error $92 to $0342 error stack
7D0E  92                  byte  $92
7D0F  20B7          L7D0F sjmp  L7DC8
;
; Diagnostic Proc table A
;
7D11  3F2B03              jbs   REG_2B,BIT_07,L7D17	; jump if HEGO1 cross over voltage detected
7D14  717FD7              andb  REG_D7,#$7F
7D17  3E2B03        L7D17 jbs   REG_2B,BIT_06,L7D1D	; jump if HEGO2 cross over voltage detected
7D1A  71EFD7              andb  REG_D7,#$EF
7D1D  3FD705        L7D1D jbs   REG_D7,BIT_07,L7D25
7D20  3CD702              jbs   REG_D7,BIT_04,L7D25
7D23  21E9                sjmp  L7F0E
7D25  28BC          L7D25 scall L7DE3	; Word behind caller is 'filter' to scale time delta (ROM range limited to $010A)
7D27  54                  byte  $54
7D28  90                  byte  $90
7D29  A3738A0042          ld    REG_42,$008A[REG_72]
7D32  D104                jnh   L7D38
7D34  1538                decb  REG_38
7D36  21D6                sjmp  L7F0E

7D38  2901          L7D38 scall L7E3B
7D3A  87                  byte  $87
7D3B  B0                  byte  $B0
7D3C  37D703              jbc   REG_D7,BIT_07,L7D42	; jmp on NO ERR
;
; EEC trouble code : 41 - EGO sensor indicates system lean
;
7D3F  2E6D                scall L7BAE		; push error $41 to $0342 error stack
7D41  41                  byte  $41
7D42  34D703        L7D42 jbc   REG_D7,BIT_04,L7D48
;
; EEC trouble code : 91 - Air/Fuel mixture not with Self test range
;
7D45  2E67                scall L7BAE		; push error $91 to $0342 error stack
7D47  91                  byte  $91
7D48  207E          L7D48 sjmp  L7DC8
;
; Diagnostic Proc table A
;
7D4A  B378CD1A            ldb   REG_1A,$CD[REG_78]
7D4E  301A77              jbc   REG_1A,BIT_00,L7DC8
7D51  B3FE0B1A            ldb   REG_1A,$0B[REG_FE]		; ROM $9E65 thermactor_present_switch = 1.0
7D55  301A70              jbc   REG_1A,BIT_00,L7DC8
7D58  2889                scall L7DE3	; Word behind caller is 'filter' to scale time delta (ROM range limited to $010A)
7D5A  54                  byte  $54
7D5B  90                  byte  $90
7D5C  28DD                scall L7E3B
7D5E  56                  byte  $56
7D5F  91                  byte  $91
7D60  910847              orb   REG_47,#$08			; REG_47 bit 3 ON - (Air management1)
7D63  911047              orb   REG_47,#$10			; REG_47 bit 4 on - (Air management2)
7D66  21A6                sjmp  L7F0E
;
; Diagnostic Proc table A
;
7D68  372B03              jbc   REG_2B,BIT_07,L7D6E	; jump if no HEGO1 cross over voltage detected yet
7D6B  71DFD7              andb  REG_D7,#$DF
7D6E  362B03        L7D6E jbc   REG_2B,BIT_06,L7D74	; jump if no HEGO2 cross over voltage detected yet
7D71  71FBD7              andb  REG_D7,#$FB
7D74  3DD703        L7D74 jbs   REG_D7,BIT_05,L7D7A
7D77  32D712              jbc   REG_D7,BIT_02,L7D8C
7D7A  28BF          L7D7A scall L7E3B
7D7C  58                  byte  $58
7D7D  91                  byte  $91
7D7E  32D703              jbc   REG_D7,BIT_02,L7D84
;
; EEC trouble code : 94 - Thermactor Air System inoperative
;
7D81  2E2B                scall L7BAE		; push error $94 to $0342 error stack
7D83  94                  byte  $94
7D84  35D703        L7D84 jbc   REG_D7,BIT_05,L7D8A
;
; EEC trouble code : 44 - Thermactor Air System inoperative
;
7D87  2E25                scall L7BAE		; push error $44 to $0342 error stack
7D89  44                  byte  $44
7D8A  2036          L7D8A sjmp  L7DC2
7D8C  71EF47        L7D8C andb  REG_47,#$EF			; REG_47 bit 4 OFF (Air management2)
7D8F  217D                sjmp  L7F0E
;
; Diagnostic Proc table A
;
7D91  2848                scall L7DDB
7D93  D703                jne   L7D98
7D95  362B0A              jbc   REG_2B,BIT_06,L7DA2	; jump if no HEGO2 cross over voltage detected yet
7D98  372B07        L7D98 jbc   REG_2B,BIT_07,L7DA2	; jump if no HEGO1 cross over voltage detected yet
7D9B  289E                scall L7E3B
7D9D  59                  byte  $59
7D9E  91                  byte  $91
;
; EEC trouble code : 45 - Thermactor air upstream during Self test
;
7D9F  2E0D                scall L7BAE		; push error $45 to $0342 error stack
7DA1  45                  byte  $45
7DA2  71F747        L7DA2 andb  REG_47,#$F7			; REG_47 bit 3 OFF (Air management1)
7DA5  911047              orb   REG_47,#$10			; REG_47 bit 4 ON (Air management2)
7DA8  2164                sjmp  L7F0E
;
; Diagnostic Proc table A
;
7DAA  B378CE1A            ldb   REG_1A,$CE[REG_78]
7DAE  301A11              jbc   REG_1A,BIT_00,L7DC2
7DB1  2888                scall L7E3B
7DB3  57                  byte  $57
7DB4  91                  byte  $91
7DB5  2824                scall L7DDB
7DB7  D703                jne   L7DBC
7DB9  362B06              jbc   REG_2B,BIT_06,L7DC2	; jump if no HEGO2 cross over voltage detected yet
7DBC  372B03        L7DBC jbc   REG_2B,BIT_07,L7DC2	; jump if no HEGO1 cross over voltage detected yet
;
; EEC trouble code : 46 - Thermactor air not by-passed during Self test
;
7DBF  2DED                scall L7BAE		; push error $46 to $0342 error stack
7DC1  46                  byte  $46
7DC2  71EF47        L7DC2 andb  REG_47,#$EF			; REG_47 bit 4 OFF (Air management2)
7DC5  71F747              andb  REG_47,#$F7			; REG_47 bit 3 ON (Air management1)
7DC8  A3FE2C1C      L7DC8 ld    REG_1C,$2C[REG_FE]
7DCC  C3738A00            st    REG_1C,$008A[REG_72]
      1C
7DD1  C3738C00            st    REG_1C,$008C[REG_72]	; store to raw KEYPWR
      1C
7DD6  B10A38              ldb   REG_38,#$0A
7DD9  2133                sjmp  L7F0E
7DDB  B3FE1642      L7DDB ldb   REG_42,$16[REG_FE]		; ROM $9E70 number_of_HEGOs
7DDF  990242              cmpb  REG_42,#$02
7DE2  F0                  ret
;
;********************************************************
; Very odd routine
; Word behind caller is 'filter' to scale time delta (ROM range limited to $010A)
;
7DE3  911028        L7DE3 orb   REG_28,#$10				; set REG_28 bit 4
7DE6  2003                sjmp  L7DEB

7DE8  71EF28        L7DE8 andb  REG_28,#$EF				; clr REG_28 bit 4

7DEB  EFD0F9        L7DEB lcall L77BE					; copy byte following call count bytes from stackptr2 to $001A
7DEE  02                  byte  $02						; copy this many bytes to $001A from this callers return address
7DEF  EF99FB              lcall L798B					; mangle the value at $001A into ROM if high bit set
7DF2  1A                  byte  $1A
7DF3  00                  byte  $00
7DF4  4B72600634          sub   REG_34,Master_IO_Timer_Lo,$60[REG_72] ; $00E0 IO time since last visit to this proc
7DF9  6D442834            mulu  REG_34,#$2844			; time since ? * ?
7DFD  4E1A363C            mulu  REG_3C,REG_36,[REG_1A]	; REG_36 is Hi 16 bits of prior result times "filter"
7E01  342816              jbc   REG_28,BIT_04,L7E1A

7E04  A3738A001C          ld    REG_1C,$008A[REG_72]	; $010A ? MAP/BP ? time?
7E09  683E1C              sub   REG_1C,REG_3E			; time delta * #$2844 * filterFactor
7E0C  D106                jnh   L7E14
7E0E  8BFE281C            cmp   REG_1C,$28[REG_FE]		; ROM $9E82 - $6000
7E12  DB18                jc    L7E2C
7E14  A3FE281C      L7E14 ld    REG_1C,$28[REG_FE]		; ROM $9E82 - $6000 - clamp if too low
7E18  2012                sjmp  L7E2C

7E1A  47738A00      L7E1A add   REG_1C,REG_3E,$008A[REG_72] ; $010A table ?????
      3E1C
7E20  DB06                jc    L7E28
7E22  8BFE2A1C            cmp   REG_1C,$2A[REG_FE]		; ROM $9E84 - $A666
7E26  D104                jnh   L7E2C	
7E28  A3FE2A1C      L7E28 ld    REG_1C,$2A[REG_FE]		; ROM $9E84 - $A666 - clamp if too high

7E2C  C3738A001C    L7E2C st    REG_1C,$008A[REG_72]	; $010A
7E31  C3738C001C          st    REG_1C,$008C[REG_72]	; $010C - ?store to raw KEYPWR???

7E36  C3726006      L7E36 st    Master_IO_Timer_Lo,$60[REG_72] ; store last time we tweaked
7E3A  F0                  ret
;
;********************************************************
; 
;
7E3B  EF80F9        L7E3B lcall L77BE			; copy byte following call count bytes from stackptr2 to $001A
7E3E  02                  byte  $02				; copy this many bytes to $001A from this callers return address
7E3F  EF49FB              lcall L798B			; mangle the value at $001A into ROM if high bit set
7E42  1A                  byte  $1A
7E43  00                  byte  $00
7E44  9A1A18              cmpb  REG_18,[REG_1A]
7E47  DB02                jc    L7E4B
7E49  CC00                pop   Zero			; nasty! return back two addresses
7E4B  F0            L7E4B ret
;
; Diagnostic proc table A
;
7E4C  36D904              jbc   REG_D9,BIT_06,L7E53
7E4F  B10F38              ldb   REG_38,#$0F
7E52  F0                  ret

7E53  3EE61B        L7E53 jbs   REG_E6,BIT_06,L7E71
7E56  2877                scall L7ECF
7E58  16                  byte  $16	; $0116 - EGR raw sensor
7E59  01                  byte  $01
7E5A  B4                  byte  $B4	; ROM mangled address range limit Lo
7E5B  90                  byte  $90
7E5C  B0                  byte  $B0	; ROM mangled address range limit Hi
7E5D  90                  byte  $90
7E5E  32                  byte  $32    	; Trouble Code on Lo limit - 
7E5F  34                  byte  $34    	; Trouble Code on Hi limit - 
7E60  341A04              jbc   REG_1A,BIT_04,L7E67
7E63  B10F38              ldb   REG_38,#$0F
7E66  F0                  ret

7E67  A3729642      L7E67 ld    REG_42,$96[REG_72]		; read raw EVP AD value
7E6B  C3727042            st    REG_42,$70[REG_72]
7E6F  2018                sjmp  L7E89
7E71  285C          L7E71 scall L7ECF
7E73  80                  byte  $80	; $380 - FIEPT?
7E74  03                  byte  $03
7E75  3C                  byte  $3C	; ROM mangled address range limit Lo
7E76  91                  byte  $91
7E77  34                  byte  $34	; ROM mangled address range limit Hi
7E78  91                  byte  $91
7E79  32                  byte  $32    	; Trouble Code on Lo limit - 
7E7A  34                  byte  $34    	; Trouble Code on Hi limit - 
7E7B  341A02              jbc   REG_1A,BIT_04,L7E80
7E7E  2047                sjmp  L7EC7
;
; Diagnostic Proc table D
;
7E80  A3730002      L7E80 ld    REG_42,$0200[REG_72]
      42
7E85  C3727042            st    REG_42,$70[REG_72]
7E89  B3782BD3      L7E89 ldb   REG_D3,$2B[REG_78]
7E8D  207F                sjmp  L7F0E
;
; Diagnostic proc table A
;
7E8F  3EE60E              jbs   REG_E6,BIT_06,L7EA0
7E92  A3729642            ld    REG_42,$96[REG_72]		; read raw EVP AD value
7E96  6B727042            sub   REG_42,$70[REG_72]
7E9A  8B783842            cmp   REG_42,$38[REG_78]
7E9E  200E                sjmp  L7EAE
7EA0  A3727042      L7EA0 ld    REG_42,$70[REG_72]
7EA4  6B730002            sub   REG_42,$0200[REG_72]
      42
7EA9  8B79C400            cmp   REG_42,$00C4[REG_78]
      42
7EAE  D217          L7EAE jgt   L7EC7
7EB0  9B782CD3            cmpb  REG_D3,$2C[REG_78]
7EB4  DB0E                jc    L7EC4
7EB6  5F782A18            mulub REG_42,REG_18,$2A[REG_78]
      42
7EBB  080342              shr   REG_42,#$03
7EBE  57782B42            addb  REG_D3,REG_42,$2B[REG_78]
      D3
7EC3  F0                  ret

;
; EEC trouble code : 33 - EGR valve (PFE and sonic) not opening
;
7EC4  2CE8          L7EC4 scall L7BAE			; push error $33 to $0342 error stack
7EC6  33                  byte  $33
7EC7  A000D2        L7EC7 ld    REG_D2,Zero
7ECA  B10E38              ldb   REG_38,#$0E
7ECD  203F                sjmp  L7F0E
;
;********************************************************
; data params follow the call here
; param word 0 ($1A) - sensor value EVP ?
; param word 1 ($1C) - mangle Lo
; param word 2 ($1E) - mangle Hi
; param byte 3 ($20) - Trouble Code for ? voltage lower than mangle Lo
; param byte 4 ($21) - Trouble Code for ? voltage lower than mangle Hi
7ECF  EFECF8        L7ECF lcall L77BE			; copy byte following call count bytes from stackptr2 to $001A
7ED2  08                  byte  $08			; copy this many bytes to $001A from this callers return address
7ED3  EFB5FA              lcall L798B			; mangle the value at $001C into ROM if high bit set
7ED6  1C                  byte  $1C
7ED7  00                  byte  $00
7ED8  EFB0FA              lcall L798B			; mangle the value at $001E into ROM if high bit set
7EDB  1E                  byte  $1E
7EDC  00                  byte  $00
7EDD  A21A42              ld    REG_42,[REG_1A]
7EE0  011A                clr   REG_1A
7EE2  8A1D42              cmp   REG_42,[REG_1C]+	; INCR POINTER !
7EE5  DB0D                jc    L7EF4
7EE7  B1311A              ldb   REG_1A,#$31		; EEC trouble code : 35 - PFE/EPT/EVP below minimum voltage
7EEA  8A1E42              cmp   REG_42,[REG_1E]
7EED  D116                jnh   L7F05
7EEF  B0201A              ldb   REG_1A,REG_20
7EF2  2011                sjmp  L7F05
7EF4  8A1C42        L7EF4 cmp   REG_42,[REG_1C]
7EF7  D114                jnh   L7F0D
7EF9  B0211A              ldb   REG_1A,REG_21
7EFC  8B1E0242            cmp   REG_42,$02[REG_1E]
7F00  D303                jnc   L7F05
7F02  B1351A              ldb   REG_1A,#$35		; EEC trouble code : 35 - PFE/EPT/EVP circuit above max voltage

7F05  51622A42      L7F05 andb  REG_42,REG_2A,#$62	; Open Circuit Check Error comes here
							; VIP_mode_flags : VSCST, running, no start
7F09  DF02                je    L7F0D
7F0B  2CA5                scall L7BB2			; save REG_1A in $0342 TROUBLE CODE table
7F0D  F0            L7F0D ret

7F0E  C7724A00      L7F0E stb   Zero,$4A[REG_72]		; zero $01CA timer? VIP_TIMER_EX
7F12  1738          L7F12 incb  REG_38
7F14  F0                  ret
;
; Diagnostic proc table A
;
7F15  B379D400            ldb   REG_42,$00D4[REG_78]
      42
7F1A  E04233              djnz  REG_42,L7F50
7F1D  A379D200            ld    REG_C2,$00D2[REG_78]
      C2
7F22  27EA                sjmp  L7F0E
;
; Diagnostic proc table A
;
7F24  2F15                scall L7E3B
7F26  55                  byte  $55
7F27  91                  byte  $91
7F28  A3728842            ld    REG_42,$88[REG_72]	; filtered sensor output - in place ($0108) - filtered RPM
7F2C  C3726A42            st    REG_42,$6A[REG_72]
7F30  A379D000            ld    REG_C2,$00D0[REG_78]
      C2
7F35  27D7                sjmp  L7F0E
;
; Diagnostic proc table A
;
7F37  2F02                scall L7E3B
7F39  55                  byte  $55
7F3A  91                  byte  $91
7F3B  A379CE00            ld    REG_22,$00CE[REG_78]
      22
7F40  67726A22            add   REG_22,$6A[REG_72]
7F44  EF25FA              lcall L796C
7F47  22                  byte  $22
7F48  00                  byte  $00
7F49  08                  byte  $08	; $0108
7F4A  01                  byte  $01
7F4B  18                  byte  $18	; EEC trouble code : 18 - SPOUT circuit open (grounded?)
7F4C  A378D0C2            ld    REG_C2,$D0[REG_78]
7F50  B11138        L7F50 ldb   REG_38,#$11
7F53  27B9                sjmp  L7F0E
;
; Diagnostic proc table A
;
7F55  A3FE3A3E            ld    REG_3E,$3A[REG_FE]
7F59  C3726E3E            st    REG_3E,$6E[REG_72]
7F5D  71EF2B              andb  REG_2B,#$EF
7F60  27AC                sjmp  L7F0E
;
; Diagnostic proc table A
;
7F62  2ED7                scall L7E3B
7F64  36                  byte  $36
7F65  F0                  byte  $F0
7F66  A3FE3A32            ld    REG_32,$3A[REG_FE]
7F6A  090532              shl   REG_32,#$05
7F6D  6B728832            sub   REG_32,$88[REG_72]	; filtered sensor output - in place ($0108) - filtered RPM
7F71  D602                jge   L7F75
7F73  0332                neg   REG_32
7F75  EFF4F9        L7F75 lcall L796C
7F78  32                  byte  $32	; $0032
7F79  00                  byte  $00
7F7A  38                  byte  $38
7F7B  F0                  byte  $F0
7F7C  13                  byte  $13	; EEC trouble code : 13 - Cannot control RPM during low RPM test
7F7D  278F                sjmp  L7F0E
;
; Diagnostic proc table A
;
7F7F  9B780C00            cmpb  Zero,$0C[REG_78]
7F83  D705                jne   L7F8A
7F85  B11638              ldb   REG_38,#$16
7F88  20BA                sjmp  L8044
7F8A  9BF84A00            cmpb  Zero,$4A[REG_F8]		; ROM $947A KIHP = 00 ( is there a knock sensor )
7F8E  DF1F                je    L7FAF
7F90  91022C              orb   REG_2C,#$02
7F93  A37808C2            ld    REG_C2,$08[REG_78]
7F97  A3798000            ld    REG_42,$0080[REG_78]
      42
7F9C  C3738A00            st    REG_42,$008A[REG_72]	; $010A - mdelta?
      42
7FA1  C3738C00            st    REG_42,$008C[REG_72]	; store to raw KEYPWR
      42
7FA6  AF780D1A            ldbze REG_1A,$0D[REG_78]
7FAA  C373A800            st    REG_1A,$00A8[REG_72]	; $0128 EOFF?
      1A
7FAF  275D          L7FAF sjmp  L7F0E
;
; Diagnostic proc table A
;
7FB1  2E88                scall L7E3B
7FB3  2F            L7FB3 byte  $2F
7FB4  F0                  byte  $F0
7FB5  91F0D7              orb   REG_D7,#$F0
7FB8  A372881C            ld    REG_1C,$88[REG_72]		; filtered sensor output - in place ($0108) - filtered RPM
7FBC  C3726A1C            st    REG_1C,$6A[REG_72]
7FC0  71F7D9              andb  REG_D9,#$F7
7FC3  EFAEEF              lcall L6F74
7FC6  2746                sjmp  L7F0E
;
; Diagnostic proc table A
;
7FC8  312C0A              jbc   REG_2C,BIT_01,L7FD5
7FCB  33D907              jbc   REG_D9,BIT_03,L7FD5
7FCE  717FD7              andb  REG_D7,#$7F
7FD1  A3F250C2            ld    REG_C2,$50[REG_F2]
7FD5  4B726AAE      L7FD5 sub   REG_1C,REG_AE,$6A[REG_72]
      1C
7FDA  D30A                jnc   L7FE6
7FDC  8BF38600            cmp   REG_1C,$0086[REG_F2]
      1C
7FE1  D303                jnc   L7FE6
7FE3  71EFD7              andb  REG_D7,#$EF
7FE6  4B7270AA      L7FE6 sub   REG_42,REG_AA,$70[REG_72]		; REG_AA is Throttle position
      42
7FEB  D602                jge   L7FEF
7FED  0342                neg   REG_42
7FEF  8BF38A00      L7FEF cmp   REG_42,$008A[REG_F2]
      42
7FF4  D303                jnc   L7FF9
7FF6  71CFD7              andb  REG_D7,#$CF
7FF9  35D703        L7FF9 jbc   REG_D7,BIT_05,L7FFF
7FFC  3CD712              jbs   REG_D7,BIT_04,L8011
7FFF  39D80F        L7FFF jbs   REG_D8,BIT_01,L8011
8002  9102D8              orb   REG_D8,#$02
8005  B3F38400            ldb   REG_1A,$0084[REG_F2]
      1A
800A  790C1A              subb  REG_1A,#$0C
800D  C7724A1A            stb   REG_1A,$4A[REG_72]		; set $01CA timer? VIP_TIMER_EX
8011  2E28          L8011 scall L7E3B
8013  84                  byte  $84
8014  90                  byte  $90
8015  312C0E              jbc   REG_2C,BIT_01,L8026
8018  A3FE2C42            ld    REG_42,$2C[REG_FE]
801C  C3738A00            st    REG_42,$008A[REG_72]
      42
8021  C3738C00            st    REG_42,$008C[REG_72]		; store to raw KEYPWR
      42
8026  34D706        L8026 jbc   REG_D7,BIT_04,L802F
;
; EEC trouble code : 77 - Operator error during Dynamic Response Test or Cylinder Balance Test
;
8029  EF82FB              lcall L7BAE		; push error $77 to $0342 error stack
802C  77                  byte  $77
802D  2011                sjmp  L8040
802F  35D704        L802F jbc   REG_D7,BIT_05,L8036
;
; EEC trouble code : 73 - Insufficient TPS change during Dynamic Response Test
;
8032  EF79FB              lcall L7BAE		; push error $73 to $0342 error stack
8035  73                  byte  $73
8036  312C07        L8036 jbc   REG_2C,BIT_01,L8040
8039  37D704              jbc   REG_D7,BIT_07,L8040
;
; EEC trouble code : 25 - Knock not sensed during Dynamic Response Test
;
803C  EF6FFB              lcall L7BAE		; push error $25 to $0342 error stack
803F  25                  byte  $25
8040  A378D0C2      L8040 ld    REG_C2,$D0[REG_78]
8044  B3781242      L8044 ldb   REG_42,$12[REG_78]
8048  E04215              djnz  REG_42,L8060
804B  B3F61342            ldb   REG_42,$13[REG_F6]
804F  E0420E              djnz  REG_42,L8060
8052  31D704              jbc   REG_D7,BIT_01,L8059
;
; EEC trouble code : 74 - Brake on/off switch circuit open
;
8055  EF56FB              lcall L7BAE		; push error $74 to $0342 error stack
8058  74                  byte  $74
8059  30D704        L8059 jbc   REG_D7,BIT_00,L8060
;
; EEC trouble code : 75 - Brake on/off switch circuit closed
;
805C  EF4FFB              lcall L7BAE		; push error $75 to $0342 error stack
805F  75                  byte  $75
8060  B379CC00      L8060 ldb   REG_42,$00CC[REG_78]
      42
8065  E04211              djnz  REG_42,L8079	   ; clr $01CA timer, incr REG_38 self test index, set bit flag and return
8068  B3F61442            ldb   REG_42,$14[REG_F6]
806C  E0420A              djnz  REG_42,L8079	   ; clr $01CA timer, incr REG_38 self test index, set bit flag and return
806F  32E603              jbc   REG_E6,BIT_02,L8075
8072  3BE604              jbs   REG_E6,BIT_03,L8079	   ; clr $01CA timer, incr REG_38 self test index, set bit flag and return
;
; EEC trouble code : 52 - Power Steering Pressure Switch circuit open
;
8075  EF36FB        L8075 lcall L7BAE		; push error $52 to $0342 error stack
8078  52                  byte  $52
;
; Diagnostic proc table A
; Diagnostic Proc table D
; 716E table entry
;
8079  9107D6        L8079 orb   REG_D6,#$07
807C  2690                sjmp  L7F0E
;
; Diagnostic Proc table D
;
807E  A33BD8711A    L807E ld    REG_1A,$71D8[REG_3A]
8083  200C                sjmp  L8091
;
;*** proc table 717E
; Diagnostic Proc table A
;
8085  A33B80711A          ld    REG_1A,$7180[REG_3A]
808A  2005                sjmp  L8091
;
;***
;
808C  A33B6A711A          ld    REG_1A,$716A[REG_3A]

8091  371B08        L8091 jbc   REG_1B,BIT_07,L809C
8094  EFF4F8              lcall L798B			; mangle the value at $001A into ROM if high bit set
8097  1A                  byte  $1A
8098  00                  byte  $00
8099  B21A1A              ldb   REG_1A,[REG_1A]
809C  981A18        L809C cmpb  REG_18,REG_1A
809F  D901                jh    L80A2
80A1  F0                  ret

80A2  1738          L80A2 incb  REG_38
80A4  2668                sjmp  L7F0E
;
; Diagnostic proc table A
;
80A6  B10436              ldb   REG_36,#$04
80A9  382B0B              jbs   REG_2B,BIT_00,L80B7
80AC  9B781F00            cmpb  Zero,$1F[REG_78]
80B0  DF05                je    L80B7
80B2  DE08                jlt   L80BC
80B4  312B05              jbc   REG_2B,BIT_01,L80BC
80B7  B11F38        L80B7 ldb   REG_38,#$1F
80BA  2652          L80BA sjmp  L7F0E
80BC  71FE2B        L80BC andb  REG_2B,#$FE		; RVIP CYL quit?
80BF  B11E38              ldb   REG_38,#$1E
80C2  27F6                sjmp  L80BA
;
; Diagnostic proc table A
;
80C4  EF74FD              lcall L7E3B
80C7  9E                  byte  $9E
80C8  90                  byte  $90
80C9  392B06              jbs   REG_2B,BIT_01,L80D2
80CC  A378181C            ld    REG_1C,$18[REG_78]
80D0  2014                sjmp  L80E6

80D2  A372741C      L80D2 ld    REG_1C,$74[REG_72]
80D6  6778161C            add   REG_1C,$16[REG_78]
80DA  DB06                jc    L80E2
80DC  8B78141C            cmp   REG_1C,$14[REG_78]
80E0  D104                jnh   L80E6
80E2  A378141C      L80E2 ld    REG_1C,$14[REG_78]
80E6  C372741C      L80E6 st    REG_1C,$74[REG_72]
80EA  91102B        L80EA orb   REG_2B,#$10
80ED  B11938              ldb   REG_38,#$19
80F0  27C8                sjmp  L80BA
;
; diagnostic proc table A
;
80F2  28D6                scall L81CA
80F4  EF44FD              lcall L7E3B
80F7  A0                  byte  $A0
80F8  90                  byte  $90
80F9  FA                  di
80FA  28E4                scall L81E0
80FC  2610                sjmp  L7F0E
;
; diagnostic proc table A
;
80FE  28CA                scall L81CA
8100  EF38FD              lcall L7E3B
8103  A2                  byte  $A2
8104  90                  byte  $90
8105  FA                  di
8106  28F0                scall L81F8
8108  A100801C            ld    REG_1C,#$8000
810C  6B72741C            sub   REG_1C,$74[REG_72]
8110  6F72721C            mulu  REG_1C,$72[REG_72]
8114  0D011C              shll  REG_1C,#$01
8117  C0361E              st    REG_1E,REG_36
811A  C7739200            stb   REG_34,$0092[REG_72]	; store to raw ECT AD 
      34
811F  25ED                sjmp  L7F0E
;
; Diagnostic proc table A
;
8121  28A7                scall L81CA
8123  EF15FD              lcall L7E3B
8126  A1                  byte  $A1
8127  90                  byte  $90
8128  FA                  di
8129  28B5                scall L81E0
812B  25E1                sjmp  L7F0E
;
; Diagnostic proc table A
;
812D  289B                scall L81CA
812F  EF09FD              lcall L7E3B
8132  A3                  byte  $A3
8133  90                  byte  $90
8134  FA                  di
8135  28C1                scall L81F8
8137  881C36              cmp   REG_36,REG_1C
813A  D909                jh    L8145
813C  B0341A              ldb   REG_1A,REG_34
813F  19041A              shlb  REG_1A,#$04
8142  EF6DFA              lcall L7BB2			; save REG_1A in $0342 TROUBLE CODE table
8145  C7739200      L8145 stb   Zero,$0092[REG_72]	; store to raw ECT AD
      00
814A  E0349D              djnz  REG_34,L80EA
814D  A3FE3A1A      L814D ld    REG_1A,$3A[REG_FE]
8151  C3726E1A            st    REG_1A,$6E[REG_72]
8155  71EF2B              andb  REG_2B,#$EF
8158  A3FE2C42            ld    REG_42,$2C[REG_FE]
815C  C3738A00            st    REG_42,$008A[REG_72]
      42
8161  C3738C00            st    REG_42,$008C[REG_72]		; store to raw KEYPWR
      42
8166  883000              cmp   Zero,REG_30
8169  D704                jne   L816F
;
; EEC trouble code : 90 - Pass Cylinder Balance Test
;
816B  EF40FA              lcall L7BAE		; push error $90 to $0342 error stack
816E  90                  byte  $90
816F  91022B        L816F orb   REG_2B,#$02
8172  B11D38              ldb   REG_38,#$1D
8175  2597                sjmp  L7F0E
;
; Diagnostic proc table A
;
8177  33D605              jbc   REG_D6,BIT_03,L817F
817A  C7724A00            stb   Zero,$4A[REG_72]		; zero $01CA timer? VIP_TIMER_EX
817E  F0                  ret

817F  992018        L817F cmpb  REG_18,#$20
8182  DB01                jc    L8185
8184  F0                  ret

8185  B11638        L8185 ldb   REG_38,#$16
8188  26EF                sjmp  L8079					; clr $01CA timer, incr REG_38 self test index, set bit flag and return
;
; Diagnostic proc table A
;
818A  3FD003              jbs   REG_D0,BIT_07,L8190		; jmp if throttle is closed
818D  91012B              orb   REG_2B,#$01
8190  302B27        L8190 jbc   REG_2B,BIT_00,L81BA
8193  37D024              jbc   REG_D0,BIT_07,L81BA		; jmp if throttle is not closed
8196  71FE2B              andb  REG_2B,#$FE
8199  0130                clr   REG_30
819B  B3FE0734            ldb   REG_34,$07[REG_FE]		; ROM $9E5A+7 = 9E61 value = $08=ENGCYL=Number of cylinders per engine revolution
819F  A3781C1A            ld    REG_1A,$1C[REG_78]
81A3  C3726E1A            st    REG_1A,$6E[REG_72]
81A7  A3781A42            ld    REG_42,$1A[REG_78]
81AB  C3738A00            st    REG_42,$008A[REG_72]
      42
81B0  C3738C00            st    REG_42,$008C[REG_72]	; store to raw KEYPWR
      42
81B5  B11838              ldb   REG_38,#$18
81B8  2700                sjmp  L80BA
;
; Diagnostic proc table A
;
81BA  99F018        L81BA cmpb  REG_18,#$F0
81BD  D10A                jnh   L81C9
81BF  C7724A00            stb   Zero,$4A[REG_72]		; zero $01CA timer? VIP_TIMER_EX
81C3  1536                decb  REG_36
81C5  D202                jgt   L81C9
81C7  2549                sjmp  L7F12
81C9  F0            L81C9 ret

81CA  3FD012        L81CA jbs   REG_D0,BIT_07,L81DF		; jmp if throttle is closed
81CD  C7739200            stb   Zero,$0092[REG_72]	; store to raw ECT AD
      00
81D2  0130                clr   REG_30
;
; EEC trouble code : 77 - Operator error during Dynamic Response Test or Cylinder Balance Test
;
81D4  EFD7F9              lcall L7BAE		; push error $77 to $0342 error stack
81D7  77                  byte  $77
81D8  91012B              orb   REG_2B,#$01
81DB  CC00                pop   Zero
81DD  276E                sjmp  L814D
81DF  F0            L81DF ret

81E0  C3727600      L81E0 st    Zero,$76[REG_72]	; zero $01F6
81E4  A3734E01            ld    REG_1C,$014E[REG_72]
      1C
81E9  C372781C            st    REG_1C,$78[REG_72]
81ED  AF735001            ldbze REG_1C,$0150[REG_72]
      1C
81F2  C3727A1C            st    REG_1C,$7A[REG_72]
81F6  FB                  ei
81F7  F0                  ret

81F8  A372761A      L81F8 ld    REG_1A,$76[REG_72]
81FC  A3734E01            ld    REG_20,$014E[REG_72]
      20
8201  AF735001            ldbze REG_22,$0150[REG_72]
      22
8206  FB                  ei
8207  6B727820            sub   REG_20,$78[REG_72]
820B  BB727A22            subcb REG_22,$7A[REG_72]
820F  8C1A20              divu  REG_20,REG_1A
8212  AFFE071A            ldbze REG_1A,$07[REG_FE]	; ROM $9E5A+7 = 9E61 value = $08=ENGCYL=Number of cylinders per engine revolution
8216  A31B9C3D            ld    REG_1E,$3D9C[REG_1A]
      1E
821B  A31BA23D            ld    REG_1C,$3DA2[REG_1A]
      1C
8220  8C201C              divu  REG_1C,REG_20
8223  C372721C            st    REG_1C,$72[REG_72]
8227  F0                  ret
;
;*****************************************************************
; Cycling Routine at 2151, routine offset $9A
;*****************************************************************
;
8228  31EA05        L8228 jbc   REG_EA,BIT_01,L8230	; jmp if not BIFLG - If equal to 1, Brake is on.
822B  71FDD7              andb  REG_D7,#$FD			; ?clr CODE_74 - Trouble Code B00 brake on/off circuit closed-not acuated during test
822E  2003                sjmp  L8233

8230  71FED7        L8230 andb  REG_D7,#$FE			; ?clr CODE_75 - Trouble Code BOO brake on/off circuit closed-always high
8233  342705        L8233 jbc   REG_27,BIT_04,L823B ; jmp if not POWSFG - Flag used to indicate that power steering load is  high: 1=power steering on
8236  9108E6              orb   REG_E6,#$08			; set POWON
8239  2003                sjmp  L823E

823B  9104E6        L823B orb   REG_E6,#$04			; set VHFNON

823E  F0            L823E ret
;
;*****************************************************************
; Cycling Routine at 2151, routine offset $98
;*****************************************************************
; Check HEGO sensors

823F  EF54EE        L823F lcall L7096				; Set up EGR flags

8242  A3724C32            ld    REG_32,$4C[REG_72]	; $01CC OLD value to filter HEGO1 (averaged)
8246  A3729C34            ld    REG_34,$9C[REG_72]	; $011C NEW value to filter in - raw HEGO1
824A  A3780236            ld    REG_36,$02[REG_78]	; filter factor
824E  EF12B4              lcall L3663				; filter HEGO1
8251  C3724C3E            st    REG_3E,$4C[REG_72]	; save filtered value (new HEGO1 avg)

8255  717F2B              andb  REG_2B,#$7F			; clear HEGO1 cross over voltage detected
8258  89C0D53E            cmp   REG_3E,#$D5C0		; O2S TRIP VOLTAGE
825C  D103                jnh   L8261				; jump if HEGO1 voltage <= $D5C0
825E  91802B              orb   REG_2B,#$80			; set REG_2B bit 7 - signal HEGO1 voltage cross?

8261  A3724E32      L8261 ld    REG_32,$4E[REG_72]	; $01CE OLD value to filter HEGO2 (averaged)
8265  A3729E34            ld    REG_34,$9E[REG_72]	; NEW value to add in - read HEGO2 raw
8269  EFF9B3              lcall L3665				; filter oxygen sensor?
826C  C3724E3E            st    REG_3E,$4E[REG_72]	; filtered value (new HEGO2 avg)

8270  71BF2B              andb  REG_2B,#$BF			; clear HEGO2 cross over voltage detected
8273  89C0D53E            cmp   REG_3E,#$D5C0		; O2S TRIP VOLTAGE
8277  D103                jnh   L827C				; jump if HEGO2 voltage <= $D5C0
8279  91402B              orb   REG_2B,#$40			; set REG_2B bit 6 - signal HEGO2 voltage cross?
827C  F0            L827C ret

;*****************************************************************
; 8061 ALU hardware test vectors - does the 8061 CPU work?

827D  FA            L827D di						; disable interrupts - why?
827E  FF                  nop
827F  FF                  nop
8280  C373460110          st    Stack_Ptr,$0146[REG_72]		; save old stack ptr
8285  FF                  nop
8286  A1580010            ld    Stack_Ptr,#$0058	; set stack pointer
828A  A17CA13C            ld    REG_3C,#$A17C
828E  A17CA13A            ld    REG_3A,#$A17C
8292  053A                dec   REG_3A
8294  883A3C              cmp   REG_3C,REG_3A
8297  FF                  nop						; a nop - why?
8298  DB03                jc    L829D

829A  20E2          L829A sjmp  L837E				; exit CPU ALU error
829C  F8                  clrc						; no entry point ????
829D  D3FB          L829D jnc   L829A

829F  6563753C            add   REG_3C,#$7563
82A3  DB04                jc    L82A9
82A5  27F3                sjmp  L829A

82A7  FF                  nop						; no entry point again?
82A8  F8                  clrc
82A9  D3EF          L82A9 jnc   L829A

82AB  F9                  setc
82AC  00F8                skip  REG_F8				; what is this ???
82AE  D3EA                jnc   L829A

82B0  A1E54B3A            ld    REG_3A,#$4BE5
82B4  643A3C              add   REG_3C,REG_3A		; test add
82B7  89C4623C            cmp   REG_3C,#$62C4
82BB  D7DD                jne   L829A

82BD  09013C              shl   REG_3C,#$01
82C0  6963753C            sub   REG_3C,#$7563		; test shift and sub
82C4  8925503C            cmp   REG_3C,#$5025
82C8  D7D0                jne   L829A

82CA  8582B03C            xor   REG_3C,#$B082		; NOTICE: if this instruction did not change R3C at all it would test OK
82CE  8582B03C            xor   REG_3C,#$B082		; test xor
82D2  8925503C            cmp   REG_3C,#$5025
82D6  D7C2                jne   L829A

82D8  6182B03C            and   REG_3C,#$B082		; test and
82DC  8900103C            cmp   REG_3C,#$1000
82E0  D7B8                jne   L829A

82E2  8131CE3C            or    REG_3C,#$CE31		; test or
82E6  8931DE3C            cmp   REG_3C,#$DE31
82EA  D7AE                jne   L829A

82EC  B13133              ldb   REG_33,#$31
82EF  C7730F02            stb   REG_33,$020F[REG_72]
      33
82F4  B19233              ldb   REG_33,#$92
82F7  57730F02            addb  REG_32,REG_33,$020F[REG_72]
      3332
82FD  99C332              cmpb  REG_32,#$C3
8300  D77C                jne   L837E				; ALU error
8302  B17B30              ldb   REG_30,#$7B
8305  B1C532              ldb   REG_32,#$C5
8308  5C303234            mulub REG_34,REG_32,REG_30
830C  89A75E34            cmp   REG_34,#$5EA7
8310  D76C                jne   L837E				; ALU error
8312  9C3234              divub REG_34,REG_32
8315  997B34              cmpb  REG_34,#$7B
8318  D764                jne   L837E				; ALU error

831A  0130                clr   REG_30
831C  0132                clr   REG_32
831E  113C                clrb  REG_3C
8320  0F3C30              norml REG_30,REG_3C		; test norml instruction
8323  997B34              cmpb  REG_34,#$7B
8326  D756                jne   L837E				; ALU error
8328  991F3C              cmpb  REG_3C,#$1F
832B  D751                jne   L837E				; ALU error

832D  A17CA13C            ld    REG_3C,#$A17C
8331  C3730C023C          st    REG_3C,$020C[REG_72]
8336  284B                scall L8383				; simple stack test - pushes and pops
8338  8B730E023C          cmp   REG_3C,$020E[REG_72]
833D  D73F                jne   L837E				; ALU error
833F  8B7310023C          cmp   REG_3C,$0210[REG_72]
8344  D738                jne   L837E				; ALU error
8346  88303C              cmp   REG_3C,REG_30
8349  D733                jne   L837E				; ALU error

834B  A1000410            ld    Stack_Ptr,#$0400	; set stack pointer - to get absolute address test locations
834F  A175553C            ld    REG_3C,#$5575
8353  C3730C023C          st    REG_3C,$020C[REG_72]
8358  2829                scall L8383				; test stack push/pop
835A  8B730E023C          cmp   REG_3C,$020E[REG_72]
835F  D71D                jne   L837E				; ALU error
8361  8B7310023C          cmp   REG_3C,$0210[REG_72]
8366  D716                jne   L837E				; ALU error
8368  88303C              cmp   REG_3C,REG_30
836B  D711                jne   L837E				; ALU error
;
; This next test verifies that REG_72 points to $0180
;
836D  B1AA30              ldb   REG_30,#$AA			; indexed fetch test
8370  C7730F0230          stb   REG_30,$020F[REG_72] ; REG_72 would need to be $0180
8375  A18F0332            ld    REG_32,#$038F		; $0385 = $0205 + $0180
8379  9A3230              cmpb  REG_30,[REG_32]
837C  DF1C                je    L839A				; EQUAL MEANS NO ERROR - run RAM test

837E  91102A        L837E orb   REG_2A,#$10			; Set VIP_mode_flag : disable no start
8381  2050                sjmp  L83D3				; reset stack ptr, enable ints and return
;
;************************************************************
; simple stack test routine
8383  CB730C02      L8383 push  $020C[REG_72]
8387  CF730E02            pop   $020E[REG_72]

838B  CB730E02            push  $020E[REG_72]
838F  CC30                pop   REG_30

8391  C830                push  REG_30
8393  CF731002            pop   $0210[REG_72]

8397  F0                  ret

8398  27E4                sjmp  L837E
                    ;*
                    ;************************************************************
                    ;*  do memory RAM test from $0100 to $08FF
                    ;*  
                    ;************************************************************
839A  A1FF083A      L839A ld    REG_3A,#$08FF			; RAM test end address
839E  A1000142            ld    REG_42,#$0100			; RAM test start address
83A2  A1AAAA30            ld    REG_30,#$AAAA
83A6  A1555532            ld    REG_32,#$5555

; tickle both watchdogs
83AA  954002        L83AA xorb  Low_Speed_Output,#$40	; change LSO bit 6 - tickle CPU OK
83AD  1705                incb  Watchdog_Timer
83AF  A24234              ld    REG_34,[REG_42]			; backup contents of test location
83B2  954002              xorb  Low_Speed_Output,#$40	; change LSO bit 6 - tickle CPU OK

83B5  C24230              st    REG_30,[REG_42]			; test odd bits
83B8  A24236              ld    REG_36,[REG_42]
83BB  883036              cmp   REG_36,REG_30
83BE  D71A                jne   L83DA					; RAM error
83C0  C24232              st    REG_32,[REG_42]			; test even bits
83C3  A24236              ld    REG_36,[REG_42]
83C6  883236              cmp   REG_36,REG_32
83C9  D70F                jne   L83DA
83CB  C24334              st    REG_34,[REG_42]+		; restore contents of test location
83CE  883A42              cmp   REG_42,REG_3A
83D1  D3D7                jnc   L83AA					; loop to end
83D3  A373460110    L83D3 ld    Stack_Ptr,$0146[REG_72]
83D8  FB                  ei
83D9  F0                  ret
83DA  E7A1FF        L83DA ljmp  L837E					; RAM CKSUM error
;
;
;
83DD  352B05        L83DD jbc   REG_2B,BIT_05,L83E5		; jump if STI input is low
83E0  C3724000      L83E0 st    Zero,$40[REG_72]		; zero $01C0 timer (Check Engine Lite?)
83E4  F0                  ret

83E5  3FA136        L83E5 jbs   REG_A1,BIT_07,L841E		; jump if CRANKING
83E8  51FAC534            andb  REG_34,REG_C5,#$FA
83EC  D716                jne   L8404
83EE  B3723242            ldb   REG_42,$32[REG_72]		; $01B2
83F2  9B784942            cmpb  REG_42,$49[REG_78]
83F6  D90C                jh    L8404
83F8  B3723C42            ldb   REG_42,$3C[REG_72]		; $01BC
83FC  9B785342            cmpb  REG_42,$53[REG_78]
8400  D902                jh    L8404
8402  2027                sjmp  L842B
8404  A379980040    L8404 ld    REG_40,$0098[REG_78]	; timer value for ???
8409  6B724040            sub   REG_40,$40[REG_72]		; $01C0 timer MILTMR (Check Engine Lite)?
840D  DB1E                jc    L842D
840F  0142                clr   REG_42
8411  8F799C0040          divu  REG_40,$009C[REG_78]
8416  DD03                jv    L841B
8418  384012              jbs   REG_40,BIT_00,L842D
841B  E78EF3        L841B ljmp  L77AC					; tweak flags, set STO on and return
841E  3C2A0A        L841E jbs   REG_2A,BIT_04,L842B		; jump if VIP_mode_flag : disable no start
8421  3C2D07              jbs   REG_2D,BIT_04,L842B		; REG_2D bit 4 effects RPM update
8424  8B799A00            cmp   Zero,$009A[REG_78]
      00
8429  D705                jne   L8430
842B  2FB3          L842B scall L83E0
842D  E784F3        L842D ljmp  L77B4					; set STO off flag, set STO output low, and set STO trigger
                    ;* function/maps/scalars
                    ;*
8430  2FE9          L8430 scall L841B
8432  27AC                sjmp  L83E0
;
;****************************************************************
; Diagnostic proc table A
; jump table entry @ 71C8
;
; reset lots of stuff and jump back to cycling thru procs
;
; very sick or switch out of self test to run
;
8434  3BD64D        L8434 jbs   REG_D6,BIT_03,L8484		; jmp if STO working - return
8437  3A2B4A              jbs   REG_2B,BIT_02,L8484		; jmp if STO trigger - return

843A  302A03              jbc   REG_2A,BIT_00,L8440		; jump if not VIP_mode_flag : VSCDT
843D  91202A              orb   REG_2A,#$20				; set (VIP_mode_flag : )running self tests

8440  FA            L8440 di
8441  FF                  nop
8442  A18C0410            ld    Stack_Ptr,#$048C		; force a stack pointer - must be sick here
8446  EFA6F6              lcall L7AEF					; call set HSO_Time_Hold = Master_IO_Timer_Lo + #$0003

8449  0146                clr   REG_46					; clr all LSO outputs
								; force ALL LSO and BiDir and REG_47 extra bits OFF
844B  312A03              jbc   REG_2A,BIT_01,L8451		; jump if not VIP_mode_flag : VSCST
844E  91402A              orb   REG_2A,#$40				; Set VIP_mode_flag : no start

8451  EFDE9B        L8451 lcall L2032					; basic reset EEC - init tables and ports
8454  302A06              jbc   REG_2A,BIT_00,L845D		; jump if not VIP_mode_flag : VSCDT
8457  71FE2A              andb  REG_2A,#$FE				; clr VIP_mode_flag : VSCDT
845A  91802A              orb   REG_2A,#$80				; Set VIP_mode_flag : disable VSCDT

845D  312A0C        L845D jbc   REG_2A,BIT_01,L846C		; jump if not VIP_mode_flag : VSCST
8460  71BD2A              andb  REG_2A,#$BD				; clear VIP_mode_flag : VIP enable and no start
8463  A1002842            ld    REG_42,#$2800
8467  C3013401            st    REG_42,$0134[Zero]		; PUTMR = Counts up after hardware reset
      42
846C  352A06        L846C jbc   REG_2A,BIT_05,L8475		; jump if normal strategy - not self test mode
846F  71DB2A              andb  REG_2A,#$DB				; clear VIP_mode_flag : VIP enable and running
8472  91182A              orb   REG_2A,#$18				; Set VIP_mode_flag : disable running and disable no start

8475  362A06        L8475 jbc   REG_2A,BIT_06,L847E		; jump if not VIP_mode_flag : no start
8478  71BB2A              andb  REG_2A,#$BB				; clear VIP_mode_flag : VIP enable and no start
847B  91102A              orb   REG_2A,#$10				; Set VIP_mode_flag : disable no start

847E  EF33F3        L847E lcall L77B4					; set STO off flag, set STO output low, and set STO trigger
8481  E7CD9C              ljmp  L2151

8484  F0            L8484 ret
;
;*******************************************************************
; Handle HSI line 7 data (Ignition Diagnostic Moniter)
;
8485  717F87        L8485 andb  REG_87,#$7F				; masked HSI data register 
8488  379003              jbc   REG_90,BIT_07,L848E		; jmp if not IDM_HIGH - raw HSI data 
848B  91104E              orb   REG_4E,#$10				; set SELF TEST MODE ON
848E  F0            L848E ret
;
;*****************************************************************
; Cycling Routine at 2151, routine offset $1C
;*****************************************************************
;
848F  374E07        L848F jbc   REG_4E,BIT_07,L8499		; jump if bit 7 is clr - new PIP received flag
8492  717F4E              andb  REG_4E,#$7F				; clr bit 7
8495  C372BE00            st    Zero,$BE[REG_72]		; ZERO - $013E - timer? time since last PIP recieved

8499  382C0A        L8499 jbs   REG_2C,BIT_00,L84A6		; jmp if IDM_BYPASS
849C  344E07              jbc   REG_4E,BIT_04,L84A6		; NEW_IDM - check Self Test Mode
849F  71EF4E              andb  REG_4E,#$EF				; bit 4 off - turn off Self Test Mode
84A2  C3724400            st    Zero,$44[REG_72]		; zero data in 1C4 - timer TSLIDM time in self test mode?

84A6  364E07        L84A6 jbc   REG_4E,BIT_06,L84B0		; new BP pulse recieved
84A9  71BF4E              andb  REG_4E,#$BF				; clr NEW_BAP
84AC  C772B600            stb   Zero,$B6[REG_72]		; ZERO data in B6+180=136 - timer - time since last BP pulse?

84B0  F0            L84B0 ret
                    ;*
                    ;************************************************************
                    ;*  copy calibration pointers from 2022 to 00F0
                    ;*  check for and set up calibration console
                    ;*  if $0D00  is  $2A,  Enconsole is present
                    ;*  this routine called only at reset
                    ;
                    ; On start bit 4 of REG_24 is set, but this routine clrs it at end so,
                    ; this routine skips console ck the first time thru, then checks every time
                    ;************************************************************
; Cycling Routine at 2151, routine offset 0
84B1  FA            L84B1 di							; interrupts off
84B2  A301000D14    L84B2 ld    REG_14,$0D00[Zero]		; CONSOLE_STATUS location   
84B7  992A15              cmpb  REG_15,#$2A				; $0D01 == #$2A ?
84BA  D72C                jne   L84E8                   ; console not present
84BC  3C241B              jbs   REG_24,BIT_04,L84DA		; use console flag

84BF  380A18              jbs   IO_Status,BIT_00,L84DA  ; HSO output overflow

84C2  47010E20            add   REG_80,Master_IO_Timer_Lo,$200E[Zero] ; add 005D to current IOTime
      0680
84C8  D702                jne   L84CC
84CA  0780                inc   REG_80					; zero has special meaning - avoid as a time
84CC  C3011AC1      L84CC st    REG_80,$C11A[Zero]		; why store a byte to ROM???
      80
84D1  A0800E              ld    HSO_Time_Hold,REG_80	; request int 5D IOtimes from now
84D4  B10F0D              ldb   HSO_Command_Hold,#$0F	; Set up HSO software timer event
84D7  EF2C4B              lcall LD006					; CONSOLE CALL

84DA  A301800C14    L84DA ld    REG_14,$0C80[Zero]		; flags for $00FX data pointers
84DF  361406              jbc   REG_14,BIT_06,L84E8
84E2  A100C214            ld    REG_14,#$C200			; use these calibration pointers for console
84E6  2009                sjmp  L84F1

84E8  C70100C000    L84E8 stb   Zero,$C000[Zero]		; h/w switch for console??
84ED  A1222014            ld    REG_14,#$2022			; calibration table pointers

84F1  3C2401        L84F1 jbs   REG_24,BIT_04,L84F5		; enable ints if console enabled
84F4  FB                  ei

84F5  A1F00018      L84F5 ld    REG_18,#$00F0			; copy data vectors here
84F9  B3012020            ldb   REG_1A,$2020[Zero]		; count - 8
      1A
84FE  A2151C        L84FE ld    REG_1C,[REG_14]+		; copy 8 vectors from 2022 to 00F0
8501  C2191C              st    REG_1C,[REG_18]+
8504  E01AF7              djnz  REG_1A,L84FE			; loop

8507  3C2422              jbs   REG_24,BIT_04,L852C		; exit

850A  A301F21F42          ld    REG_42,$1FF2[Zero]		; console value ?
850F  891C1F42            cmp   REG_42,#$1F1C			; console signature?
8513  D717                jne   L852C					; exit - not console found

8515  A1A5A542            ld    REG_42,#$A5A5
8519  C301F61F42          st    REG_42,$1FF6[Zero]		; can we read/write this loc
851E  8B01F61F42          cmp   REG_42,$1FF6[Zero]		; is it a r/w location? Or is ROM value = $A5A5 ?
8523  D707                jne   L852C					; exit

8525  C92C85              push  #$852C					; return address
8528  CB01F21F            push  $1FF2[Zero]				; call here if 1FF6 is a R/W register

852C  71EF24        L852C andb  REG_24,#$EF				; Turn off bit 4 - console ck - enabling cks
852F  F0                  ret

;
;*****************************************************************
; Cycling Routine at 2151, routine offset $22
; EVP something
;*****************************************************************
;
8530  36E66F        L8530 jbc   REG_E6,BIT_06,L85A2		; jmp if not PFEHP_FLG
8533  B301C00716          ldb   REG_16,$07C0[Zero]		; KAM_FLAGS
8538  A372B414            ld    REG_14,$B4[REG_72]		; $0134 - PUTMR - Counts up after hardware reset
853C  8BF85014            cmp   REG_14,$50[REG_F8]		; ROM $9480 - TKYON1 - Minimum time delay before PIPs are recognized, sec
8540  DB0C                jc    L854E
8542  71FD28              andb  REG_28,#$FD				; clr PTPFLG
8545  3F2803              jbs   REG_28,BIT_07,L854B		; jmp if KAM_ERROR
8548  3F1603              jbs   REG_16,BIT_07,L854E		; jmp if ???
854B  9120EC        L854B orb   REG_EC,#$20				; set BPUFLG
854E  3AA109        L854E jbs   REG_A1,BIT_02,L855A		; UNDSP = Run/Underspeed Flag.  (1 = Underspeed (or CRANK), 0 = Run)
8551  9BF856C8            cmpb  REG_C8,$56[REG_F8]		; (REG_C8 may be a byte size counter for ATMR1)
8555  D103                jnh   L855A
8557  717F16              andb  REG_16,#$7F
855A  35EC40        L855A jbc   REG_EC,BIT_05,L859D
855D  39283D              jbs   REG_28,BIT_01,L859D
8560  8BF85214            cmp   REG_14,$52[REG_F8]
8564  D337                jnc   L859D
8566  8BF85414            cmp   REG_14,$54[REG_F8]
856A  D931                jh    L859D
856C  A180A23E            ld    REG_3E,#$A280
8570  A3729634            ld    REG_34,$96[REG_72]		; read raw EVP AD value
8574  8BF33801            cmp   REG_34,$0138[REG_F2]	; ROM EVP limit
      34
8579  D11D                jnh   L8598
857B  8BF33A01            cmp   REG_34,$013A[REG_F2]	; ROM EVP limit?
      34
8580  DB16                jc    L8598
8582  67F84E34            add   REG_34,$4E[REG_F8]		; ROM
8586  D303                jnc   L858B
8588  BDFF34              ldbse REG_34,#$FF				; CLAMP
858B  A301EE07      L858B ld    REG_32,$07EE[Zero]		; OLD AD value - filtered EVP saved in KAM 
      32
8590  EFCBB0              lcall L365E					; FILTER new AD value (REG_34 is new AD value)
8593  48D0                word  $D048					; funny filter factor from ROM
8595  918016              orb   REG_16,#$80
8598  C301EE07      L8598 st    REG_3E,$07EE[Zero]		; updated AD value - filtered EVP saved in KAM 
      3E
859D  C701C007      L859D stb   REG_16,$07C0[Zero]
      16
85A2  F0            L85A2 ret
                    ;*
                    ;************************************************************
                    ;*  verify or int table at 0702-07AF
                    ;*  this routine called only at reset
                    ;* Checksum the KAM addresses $0704 to $07AF
                    ;* checksum stored at $0702 word
                    ;* Checksum OK and updated if with +- 1 of saved cksum
                    ;************************************************************
85A3  AD5630        L85A3 ldbze REG_30,#$56
85A6  0138                clr   REG_38					; start cksum

85A8  AF3103073A    L85A8 ldbze REG_3A,$0703[REG_30]	; table 1 704-759
85AD  643A38              add   REG_38,REG_3A
85B0  AF3159073A          ldbze REG_3A,$0759[REG_30]	; table 2 760-7AF
85B5  643A38              add   REG_38,REG_3A
85B8  E030ED              djnz  REG_30,L85A8			; loop

85BB  A30102073A          ld    REG_3A,$0702[Zero]		; old table sum
85C0  68383A              sub   REG_3A,REG_38
85C3  DB02                jc    L85C7
85C5  033A                neg   REG_3A
85C7  8901003A      L85C7 cmp   REG_3A,#$0001
85CB  D906                jh    L85D3					; jmp > +-1??

85CD  C301020738          st    REG_38,$0702[Zero]		; save sum as cksum
85D2  F0                  ret

; checksum is bad - clear table
85D3  B1803A        L85D3 ldb   REG_3A,#$80				; value to clr to
85D6  AD5630              ldbze REG_30,#$56				; count of bytes to set

85D9  C73103073A    L85D9 stb   REG_3A,$0703[REG_30]	; table 1
85DE  C73159073A          stb   REG_3A,$0759[REG_30]	; table 2
85E3  E030F3              djnz  REG_30,L85D9

85E6  A1005638            ld    REG_38,#$5600			; new sum = ( $56 + $56 ) * $80
85EA  C301020738          st    REG_38,$0702[Zero]		; valid sum
85EF  C701E00700          stb   Zero,$07E0[Zero]		; what is this?

85F4  F0                  ret
                    ;*
                    ;************************************************************
                    ;*  validate or clr table at 7E4-7EA (7EC is sum)
                    ;*  this routine called only at reset
                    ; checksum KAM table
                    ; clear to zero if checksum is off by more than 1
                    ;************************************************************
85F5  A1080030      L85F5 ld    REG_30,#$0008
85F9  0132                clr   REG_32

85FB  6731E20732    L85FB add   REG_32,$07E2[REG_30]	; add bytes in table 07E4-07EA
8600  790230              subb  REG_30,#$02
8603  D7F6                jne   L85FB

8605  4B01EC073234        sub   REG_34,REG_32,$07EC[Zero] ; old sum (cksum?)   
860B  D602                jge   L860F
860D  0334                neg   REG_34					; ABS
860F  89010034      L860F cmp   REG_34,#$0001
8613  D10E                jnh   L8623					; jmp exit if < +-1

8615  A1080032            ld    REG_32,#$0008
8619  A1E40730            ld    REG_30,#$07E4
861D  C63100        L861D stb   Zero,[REG_30]+			; zero table
8620  E032FA              djnz  REG_32,L861D

8623  C301EC0732    L8623 st    REG_32,$07EC[Zero]		; new checksum

8628  F0                  ret
                    ;**** end of routine
                    ;*
8629  FF                  byte  $FF						; byte to force word alignment
                    ;*
                    ;************************************************************
                    ;*  an array or linked list??  of tables; each is formatted
                    ;*  as described in following block. Code at L2068 and L2087 to
                    ;*  go to next block. Each block handled by loop at L2074
                    ;************************************************************
                    ;* 1st word = start address to init (hi-byte only,  lo-byte ignored)
                    ;* 2nd word = address of byte past end of table
                    ;* each pair of bytes following 2nd word until address in 2nd word
                    ;*     1st byte = lo-byte of addr to init (hi-byte from 1st word above)
                    ;*     2nd byte = data to OR into location being init'ed
                    ;*
                    ;* in this EPROM:
                    ;*     - this table is processed by loop at L2074
                    ;*     - since this are has been cleared by the loop at L203D
                    ;*          the OR is the same as initializing these locations
                    ;*     - 22 bytes from 862e thru 864f are processed
                    ;*           (00)ee  has  04  OR'ed into it
                    ;*           (00)a1  has  84  OR'ed into it
                    ;*           (00)4f  has  01  OR'ed into it
                    ;*             ...
                    ;************************************************************
862A  0000                word  Zero                        ;hi-byte = 'page' to init
862C  5086                word  $8650                       ;contains addr of end of init table
862E  EE                  byte  $EE                         ;start of 1st init table
862F  04                  byte  $04
8630  A1                  byte  $A1
8631  84                  byte  $84
8632  4F                  byte  $4F
8633  01                  byte  $01
8634  C1                  byte  $C1
8635  80                  byte  $80
8636  9C                  byte  $9C
8637  01                  byte  $01
8638  9D                  byte  $9D
8639  01                  byte  $01
863A  AE                  byte  $AE
863B  40                  byte  $40
863C  AF                  byte  $AF
863D  06                  byte  $06
863E  B0                  byte  $B0
863F  1E                  byte  $1E
8640  B1                  byte  $B1
8641  1E                  byte  $1E
8642  C2                  byte  $C2
8643  28                  byte  $28
8644  DC                  byte  $DC
8645  01                  byte  $01
8646  D0                  byte  $D0
8647  FF                  byte  $FF
8648  C6                  byte  $C6
8649  01                  byte  $01
864A  46                  byte  $46
864B  10                  byte  $10
864C  47                  byte  $47
864D  40                  byte  $40
864E  9B                  byte  $9B
864F  01                  byte  $01
                    ;* end of 1st init table
                    ;*
                    ;* start of 2nd init table ???
8650  5A                  byte  $5A
8651  86                  byte  $86
8652  FF                  byte  $FF
8653  FF                  byte  $FF
8654  FF                  byte  $FF
8655  FF                  byte  $FF
8656  FF                  byte  $FF
8657  FF                  byte  $FF
8658  FF                  byte  $FF
8659  FF                  byte  $FF

865A  00                  byte  $00
865B  01                  byte  $01
865C  8E                  byte  $8E
865D  86                  byte  $86
865E  00                  byte  $00
865F  C0                  byte  $C0
8660  01                  byte  $01
8661  5B                  byte  $5B
8662  02                  byte  $02
8663  C0                  byte  $C0
8664  03                  byte  $03
8665  4C                  byte  $4C
8666  04                  byte  $04
8667  80                  byte  $80
8668  05                  byte  $05
8669  A2                  byte  $A2
866A  08                  byte  $08
866B  40                  byte  $40
866C  09                  byte  $09
866D  06                  byte  $06
866E  16                  byte  $16
866F  C0                  byte  $C0
8670  17                  byte  $17
8671  4C                  byte  $4C
8672  26                  byte  $26
8673  80                  byte  $80
8674  27                  byte  $27
8675  3E                  byte  $3E
8676  28                  byte  $28
8677  C0                  byte  $C0
8678  29                  byte  $29
8679  4C                  byte  $4C
867A  31                  byte  $31
867B  D8                  byte  $D8
867C  41                  byte  $41
867D  08                  byte  $08
867E  52                  byte  $52
867F  01                  byte  $01
8680  53                  byte  $53
8681  20                  byte  $20
8682  69                  byte  $69
8683  01                  byte  $01
8684  70                  byte  $70
8685  C0                  byte  $C0
8686  71                  byte  $71
8687  4C                  byte  $4C
8688  7C                  byte  $7C
8689  80                  byte  $80
868A  7D                  byte  $7D
868B  A2                  byte  $A2
868C  FE                  byte  $FE
868D  D8                  byte  $D8

868E  98                  byte  $98
868F  86                  byte  $86
8690  FF                  byte  $FF
8691  FF                  byte  $FF
8692  FF                  byte  $FF
8693  FF                  byte  $FF
8694  FF                  byte  $FF
8695  FF                  byte  $FF
8696  FF                  byte  $FF
8697  FF                  byte  $FF

8698  00                  byte  $00
8699  02                  byte  $02
869A  CA                  byte  $CA
869B  86                  byte  $86
869C  0B                  byte  $0B
869D  80                  byte  $80
869E  0D                  byte  $0D
869F  80                  byte  $80
86A0  11                  byte  $11
86A1  C8                  byte  $C8
86A2  16                  byte  $16
86A3  FF                  byte  $FF
86A4  17                  byte  $17
86A5  FF                  byte  $FF
86A6  26                  byte  $26
86A7  99                  byte  $99
86A8  27                  byte  $27
86A9  79                  byte  $79
86AA  2A                  byte  $2A
86AB  80                  byte  $80
86AC  2B                  byte  $2B
86AD  3E                  byte  $3E
86AE  3A                  byte  $3A
86AF  22                  byte  $22
86B0  3B                  byte  $3B
86B1  08                  byte  $08
86B2  68                  byte  $68
86B3  01                  byte  $01
86B4  69                  byte  $69
86B5  01                  byte  $01
86B6  6A                  byte  $6A
86B7  01                  byte  $01
86B8  6B                  byte  $6B
86B9  01                  byte  $01
86BA  BB                  byte  $BB
86BB  FF                  byte  $FF
86BC  B9                  byte  $B9
86BD  0A                  byte  $0A 
86BE  C5                  byte  $C5
86BF  03                  byte  $03 
86C0  D4                  byte  $D4
86C1  FF                  byte  $FF 
86C2  E0                  byte  $E0
86C3  FF                  byte  $FF 
86C4  EA                  byte  $EA
86C5  FF                  byte  $FF 
86C6  F4                  byte  $F4
86C7  FF                  byte  $FF 
86C8  FE                  byte  $FE
86C9  FF                  byte  $FF 
86CA  D4                  byte  $D4
86CB  86                  byte  $86
86CC  FF                  byte  $FF
86CD  FF                  byte  $FF
86CE  FF                  byte  $FF
86CF  FF                  byte  $FF
86D0  FF                  byte  $FF
86D1  FF                  byte  $FF
86D2  FF                  byte  $FF
86D3  FF                  byte  $FF

86D4  00                  byte  $00
86D5  03                  byte  $03
86D6  E6                  byte  $E6
86D7  86                  byte  $86
86D8  08                  byte  $08
86D9  FF                  byte  $FF
86DA  12                  byte  $12
86DB  FF                  byte  $FF
86DC  1C                  byte  $1C
86DD  FF                  byte  $FF
86DE  22                  byte  $22
86DF  FF                  byte  $FF
86E0  C3                  byte  $C3
86E1  19                  byte  $19
86E2  C0                  byte  $C0
86E3  6C                  byte  $6C
86E4  C1                  byte  $C1
86E5  05                  byte  $05

86E6  FF                  byte  $FF		; end of table
86E7  FF                  byte  $FF
                    ;* ignored bytes all FF
86E8                      ds    $0518   ; bytes ignored by 'ignore' command
                    ;* Engine Parameters table 1
;
;*************************************************** REG_F0 points here
;
8C00  5A8E                word  $8E5A

8C02  80                  byte  $80
8C03  3E                  byte  $3E
8C04  54                  byte  $54
8C05  00                  byte  $00

8C06  FA                  byte  $FA		; 250
8C07  00                  byte  $00

8C08  E8                  byte  $E8		; 1000
8C09  03                  byte  $03

8C0A  48                  byte  $48
8C0B  01                  byte  $01
8C0C  60                  byte  $60
8C0D  3B                  byte  $3B
8C0E  20                  byte  $20
8C0F  4E                  byte  $4E
8C10  0C                  byte  $0C
8C11  20                  byte  $20
8C12  83                  byte  $83
8C13  07                  byte  $07
8C14  02                  byte  $02
8C15  05                  byte  $05

8C16  C1                  byte  $C1	; pip_minimum_period - table?
8C17  03                  byte  $03

8C18  7F                  byte  $7F
8C19  19                  byte  $19
8C1A  23                  byte  $23
8C1B  19                  byte  $19
8C1C  1E                  byte  $1E
8C1D  2D                  byte  $2D
8C1E  80                  byte  $80
8C1F  2D                  byte  $2D
8C20  80                  byte  $80
8C21  2D                  byte  $2D
8C22  80                  byte  $80
8C23  2D                  byte  $2D
8C24  80                  byte  $80
8C25  2D                  byte  $2D

8C26  7F                  byte  $7F
8C27  03                  byte  $03
8C28  80                  byte  $80
8C29  03                  byte  $03
8C2A  80                  byte  $80
8C2B  03                  byte  $03
8C2C  80                  byte  $80
8C2D  03                  byte  $03
8C2E  80                  byte  $80
8C2F  03                  byte  $03
8C30  80                  byte  $80
8C31  03                  byte  $03
8C32  80                  byte  $80
8C33  03                  byte  $03
8C34  FF                  byte  $FF
8C35  7F                  byte  $7F

8C36  00                  byte  $00
8C37  00                  byte  $00
8C38  55                  byte  $55
8C39  00                  byte  $00
8C3A  00                  byte  $00
8C3B  00                  byte  $00
8C3C  41                  byte  $41
8C3D  00                  byte  $00
8C3E  A0                  byte  $A0
8C3F  0F                  byte  $0F
8C40  00                  byte  $00
8C41  80                  byte  $80
8C42  A0                  byte  $A0
8C43  0F                  byte  $0F
8C44  00                  byte  $00
8C45  80                  byte  $80
8C46  A0                  byte  $A0
8C47  0F                  byte  $0F
8C48  00                  byte  $00
8C49  80                  byte  $80
8C4A  A0                  byte  $A0
8C4B  0F                  byte  $0F
8C4C  00                  byte  $00
8C4D  80                  byte  $80
8C4E  A0                  byte  $A0
8C4F  0F                  byte  $0F
8C50  FF                  byte  $FF
8C51  FF                  byte  $FF
8C52  80                  byte  $80
8C53  3E                  byte  $3E
8C54  9A                  byte  $9A
8C55  59                  byte  $59
8C56  80                  byte  $80
8C57  3E                  byte  $3E
8C58  33                  byte  $33
8C59  33                  byte  $33
8C5A  10                  byte  $10
8C5B  27                  byte  $27
8C5C  9A                  byte  $9A
8C5D  19                  byte  $19
8C5E  00                  byte  $00
8C5F  1E                  byte  $1E
8C60  00                  byte  $00
8C61  00                  byte  $00
8C62  00                  byte  $00
8C63  1E                  byte  $1E
8C64  00                  byte  $00
8C65  00                  byte  $00
8C66  00                  byte  $00
8C67  1E                  byte  $1E
8C68  00                  byte  $00
8C69  00                  byte  $00
8C6A  00                  byte  $00
8C6B  1E                  byte  $1E
8C6C  00                  byte  $00
8C6D  00                  byte  $00
8C6E  00                  byte  $00
8C6F  1E                  byte  $1E
8C70  00                  byte  $00
8C71  00                  byte  $00
8C72  00                  byte  $00
8C73  1E                  byte  $1E
8C74  00                  byte  $00
8C75  00                  byte  $00
8C76  00                  byte  $00
8C77  1E                  byte  $1E
8C78  FF                  byte  $FF
8C79  FF                  byte  $FF
8C7A  D1                  byte  $D1
8C7B  F7                  byte  $F7
8C7C  41                  byte  $41
8C7D  A2                  byte  $A2
8C7E  D1                  byte  $D1
8C7F  F7                  byte  $F7
8C80  56                  byte  $56
8C81  8A                  byte  $8A
8C82  75                  byte  $75
8C83  B8                  byte  $B8
8C84  D8                  byte  $D8
8C85  74                  byte  $74
8C86  A3                  byte  $A3
8C87  78                  byte  $78
8C88  00                  byte  $00
8C89  00                  byte  $00
8C8A  A3                  byte  $A3
8C8B  78                  byte  $78
8C8C  00                  byte  $00
8C8D  00                  byte  $00
8C8E  A3                  byte  $A3
8C8F  78                  byte  $78
8C90  FF                  byte  $FF
8C91  70                  byte  $70
8C92  2D                  byte  $2D
8C93  70                  byte  $70
8C94  0F                  byte  $0F
8C95  40                  byte  $40
8C96  0A                  byte  $0A
8C97  30                  byte  $30
8C98  06                  byte  $06
8C99  20                  byte  $20
8C9A  00                  byte  $00
8C9B  00                  byte  $00
8C9C  00                  byte  $00
8C9D  00                  byte  $00

8C9E  FF                  byte  $FF	; table fuel_table_tp_scaling
8C9F  70                  byte  $70
8CA0  F4                  byte  $F4
8CA1  70                  byte  $70
8CA2  22                  byte  $22
8CA3  00                  byte  $00
8CA4  00                  byte  $00
8CA5  00                  byte  $00
8CA6  00                  byte  $00
8CA7  00                  byte  $00

8CA8  7F                  byte  $7F	; table fuel_table_XX_scaling
8CA9  60                  byte  $60
8CAA  7D                  byte  $7D
8CAB  60                  byte  $60
8CAC  E7                  byte  $E7
8CAD  00                  byte  $00
8CAE  80                  byte  $80
8CAF  00                  byte  $00
8CB0  80                  byte  $80
8CB1  00                  byte  $00

          ;Func: EEC Load Scaling
          ;X: Raw Load
          ;Scale: 32768.000000 Offset: 0.000000 Math: 1
          ;Y: Table Row Pointer
          ;Scale: 256.000000 Offset: 0.000000 Math: 1
          ;org 08CB2h
          DW   0FFFFh,00700h
          DW   06000h,00700h	// 75% VE
          DW   04CCDh,00600h	// 60% VE
          DW   00CCDh,00100h	// 10% VE
          DW   00666h,00000h	//  5% VE
          DW   00000h,00000h

8CB2  FF                  byte  $FF
8CB3  FF                  byte  $FF
8CB4  00                  byte  $00
8CB5  07                  byte  $07
8CB6  00                  byte  $00
8CB7  60                  byte  $60
8CB8  00                  byte  $00
8CB9  07                  byte  $07
8CBA  CD                  byte  $CD
8CBB  4C                  byte  $4C
8CBC  00                  byte  $00
8CBD  06                  byte  $06
8CBE  CD                  byte  $CD
8CBF  0C                  byte  $0C
8CC0  00                  byte  $00
8CC1  01                  byte  $01
8CC2  66                  byte  $66
8CC3  06                  byte  $06
8CC4  00                  byte  $00
8CC5  00                  byte  $00
8CC6  00                  byte  $00
8CC7  00                  byte  $00
8CC8  00                  byte  $00
8CC9  00                  byte  $00
8CCA  00                  byte  $00
8CCB  00                  byte  $00
8CCC  00                  byte  $00
8CCD  00                  byte  $00
8CCE  00                  byte  $00
8CCF  00                  byte  $00
8CD0  00                  byte  $00
8CD1  00                  byte  $00
8CD2  7F                  byte  $7F
8CD3  90                  byte  $90
8CD4  78                  byte  $78
8CD5  90                  byte  $90
8CD6  F1                  byte  $F1
8CD7  00                  byte  $00
8CD8  80                  byte  $80
8CD9  00                  byte  $00
8CDA  80                  byte  $80
8CDB  00                  byte  $00
8CDC  80                  byte  $80
8CDD  00                  byte  $00

8CDE  FFFF                word  $FFFF	$0900	; TABLE  spark_table_RPM_scaling - ~8 references
8CDF  FF                  byte  $FF
8CE0  00                  byte  $00
8CE1  09                  byte  $09

8CE2  803E                word  $3E80	$0900	; 4000 RPM
8CE3  3E                  byte  $3E
8CE4  00                  byte  $00
8CE5  09                  byte  $09

8CE6  E0                  byte  $2EE0	$0800	; 3000 RPM
8CE7  2E                  byte  $2E
8CE8  00                  byte  $00
8CE9  08                  byte  $08

8CEA  70                  byte  $1770	$0500	; 1500 RPM
8CEB  17                  byte  $17
8CEC  00                  byte  $00
8CED  05                  byte  $05

8CEE  D0                  byte  $07D0	$0000	; 500 RPM
8CEF  07                  byte  $07
8CF0  00                  byte  $00
8CF1  00                  byte  $00

8CF2  00                  byte  $0000	$0000
8CF3  00                  byte  $00
8CF4  00                  byte  $00
8CF5  00                  byte  $00

8CF6  00                  byte  $00
8CF7  00                  byte  $00
8CF8  00                  byte  $00
8CF9  00                  byte  $00
	
	FFFF 0700
	6000 0700
	4CCD 0600
	0CCD 0100
	0666 0000
	0000 0000
8CFA  FF                  byte  $FF	; table  load_scaling - ~6 references
8CFB  FF                  byte  $FF
8CFC  00                  byte   $00
8CFD  07                  byte   $07
8CFE  00                  byte  $00
8CFF  60                  byte  $60
8D00  00                  byte   $00
8D01  07                  byte   $07
8D02  CD                  byte  $CD
8D03  4C                  byte  $4C
8D04  00                  byte   $00
8D05  06                  byte   $06
8D06  CD                  byte  $CD
8D07  0C                  byte  $0C
8D08  00                  byte   $00
8D09  01                  byte   $01
8D0A  66                  byte  $66
8D0B  06                  byte  $06
8D0C  00                  byte   $00
8D0D  00                  byte   $00
8D0E  00                  byte  $00
8D0F  00                  byte  $00
8D10  00                  byte   $00
8D11  00                  byte   $00
8D12  00                  byte  $00
8D13  00                  byte  $00
8D14  00                  byte  $00
8D15  00                  byte  $00

8D16  FF                  byte  $FF
8D17  FF                  byte  $FF
8D18  70                  byte  $70
8D19  00                  byte  $00
8D1A  33                  byte  $33
8D1B  73                  byte  $73
8D1C  70                  byte  $70
8D1D  00                  byte  $00
8D1E  9A                  byte  $9A
8D1F  59                  byte  $59
8D20  50                  byte  $50
8D21  00                  byte  $00
8D22  33                  byte  $33
8D23  33                  byte  $33
8D24  30                  byte  $30
8D25  00                  byte  $00
8D26  33                  byte  $33
8D27  13                  byte  $13
8D28  10                  byte  $10
8D29  00                  byte  $00
8D2A  9A                  byte  $9A
8D2B  09                  byte  $09
8D2C  00                  byte  $00
8D2D  00                  byte  $00
8D2E  00                  byte  $00
8D2F  00                  byte  $00
8D30  00                  byte  $00
8D31  00                  byte  $00

8D32  FF                  byte  $FF	; TABLE independent var is RPM
8D33  FF                  byte  $FF
8D34  00                  byte  $00
8D35  02                  byte  $02
8D36  8F                  byte  $8F
8D37  42                  byte  $42
8D38  00                  byte  $00
8D39  02                  byte  $02
8D3A  7B                  byte  $7B
8D3B  24                  byte  $24
8D3C  00                  byte  $00
8D3D  01                  byte  $01
8D3E  AE                  byte  $AE
8D3F  17                  byte  $17
8D40  00                  byte  $00
8D41  00                  byte  $00
8D42  00                  byte  $00
8D43  00                  byte  $00
8D44  00                  byte  $00
8D45  00                  byte  $00

8D46  FF                  byte  $FF
8D47  FF                  byte  $FF
8D48  00                  byte  $00
8D49  03                  byte  $03
8D4A  40                  byte  $40
8D4B  1F                  byte  $1F
8D4C  00                  byte  $00
8D4D  03                  byte  $03
8D4E  10                  byte  $10
8D4F  0E                  byte  $0E
8D50  00                  byte  $00
8D51  00                  byte  $00
8D52  00                  byte  $00
8D53  00                  byte  $00
8D54  00                  byte  $00
8D55  00                  byte  $00

8D56  FF                  byte  $FF
8D57  FF                  byte  $FF
8D58  FF                  byte  $FF
8D59  00                  byte  $00
8D5A  00                  byte  $00
8D5B  8C                  byte  $8C
8D5C  FF                  byte  $FF
8D5D  00                  byte  $00
8D5E  00                  byte  $00
8D5F  8C                  byte  $8C
8D60  00                  byte  $00
8D61  00                  byte  $00
8D62  00                  byte  $00
8D63  00                  byte  $00
8D64  00                  byte  $00
8D65  00                  byte  $00
8D66  00                  byte  $00
8D67  00                  byte  $00
8D68  00                  byte  $00
8D69  00                  byte  $00
8D6A  00                  byte  $00
8D6B  00                  byte  $00
8D6C  00                  byte  $00
8D6D  00                  byte  $00

8D6E  FF                  byte  $FF
8D6F  FF                  byte  $FF
8D70  CD                  byte  $CD
8D71  C8                  byte  $C8
8D72  9A                  byte  $9A
8D73  A2                  byte  $A2
8D74  58                  byte  $58
8D75  80                  byte  $80
8D76  00                  byte  $00
8D77  80                  byte  $80
8D78  FF                  byte  $FF
8D79  00                  byte  $00
     ;** O2 bias table
8D7A  58                  byte  $58
8D7B  00                  byte  $00
8D7C  33                  byte  $33
8D7D  22                  byte  $22
8D7E  1A                  byte  $1A
8D7F  40                  byte  $40
8D80  0A                  byte  $0A
8D81  59                  byte  $59
8D82  05                  byte  $05
8D83  65                  byte  $65
8D84  00                  byte  $00
8D85  80                  byte  $80
     ;** O2 bias table
8D86  FF                  byte  $FF
8D87  5B                  byte  $5B
8D88  E6                  byte  $E6
8D89  5B                  byte  $5B
8D8A  9A                  byte  $9A
8D8B  6E                  byte  $6E
8D8C  58                  byte  $58
8D8D  80                  byte  $80
8D8E  00                  byte  $00
8D8F  80                  byte  $80
     ;** O2 bias table  - cross time correction
8D90  FF                  byte  $FF
8D91  F3                  byte  $F3
8D92  E6                  byte  $E6
8D93  F3                  byte  $F3
8D94  CD                  byte  $CD
8D95  7A                  byte  $7A
8D96  B3                  byte  $B3
8D97  52                  byte  $52
8D98  9A                  byte  $9A
8D99  3E                  byte  $3E
8D9A  80                  byte  $80
8D9B  32                  byte  $32
8D9C  57                  byte  $57
8D9D  27                  byte  $27
8D9E  1A                  byte  $1A
8D9F  19                  byte  $19
8DA0  05                  byte  $05
8DA1  14                  byte  $14
8DA2  00                  byte  $00
8DA3  10                  byte  $10
8DA4  00                  byte  $00
8DA5  10                  byte  $10
8DA6  FF                  byte  $FF
8DA7  80                  byte  $80
8DA8  F0                  byte  $F0
8DA9  80                  byte  $80
8DAA  E0                  byte  $E0
8DAB  70                  byte  $70
8DAC  A0                  byte  $A0
8DAD  50                  byte  $50
8DAE  00                  byte  $00
8DAF  40                  byte  $40

; ECT AD counts to degrees F (used at $38B8)
8DB0  FF                  byte  $FF	indep (AD Count) legal range 0A - E6
8DB1  EC                  byte  $EC	depend(Degrees F) -20 degrees Farenheit

8DB2  E8                  byte  $E8	indep (AD Count)
8DB3  EC                  byte  $EC	-20 * 2 Degrees F

8DB4  E0                  byte  $E0	indep (AD Count)
8DB5  FB                  byte  $FB	-5 * 2 Degrees F

8DB6  D1                  byte  $D1	indep (AD Count)
8DB7  0A                  byte  $0A	10 * 2 Degrees F

8DB8  B8                  byte  $B8	indep (AD Count)
8DB9  17                  byte  $17	23 * 2 Degrees F

8DBA  49                  byte  $49	indep (AD Count)
8DBB  43                  byte  $43	67 * 2 Degrees F

8DBC  25                  byte  $25	indep (AD Count)
8DBD  5A                  byte  $5A	90 * 2 Degrees F

8DBE  14                  byte  $14	indep (AD Count)
8DBF  6F                  byte  $6F	111 * 2 Degrees F

8DC0  0D                  byte  $0D	indep (AD Count)
8DC1  7F                  byte  $7F	127 * 2 Degrees F

8DC2  00                  byte  $00	indep (AD Count)
8DC3  7F                  byte  $7F	127 * 2 Degrees F

8DC4  7F                  byte  $7F
8DC5  06                  byte  $06
8DC6  6E                  byte  $6E
8DC7  06                  byte  $06
8DC8  67                  byte  $67
8DC9  00                  byte  $00
8DCA  5A                  byte  $5A
8DCB  00                  byte  $00
8DCC  50                  byte  $50
8DCD  09                  byte  $09
8DCE  37                  byte  $37
8DCF  09                  byte  $09
8DD0  F3                  byte  $F3
8DD1  29                  byte  $29
8DD2  80                  byte  $80
8DD3  29                  byte  $29
8DD4  7F                  byte  $7F
8DD5  09                  byte  $09
8DD6  71                  byte  $71
8DD7  09                  byte  $09
8DD8  64                  byte  $64
8DD9  06                  byte  $06
8DDA  58                  byte  $58
8DDB  00                  byte  $00
8DDC  80                  byte  $80
8DDD  00                  byte  $00
8DDE  80                  byte  $80
8DDF  00                  byte  $00
8DE0  80                  byte  $80
8DE1  00                  byte  $00
                    ;*
                    ;************************************************************
                    ;MAF transfer function
                    ;************************************************************
          ;Func: MAF Transfer
          ;X: MAF Voltage
          ;Scale: 4096.000000 Offset: 0.000000 Math: 1
          ;Y: Mass Flow Kg/hr
          ;Scale: 4.000000 Offset: 0.000000 Math: 1
          ;org 08DE2h
          DW   0FFFFh,00A4Dh
          DW   04C4Ah,00A4Dh
          DW   04717h,00893h
          DW   042D5h,00759h
          DW   03E2Dh,00629h
          DW   038B4h,004ECh
          DW   035AEh,00449h
          DW   03262h,003A5h
          DW   02E8Fh,00300h
          DW   02B1Bh,0027Dh
          DW   02950h,00240h
          DW   02733h,001FDh
          DW   0250Eh,001C1h
          DW   02277h,0017Bh
          DW   01FD3h,0013Ch
          DW   01E3Dh,0011Dh
          DW   01CD9h,00104h
          DW   01B0Eh,000E6h
          DW   0192Fh,000C5h
          DW   0177Dh,000ABh
          DW   01523h,0008Dh
          DW   012E9h,00074h
          DW   01175h,00067h
          DW   00E25h,0004Bh
          DW   00C00h,0003Bh
          DW   00923h,0002Bh
          DW   00000h,0002Bh
          DW   00000h,0002Bh
          DW   00000h,0002Bh
          DW   00000h,0002Bh
8DE2  FF                  byte  $FF
8DE3  FF                  byte  $FF
8DE4  4D                  byte  $4D
8DE5  0A                  byte  $0A
8DE6  4A                  byte  $4A
8DE7  4C                  byte  $4C
8DE8  4D                  byte  $4D
8DE9  0A                  byte  $0A
8DEA  17                  byte  $17
8DEB  47                  byte  $47
8DEC  93                  byte  $93
8DED  08                  byte  $08
8DEE  D5                  byte  $D5
8DEF  42                  byte  $42
8DF0  59                  byte  $59
8DF1  07                  byte  $07
8DF2  2D                  byte  $2D
8DF3  3E                  byte  $3E
8DF4  29                  byte  $29
8DF5  06                  byte  $06
8DF6  B4                  byte  $B4
8DF7  38                  byte  $38
8DF8  EC                  byte  $EC
8DF9  04                  byte  $04
8DFA  AE                  byte  $AE
8DFB  35                  byte  $35
8DFC  49                  byte  $49
8DFD  04                  byte  $04
8DFE  62                  byte  $62
8DFF  32                  byte  $32
8E00  A5                  byte  $A5
8E01  03                  byte  $03
8E02  8F                  byte  $8F
8E03  2E                  byte  $2E
8E04  00                  byte  $00
8E05  03                  byte  $03
8E06  1B                  byte  $1B
8E07  2B                  byte  $2B
8E08  7D                  byte  $7D
8E09  02                  byte  $02
8E0A  50                  byte  $50
8E0B  29                  byte  $29
8E0C  40                  byte  $40
8E0D  02                  byte  $02
8E0E  33                  byte  $33
8E0F  27                  byte  $27
8E10  FD                  byte  $FD
8E11  01                  byte  $01
8E12  0E                  byte  $0E
8E13  25                  byte  $25
8E14  C1                  byte  $C1
8E15  01                  byte  $01
8E16  77                  byte  $77
8E17  22                  byte  $22
8E18  7B                  byte  $7B
8E19  01                  byte  $01
8E1A  D3                  byte  $D3
8E1B  1F                  byte  $1F
8E1C  3C                  byte  $3C
8E1D  01                  byte  $01
8E1E  3D                  byte  $3D
8E1F  1E                  byte  $1E
8E20  1D                  byte  $1D
8E21  01                  byte  $01
8E22  D9                  byte  $D9
8E23  1C                  byte  $1C
8E24  04                  byte  $04
8E25  01                  byte  $01
8E26  0E                  byte  $0E
8E27  1B                  byte  $1B
8E28  E6                  byte  $E6
8E29  00                  byte  $00
8E2A  2F                  byte  $2F
8E2B  19                  byte  $19
8E2C  C5                  byte  $C5
8E2D  00                  byte  $00
8E2E  7D                  byte  $7D
8E2F  17                  byte  $17
8E30  AB                  byte  $AB
8E31  00                  byte  $00
8E32  23                  byte  $23
8E33  15                  byte  $15
8E34  8D                  byte  $8D
8E35  00                  byte  $00
8E36  E9                  byte  $E9
8E37  12                  byte  $12
8E38  74                  byte  $74
8E39  00                  byte  $00
8E3A  75                  byte  $75
8E3B  11                  byte  $11
8E3C  67                  byte  $67
8E3D  00                  byte  $00
8E3E  25                  byte  $25
8E3F  0E                  byte  $0E
8E40  4B                  byte  $4B
8E41  00                  byte  $00
8E42  00                  byte  $00
8E43  0C                  byte  $0C
8E44  3B                  byte  $3B
8E45  00                  byte  $00
8E46  23                  byte  $23
8E47  09                  byte  $09
8E48  2B                  byte  $2B
8E49  00                  byte  $00
8E4A  00                  byte  $00
8E4B  00                  byte  $00
8E4C  2B                  byte  $2B
8E4D  00                  byte  $00
8E4E  00                  byte  $00
8E4F  00                  byte  $00
8E50  2B                  byte  $2B
8E51  00                  byte  $00
8E52  00                  byte  $00
8E53  00                  byte  $00
8E54  2B                  byte  $2B
8E55  00                  byte  $00
8E56  00                  byte  $00
8E57  00                  byte  $00
8E58  2B                  byte  $2B
8E59  00                  byte  $00
                    ;* End of MAF transfer function
                    ;*
                    ;* function/maps/scalars
                    ;*
;
;*************************************************** REG_F2 points here
;
8E5A  D69F                word  $8FD6

8E5C  00                  byte  $00
8E5D  FF                  byte  $FF
8E5E  00                  byte  $00
8E5F  20                  byte  $20
8E60  00                  byte  $00
8E61  A0                  byte  $A0
8E62  55                  byte  $55
8E63  D5                  byte  $D5
8E64  00                  byte  $00
8E65  83                  byte  $83
8E66  00                  byte  $00
8E67  06                  byte  $06
8E68  20                  byte  $20
8E69  4E                  byte  $4E
8E6A  D0                  byte  $D0
8E6B  07                  byte  $07
8E6C  80                  byte  $80
8E6D  0C                  byte  $0C
8E6E  00                  byte  $00
8E6F  0C                  byte  $0C
8E70  00                  byte  $00
8E71  E6                  byte  $E6
8E72  C0                  byte  $C0
8E73  0C                  byte  $0C
8E74  80                  byte  $80
8E75  2F                  byte  $2F
8E76  40                  byte  $40
8E77  38                  byte  $38
8E78  00                  byte  $00
8E79  5D                  byte  $5D
8E7A  80                  byte  $80
8E7B  62                  byte  $62
8E7C  C0                  byte  $C0
8E7D  91                  byte  $91
8E7E  40                  byte  $40
8E7F  92                  byte  $92
8E80  00                  byte  $00
8E81  C7                  byte  $C7
8E82  91                  byte  $91
8E83  01                  byte  $01
8E84  B8                  byte  $B8
8E85  1E                  byte  $1E
8E86  CD                  byte  $CD
8E87  2C                  byte  $2C
8E88  C3                  byte  $C3
8E89  04                  byte  $04
8E8A  29                  byte  $29
8E8B  00                  byte  $00
8E8C  00                  byte  $00
8E8D  32                  byte  $32
8E8E  00                  byte  $00
8E8F  C8                  byte  $C8
8E90  80                  byte  $80
8E91  57                  byte  $57
8E92  00                  byte  $00
8E93  14                  byte  $14
8E94  00                  byte  $00
8E95  02                  byte  $02
8E96  00                  byte  $00
8E97  06                  byte  $06
8E98  00                  byte  $00
8E99  03                  byte  $03
8E9A  00                  byte  $00
8E9B  01                  byte  $01
8E9C  FE                  byte  $FE
8E9D  0A                  byte  $0A
8E9E  26                  byte  $26
8E9F  B0                  byte  $B0
8EA0  32                  byte  $32
8EA1  01                  byte  $01	; VSTYPE Vehicle speed sensor cruise control hardware present switch;
												0 = No vehicle speed and no cruise control,
												1 = Vehicle speed sensor, no cruise control (VSS),
												2 = Both vehicle speed sensor and cruise control (VSS+VSC). 

8EA2  0D                  byte  $0D
8EA3  04                  byte  $04

8EA4  80                  byte  $80
8EA5  01                  byte  $01
8EA6  03                  byte  $03	; bad MAF retry interval
8EA7  01                  byte  $01
8EA8  01                  byte  $01
8EA9  FF                  byte  $FF
8EAA  78                  byte  $78
8EAB  00                  byte  $00
8EAC  00                  byte  $00
8EAD  32                  byte  $32
8EAE  66                  byte  $66
8EAF  06                  byte  $06
8EB0  33                  byte  $33
8EB1  03                  byte  $03
8EB2  10                  byte  $10
8EB3  0E                  byte  $0E
8EB4  00                  byte  $00
8EB5  FF                  byte  $FF
8EB6  00                  byte  $00
8EB7  19                  byte  $19
8EB8  80                  byte  $80
8EB9  3E                  byte  $3E
8EBA  00                  byte  $00
8EBB  19                  byte  $19
8EBC  80                  byte  $80
8EBD  3E                  byte  $3E
8EBE  00                  byte  $00
8EBF  64                  byte  $64
8EC0  80                  byte  $80
8EC1  57                  byte  $57

8EC2  00                  byte  $00		; ACT range low (checked in 38A1 and 7XXX)
8EC3  0A                  byte  $0A

8EC4  C0                  byte  $C0		; ACT range high
8EC5  E9                  byte  $E9

8EC6  3C                  byte  $3C
8EC7  FF                  byte  $FF
8EC8  80                  byte  $80
8EC9  F7                  byte  $F7
8ECA  00                  byte  $00
8ECB  0A                  byte  $0A
8ECC  C8                  byte  $C8
8ECD  01                  byte  $01
8ECE  10                  byte  $10
8ECF  08                  byte  $08
8ED0  10                  byte  $10
8ED1  FF                  byte  $FF
8ED2  82                  byte  $82
8ED3  00                  byte  $00
8ED4  D0                  byte  $D0
8ED5  07                  byte  $07
8ED6  5A                  byte  $5A
8ED7  00                  byte  $00

8ED8  00                  byte  $00	; ECT range low  #$0A00
8ED9  0A                  byte  $0A

8EDA  C0                  byte  $C0	; ECT range high #$E9C0
8EDB  E9                  byte  $E9

8EDC  00                  byte  $00
8EDD  05                  byte  $05
8EDE  78                  byte  $78
8EDF  50                  byte  $50
8EE0  40                  byte  $40
8EE1  06                  byte  $06
8EE2  A8                  byte  $A8
8EE3  00                  byte  $00
8EE4  00                  byte  $00
8EE5  32                  byte  $32
8EE6  00                  byte  $00
8EE7  14                  byte  $14
8EE8  00                  byte  $00
8EE9  FF                  byte  $FF
8EEA  00                  byte  $00
8EEB  0B                  byte  $0B
8EEC  01                  byte  $01
8EED  FF                  byte  $FF
8EEE  7B                  byte  $7B
8EEF  04                  byte  $04
8EF0  48                  byte  $48
8EF1  01                  byte  $01
8EF2  EC                  byte  $EC
8EF3  01                  byte  $01
8EF4  33                  byte  $33
8EF5  73                  byte  $73
8EF6  C2                  byte  $C2
8EF7  00                  byte  $00
8EF8  B0                  byte  $B0
8EF9  01                  byte  $01
8EFA  30                  byte  $30
8EFB  30                  byte  $30
8EFC  18                  byte  $18
8EFD  18                  byte  $18
8EFE  01                  byte  $01
8EFF  08                  byte  $08
8F00  F0                  byte  $F0
8F01  0A                  byte  $0A
8F02  10                  byte  $10
8F03  6D                  byte  $6D
8F04  09                  byte  $09
8F05  20                  byte  $20
8F06  6D                  byte  $6D
8F07  FF                  byte  $FF
8F08  CD                  byte  $CD
8F09  2C                  byte  $2C

8F0A  00                  byte  $00		; ACT min
8F0B  0A                  byte  $0A

8F0C  40                  byte  $40		; ACT max
8F0D  F6                  byte  $F6

8F0E  00                  byte  $00
8F0F  0F                  byte  $0F
8F10  80                  byte  $80
8F11  22                  byte  $22
8F12  00                  byte  $00
8F13  14                  byte  $14
8F14  00                  byte  $00
8F15  28                  byte  $28
8F16  10                  byte  $10
8F17  10                  byte  $10
8F18  10                  byte  $10
8F19  50                  byte  $50
8F1A  78                  byte  $78
8F1B  C8                  byte  $C8
8F1C  C8                  byte  $C8
8F1D  FE                  byte  $FE
8F1E  C8                  byte  $C8
8F1F  FE                  byte  $FE
8F20  C8                  byte  $C8
8F21  FE                  byte  $FE
8F22  C8                  byte  $C8
8F23  C8                  byte  $C8
8F24  C8                  byte  $C8
8F25  C8                  byte  $C8
8F26  C8                  byte  $C8
8F27  C8                  byte  $C8
8F28  C8                  byte  $C8
8F29  C8                  byte  $C8
8F2A  C8                  byte  $C8
8F2B  C8                  byte  $C8
8F2C  C8                  byte  $C8
8F2D  C8                  byte  $C8
8F2E  C8                  byte  $C8
8F2F  C8                  byte  $C8
8F30  C8                  byte  $C8
8F31  64                  byte  $64
8F32  64                  byte  $64
8F33  0A                  byte  $0A
8F34  64                  byte  $64
8F35  14                  byte  $14
8F36  0A                  byte  $0A
8F37  14                  byte  $14
8F38  64                  byte  $64
8F39  64                  byte  $64
8F3A  64                  byte  $64
8F3B  64                  byte  $64
8F3C  64                  byte  $64
8F3D  14                  byte  $14
8F3E  64                  byte  $64
8F3F  64                  byte  $64
8F40  64                  byte  $64
8F41  14                  byte  $14
8F42  FF                  byte  $FF
8F43  64                  byte  $64
8F44  64                  byte  $64
8F45  64                  byte  $64
8F46  32                  byte  $32
8F47  FF                  byte  $FF
8F48  40                  byte  $40
8F49  B3                  byte  $B3
8F4A  C0                  byte  $C0
8F4B  0F                  byte  $0F
8F4C  40                  byte  $40
8F4D  BE                  byte  $BE
8F4E  C0                  byte  $C0
8F4F  0F                  byte  $0F
8F50  40                  byte  $40
8F51  B3                  byte  $B3
8F52  C0                  byte  $C0
8F53  0F                  byte  $0F
8F54  C0                  byte  $C0
8F55  3A                  byte  $3A
8F56  C0                  byte  $C0
8F57  0F                  byte  $0F
8F58  4B                  byte  $4B
8F59  05                  byte  $05
8F5A  33                  byte  $33
8F5B  73                  byte  $73
8F5C  B0                  byte  $B0
8F5D  04                  byte  $04
8F5E  F7                  byte  $F7
8F5F  06                  byte  $06
8F60  28                  byte  $28
8F61  00                  byte  $00
8F62  00                  byte  $00
8F63  2D                  byte  $2D
8F64  40                  byte  $40
8F65  1F                  byte  $1F
8F66  C0                  byte  $C0
8F67  5D                  byte  $5D

8F68  00                  byte  $00	; ROM $8F6A mass_air_maximum = $12C0 - max MAF count
8F69  F5                  byte  $F5

8F6A  C0                  byte  $C0	; ROM $8F6A mass_air_minimum = $12C0 - min MAF count
8F6B  12                  byte  $12

8F6C  50                  byte  $50	; ROM $8F6C mass_air_rpm (4500.0RPM)
8F6D  46                  byte  $46

8F6E  CD                  byte  $CD
8F6F  0C                  byte  $0C
8F70  9A                  byte  $9A
8F71  FF                  byte  $FF
8F72  00                  byte  $00
8F73  00                  byte  $00
8F74  08                  byte  $08
8F75  00                  byte  $00
8F76  00                  byte  $00
8F77  00                  byte  $00
8F78  00                  byte  $00
8F79  00                  byte  $00
8F7A  00                  byte  $00
8F7B  80                  byte  $80

; These limits are the minimum the OCC AD channel needs to change when the actuator line togges
; otherwise the circuit is considered faulty
8F7C  80                  byte  $80	; Open Circuit Limit for Idle Air Control = $0780
8F7D  07                  byte  $07
8F7E  80                  byte  $80	; Open Circuit Limit for AM 1 = $0780
8F7F  07                  byte  $07
8F80  00                  byte  $00	; Open Circuit Limit for Hi Fan = $0780
8F81  00                  byte  $00
8F82  80                  byte  $80	; Open Circuit Limit for ??????AM 2???? = $0780
8F83  07                  byte  $07
8F84  80                  byte  $80	; Open Circuit Limit for Canister Purge = $0780
8F85  07                  byte  $07

8F86  80                  byte  $80	; Open Circuit Limit for Fuel Pump = $0780
8F87  07                  byte  $07
8F88  00                  byte  $00	; Open Circuit Limit for Electro Drive Fan = $0000
8F89  00                  byte  $00
8F8A  40                  byte  $40	; Open Circuit Limit for Data Output Link = $0680
8F8B  06                  byte  $06
8F8C  40                  byte  $40	; Open Circuit Limit for SCCS Vent = $0640
8F8D  06                  byte  $06

8F8E  00                  byte  $00
8F8F  0A                  byte  $0A
8F90  40                  byte  $40
8F91  F6                  byte  $F6
8F92  80                  byte  $80
8F93  98                  byte  $98
8F94  00                  byte  $00
8F95  B4                  byte  $B4
8F96  C0                  byte  $C0
8F97  99                  byte  $99
8F98  80                  byte  $80
8F99  D4                  byte  $D4
8F9A  40                  byte  $40
8F9B  97                  byte  $97
8F9C  80                  byte  $80
8F9D  D4                  byte  $D4
8F9E  00                  byte  $00
8F9F  14                  byte  $14
8FA0  00                  byte  $00
8FA1  96                  byte  $96
8FA2  A0                  byte  $A0
8FA3  0F                  byte  $0F
8FA4  1A                  byte  $1A
8FA5  00                  byte  $00
8FA6  00                  byte  $00
8FA7  FF                  byte  $FF
8FA8  58                  byte  $58
8FA9  02                  byte  $02
8FAA  78                  byte  $78
8FAB  00                  byte  $00
8FAC  14                  byte  $14
8FAD  00                  byte  $00
8FAE  01                  byte  $01
8FAF  28                  byte  $28
8FB0  08                  byte  $08
8FB1  18                  byte  $18
8FB2  50                  byte  $50
8FB3  50                  byte  $50
8FB4  E5                  byte  $E5
8FB5  00                  byte  $00
8FB6  E5                  byte  $E5
8FB7  00                  byte  $00
8FB8  8F                  byte  $8F
8FB9  02                  byte  $02
8FBA  00                  byte  $00
8FBB  06                  byte  $06
8FBC  00                  byte  $00
8FBD  78                  byte  $78
8FBE  9A                  byte  $9A
8FBF  04                  byte  $04
8FC0  A0                  byte  $A0
8FC1  A0                  byte  $A0
8FC2  50                  byte  $50
8FC3  78                  byte  $78
8FC4  18                  byte  $18
8FC5  FF                  byte  $FF
8FC6  00                  byte  $00
8FC7  05                  byte  $05
8FC8  00                  byte  $00
8FC9  05                  byte  $05
8FCA  26                  byte  $26
8FCB  01                  byte  $01
8FCC  F0                  byte  $F0
8FCD  38                  byte  $38
8FCE  60                  byte  $60
8FCF  22                  byte  $22
8FD0  70                  byte  $70
8FD1  17                  byte  $17
8FD2  0A                  byte  $0A
8FD3  01                  byte  $01
8FD4  18                  byte  $18
8FD5  FF                  byte  $FF
                    ;* function/maps/scalars
                    ;*
;
;*************************************************** REG_F4 points here
;
8FD6  A893                word  $93A8

8FD8  4B                  byte  $4B
8FD9  BD                  byte  $BD
8FDA  00                  byte  $00
8FDB  00                  byte  $00
8FDC  BD                  byte  $BD
8FDD  01                  byte  $01
8FDE  00                  byte  $00

	
8FDF  74                  byte  $74	; cylinder 1 ?
8FE0  7F                  byte  $7F	; cylinder 2 ?
8FE1  7B                  byte  $7B	; cylinder 3 ?
8FE2  26                  byte  $26	; cylinder 4 ?
8FE3  FF                  byte  $FF	; cylinder 5 ?
8FE4  C0                  byte  $C0	; cylinder 6 ?
8FE5  5D                  byte  $5D	; cylinder 7 ?
8FE6  E8                  byte  $E8	; cylinder 8 ?

8FE7  1C                  byte  $1C
8FE8  90                  byte  $90
8FE9  01                  byte  $01
8FEA  00                  byte  $00
8FEB  80                  byte  $80
8FEC  64                  byte  $64
8FED  FF                  byte  $FF
8FEE  20                  byte  $20
8FEF  03                  byte  $03
8FF0  90                  byte  $90
8FF1  01                  byte  $01
8FF2  00                  byte  $00
8FF3  80                  byte  $80
8FF4  66                  byte  $66
8FF5  66                  byte  $66
8FF6  D0                  byte  $D0
8FF7  0A                  byte  $0A
8FF8  0D                  byte  $0D
8FF9  FF                  byte  $FF
8FFA  01                  byte  $01
8FFB  00                  byte  $00
8FFC  00                  byte  $00
8FFD  80                  byte  $80
8FFE  00                  byte  $00	; ROM $8FFE injector_delay_global = 0 word
8FFF  00                  byte  $00
9000  00                  byte  $00
9001  FF                  byte  $FF
9002  33                  byte  $33	; accel_pimp_global_multiplier- word
9003  00                  byte  $00
9004  01                  byte  $01
9005  FF                  byte  $FF
9006  C0                  byte  $C0
9007  FF                  byte  $FF
9008  DF                  byte  $DF
9009  FF                  byte  $FF
900A  14                  byte  $14
900B  00                  byte  $00
900C  4D                  byte  $4D
900D  FF                  byte  $FF
900E  20                  byte  $20
900F  03                  byte  $03
9010  03                  byte  $03
9011  02                  byte  $02
9012  10                  byte  $10
9013  01                  byte  $01
9014  9A                  byte  $9A
9015  80                  byte  $80
9016  1A                  byte  $1A
9017  00                  byte  $00
9018  00                  byte  $00
9019  00                  byte  $00

901A  4A                  byte  $4A	; SARCHG ROM $901A engine_displacement contents = $1B4A = 6986 - engine_displacement ( one unit = 0.0430981 Cubic Inches)
901B  1B                  byte  $1B

901C  64                  byte  $64	; ROM $901C injector_slope_low word 3B64
901D  3B                  byte  $3B

901E  B2                  byte  $B2	; ROM $901E injector_slope_high word 2CB2 = 19# injectors
901F  2C                  byte  $2C

9020  00                  byte  $00
9021  00                  byte  $00
9022  7E                  byte  $7E
9023  00                  byte  $00
9024  7E                  byte  $7E
9025  00                  byte  $00
9026  7E                  byte  $7E
9027  00                  byte  $00
9028  7E                  byte  $7E
9029  00                  byte  $00
902A  66                  byte  $66
902B  06                  byte  $06
902C  9A                  byte  $9A
902D  F9                  byte  $F9
902E  CD                  byte  $CD
902F  08                  byte  $08
9030  CD                  byte  $CD
9031  00                  byte  $00
9032  C3                  byte  $C3	; ROM $9032 spark_adder_closed_throttle
9033  F5                  byte  $F5
9034  CD                  byte  $CD
9035  00                  byte  $00
9036  40                  byte  $40
9037  03                  byte  $03
9038  58                  byte  $58
9039  02                  byte  $02
903A  F0                  byte  $F0
903B  0F                  byte  $0F
903C  08                  byte  $08
903D  FF                  byte  $FF
903E  64                  byte  $64
903F  00                  byte  $00
9040  40                  byte  $40
9041  03                  byte  $03
9042  02                  byte  $02
9043  04                  byte  $04
9044  00                  byte  $00
9045  00                  byte  $00
9046  01                  byte  $01
9047  03                  byte  $03
9048  FF                  byte  $FF
9049  02                  byte  $02
                    ;* Idle Speed in neutral (0054H = 84 and 84 * 8 = 672rpm
904A  5400                word  $0054
                    ;*
                    ;* Idle Speed in gear (0054H = 84 and 84 * 8 = 672rpm
904C  5400                word  $0054
                    ;*
904E  08                  byte  $08
904F  00                  byte  $00
9050  03                  byte  $03
9051  00                  byte  $00
9052  67                  byte  $67
9053  00                  byte  $00
9054  8F                  byte  $8F
9055  02                  byte  $02
9056  00                  byte  $00
9057  A0                  byte  $A0
9058  00                  byte  $00
9059  00                  byte  $00
905A  00                  byte  $00
905B  00                  byte  $00
905C  66                  byte  $66
905D  00                  byte  $00
905E  66                  byte  $66
905F  00                  byte  $00
9060  00                  byte  $00
9061  00                  byte  $00
9062  28                  byte  $28
9063  00                  byte  $00
9064  00                  byte  $00
9065  00                  byte  $00
9066  19                  byte  $19
9067  50                  byte  $50
9068  00                  byte  $00
9069  80                  byte  $80
906A  80                  byte  $80
906B  80                  byte  $80
906C  80                  byte  $80
906D  80                  byte  $80
906E  80                  byte  $80
906F  80                  byte  $80
9070  80                  byte  $80
9071  80                  byte  $80
9072  80                  byte  $80
9073  80                  byte  $80
9074  80                  byte  $80
9075  80                  byte  $80
9076  80                  byte  $80
9077  80                  byte  $80
9078  80                  byte  $80
9079  80                  byte  $80
907A  80                  byte  $80
907B  80                  byte  $80
907C  80                  byte  $80
907D  80                  byte  $80
907E  80                  byte  $80
907F  80                  byte  $80
9080  80                  byte  $80
9081  80                  byte  $80
9082  80                  byte  $80
9083  80                  byte  $80
9084  80                  byte  $80
9085  80                  byte  $80
9086  80                  byte  $80
9087  80                  byte  $80
9088  80                  byte  $80
9089  80                  byte  $80
908A  80                  byte  $80
908B  80                  byte  $80
908C  80                  byte  $80
908D  80                  byte  $80
908E  80                  byte  $80
908F  80                  byte  $80
9090  80                  byte  $80
9091  80                  byte  $80
9092  80                  byte  $80
9093  80                  byte  $80
9094  80                  byte  $80
9095  80                  byte  $80
9096  80                  byte  $80
9097  80                  byte  $80
9098  80                  byte  $80
9099  80                  byte  $80
909A  80                  byte  $80
909B  80                  byte  $80
909C  80                  byte  $80
909D  80                  byte  $80
909E  80                  byte  $80
909F  80                  byte  $80
90A0  80                  byte  $80
90A1  80                  byte  $80
90A2  80                  byte  $80
90A3  80                  byte  $80
90A4  80                  byte  $80
90A5  80                  byte  $80

90A6  80                  byte  $80
90A7  80                  byte  $80
90A8  80                  byte  $80
90A9  80                  byte  $80
90AA  80                  byte  $80
90AB  80                  byte  $80
90AC  80                  byte  $80
90AD  80                  byte  $80
90AE  80                  byte  $80
90AF  80                  byte  $80
90B0  80                  byte  $80
90B1  80                  byte  $80
90B2  80                  byte  $80
90B3  80                  byte  $80
90B4  80                  byte  $80
90B5  80                  byte  $80
90B6  80                  byte  $80
90B7  80                  byte  $80
90B8  80                  byte  $80

90B9  FF                  byte  $FF
90BA  80                  byte  $80
90BB  E0                  byte  $E0
90BC  80                  byte  $80
90BD  B0                  byte  $B0
90BE  00                  byte  $00
90BF  00                  byte  $00
90C0  00                  byte  $00
90C1  00                  byte  $00
90C2  00                  byte  $00
90C3  00                  byte  $00
90C4  00                  byte  $00
90C5  FF                  byte  $FF
90C6  FF                  byte  $FF
90C7  FF                  byte  $FF
90C8  00                  byte  $00
90C9  06                  byte  $06
90CA  00                  byte  $00
90CB  7D                  byte  $7D
90CC  00                  byte  $00
90CD  06                  byte  $06
90CE  00                  byte  $00
90CF  19                  byte  $19
90D0  00                  byte  $00
90D1  02                  byte  $02
90D2  00                  byte  $00
90D3  00                  byte  $00
90D4  00                  byte  $00
90D5  00                  byte  $00
90D6  00                  byte  $00
90D7  00                  byte  $00
90D8  00                  byte  $00
90D9  00                  byte  $00
90DA  00                  byte  $00
90DB  00                  byte  $00
90DC  00                  byte  $00
90DD  00                  byte  $00
90DE  00                  byte  $00
90DF  00                  byte  $00
90E0  00                  byte  $00
90E1  00                  byte  $00
90E2  FF                  byte  $FF
90E3  FF                  byte  $FF
90E4  37                  byte  $37
90E5  1A                  byte  $1A
90E6  80                  byte  $80
90E7  3E                  byte  $3E
90E8  37                  byte  $37
90E9  1A                  byte  $1A
90EA  10                  byte  $10
90EB  27                  byte  $27
90EC  F0                  byte  $F0
90ED  16                  byte  $16
90EE  40                  byte  $40
90EF  1F                  byte  $1F
90F0  A9                  byte  $A9
90F1  13                  byte  $13
90F2  70                  byte  $70
90F3  17                  byte  $17
90F4  6B                  byte  $6B
90F5  0E                  byte  $0E
90F6  30                  byte  $30
90F7  11                  byte  $11
90F8  D5                  byte  $D5
90F9  09                  byte  $09
90FA  10                  byte  $10
90FB  0E                  byte  $0E
90FC  8E                  byte  $8E
90FD  06                  byte  $06
90FE  00                  byte  $00
90FF  00                  byte  $00
9100  F6                  byte  $F6
9101  0D                  byte  $0D

; Air flow from N and TP when MAF fails
9102  1A                  byte  $1A
9103  15                  byte  $15
9104  0A                  byte  $0A
9105  0A                  byte  $0A
9106  0A                  byte  $0A
9107  09                  byte  $09
9108  08                  byte  $08
9109  07                  byte  $07
910A  06                  byte  $06
910B  06                  byte  $06
910C  44                  byte  $44
910D  41                  byte  $41
910E  3A                  byte  $3A
910F  2F                  byte  $2F
9110  22                  byte  $22
9111  19                  byte  $19
9112  13                  byte  $13
9113  11                  byte  $11
9114  0F                  byte  $0F
9115  0E                  byte  $0E
9116  58                  byte  $58
9117  57                  byte  $57
9118  55                  byte  $55
9119  51                  byte  $51
911A  4B                  byte  $4B
911B  42                  byte  $42
911C  32                  byte  $32
911D  28                  byte  $28
911E  1D                  byte  $1D
911F  19                  byte  $19
9120  60                  byte  $60
9121  64                  byte  $64
9122  68                  byte  $68
9123  69                  byte  $69
9124  6A                  byte  $6A
9125  69                  byte  $69
9126  64                  byte  $64
9127  5A                  byte  $5A
9128  4B                  byte  $4B
9129  3E                  byte  $3E
912A  62                  byte  $62
912B  69                  byte  $69
912C  6B                  byte  $6B
912D  6D                  byte  $6D
912E  6E                  byte  $6E
912F  6F                  byte  $6F
9130  71                  byte  $71
9131  72                  byte  $72
9132  71                  byte  $71
9133  6F                  byte  $6F
9134  64                  byte  $64
9135  6A                  byte  $6A
9136  6D                  byte  $6D
9137  70                  byte  $70
9138  72                  byte  $72
9139  75                  byte  $75
913A  77                  byte  $77
913B  7D                  byte  $7D
913C  90                  byte  $90
913D  90                  byte  $90
913E  83                  byte  $83
913F  88                  byte  $88
9140  8C                  byte  $8C
9141  90                  byte  $90
9142  93                  byte  $93
9143  94                  byte  $94
9144  9D                  byte  $9D
9145  AA                  byte  $AA
9146  DF                  byte  $DF
9147  DF                  byte  $DF

9148  FF                  byte  $FF	; TABLE injector_time_load_scaling
9149  FF                  byte  $FF
914A  70                  byte  $70
914B  00                  byte  $00
914C  00                  byte  $00
914D  60                  byte  $60
914E  70                  byte  $70
914F  00                  byte  $00
9150  CD                  byte  $CD
9151  4C                  byte  $4C
9152  60                  byte  $60
9153  00                  byte  $00
9154  CD                  byte  $CD
9155  0C                  byte  $0C
9156  10                  byte  $10
9157  00                  byte  $00
9158  66                  byte  $66
9159  06                  byte  $06
915A  00                  byte  $00
915B  00                  byte  $00
915C  00                  byte  $00
915D  00                  byte  $00
915E  00                  byte  $00
915F  00                  byte  $00
                    ;*
                    ;************************************************************
                    ;Injector Time Table
                    ;************************************************************

FN1315 = An 10x8 table which gives injector delay as  a function of engine speed and load.
       X-input = FN070 - Normalized Engine Speed (N).
       Y-input = FN085 - Normalized Load.

9160	FN1315	table		1	8	unsigned	-2	10			91AF
          ;Map: Injector Timing [Crank Degrees]
          ;Scale: 4.000000 Offset: 0.000000 Math: 0
          ;10 Cols: Speed [RPM]
          ;500|700|900|1100|1300|1500|2000|2500|3000|4000
          ;8 Rows: Load []
          ;.05|.15|.23|.30|.40|.50|.60|.75
          ;org 09160h
9160  58585858            byte  $58,$58,$58,$58,$58,$58,$58,$58   ;XXXXXXXX
9168  58585858            byte  $58,$58,$58,$58,$58,$58,$58,$58   ;XXXXXXXX
9170  58585858            byte  $58,$58,$58,$58,$58,$58,$58,$58   ;XXXXXXXX
9178  58585858            byte  $58,$58,$58,$58,$58,$58,$58,$58   ;XXXXXXXX
9180  58585858            byte  $58,$58,$58,$58,$58,$58,$58,$58   ;XXXXXXXX
9188  58585858            byte  $58,$58,$58,$58,$58,$5F,$64,$64   ;XXXXX_dd
9190  64645F5F            byte  $64,$64,$5F,$5F,$5F,$5F,$5F,$5F   ;dd______
9198  69697474            byte  $69,$69,$74,$74,$69,$69,$69,$69   ;iittiiii
91A0  69696974            byte  $69,$69,$69,$74,$74,$74,$69,$69   ;iiitttii
91A8  69696969            byte  $69,$69,$69,$69,$69,$74,$74,$74   ;iiiiittt
                    ;* End of Injector Time Table
                    ;*
; in - cylinder #
; out - port(bank) #
          ;Map: Injector Output Port []
          ;Scale: 1.000000 Offset: 0.000000 Math: 0
          ;8 Cols: Injector Port []
          ;1|2|3|4|5|6|7|8
          ;org 091B1h
91B0  00000000            byte  $00,$00,$00,$00,$00,$02,$02,$02   ;........
91B8  02                  byte  $02                               ;.
                    ;* Load Injector Firing Order

          ;Map: Load Injector Firing Order []
          ;Scale: 1.000000 Offset: 0.000000 Math: 0
          ;8 Cols: Injector to Fire []
          ;1|2|3|4|5|6|7|8
          ;org 091B9h
91B9  01                  byte  $01
91BA  03                  byte  $03
91BB  07                  byte  $07
91BC  02                  byte  $02
91BD  06                  byte  $06
91BE  05                  byte  $05
91BF  04                  byte  $04
91C0  08                  byte  $08
                    ;* End

          ;Func: Accelerator Enrichment Multiplier vs TP
          ;X: Throttle Position-A/D Counts
          ;Scale: 4.000000 Offset: 0.000000 Math: 0
          ;Y: Accelerator Enrichment Multiplier
          ;Scale: 128.000000 Offset: 0.000000 Math: 1
          ;org 091C1h
          DB   0FFh,000h
          DB   0D5h,000h
          DB   071h,026h
          DB   032h,07Ah
          DB   000h,080h

91C1  FF                  byte  $FF
91C2  00                  byte  $00
91C3  D5                  byte  $D5
91C4  00                  byte  $00
91C5  71                  byte  $71
91C6  26                  byte  $26
91C7  32                  byte  $32
91C8  7A                  byte  $7A
91C9  00                  byte  $00
91CA  80                  byte  $80

; Accel Enrichment Fuel [lb/min]
; Throttle Rate [degrees per second] vs ECT
; pp43 of pdf

          ;Map: Accel Enrichment Fuel [lb/min]
          ;Scale: 4.000000 Offset: 0.000000 Math: 1
          ;8 Cols: Throttle Rate [Deg/sec]
          ;15|33|48|63|77|90|110|125
          ;7 Rows: ECT [DegF]
          ;-30|0|30|50|100|150|200
          ;org 091CBh
          DB   054h,05Ch,068h,070h,07Ch,088h,09Ch,0E0h
          DB   030h,038h,040h,048h,068h,078h,098h,0DCh
          DB   014h,020h,028h,030h,042h,054h,06Ch,0B4h
          DB   010h,014h,018h,020h,032h,044h,066h,088h
          DB   008h,008h,00Ch,012h,020h,032h,048h,074h
          DB   006h,006h,008h,00Ch,012h,020h,030h,050h
          DB   006h,006h,008h,00Ch,012h,020h,030h,048h


91CB  54                  byte  $54
91CC  5C                  byte  $5C
91CD  68                  byte  $68
91CE  70                  byte  $70
91CF  7C                  byte  $7C
91D0  88                  byte  $88
91D1  9C                  byte  $9C
91D2  E0                  byte  $E0
91D3  30                  byte  $30
91D4  38                  byte  $38
91D5  40                  byte  $40
91D6  48                  byte  $48
91D7  68                  byte  $68
91D8  78                  byte  $78
91D9  98                  byte  $98
91DA  DC                  byte  $DC
91DB  14                  byte  $14
91DC  20                  byte  $20
91DD  28                  byte  $28
91DE  30                  byte  $30
91DF  42                  byte  $42
91E0  54                  byte  $54
91E1  6C                  byte  $6C
91E2  B4                  byte  $B4
91E3  10                  byte  $10
91E4  14                  byte  $14
91E5  18                  byte  $18
91E6  20                  byte  $20
91E7  32                  byte  $32
91E8  44                  byte  $44
91E9  66                  byte  $66
91EA  88                  byte  $88
91EB  08                  byte  $08
91EC  08                  byte  $08
91ED  0C                  byte  $0C
91EE  12                  byte  $12
91EF  20                  byte  $20
91F0  32                  byte  $32
91F1  48                  byte  $48
91F2  74                  byte  $74
91F3  06                  byte  $06
91F4  06                  byte  $06
91F5  08                  byte  $08
91F6  0C                  byte  $0C
91F7  12                  byte  $12
91F8  20                  byte  $20
91F9  30                  byte  $30
91FA  50                  byte  $50

91FB  06                  byte  $06	; fuel_accel_enrich_table
91FC  06                  byte  $06
91FD  08                  byte  $08
91FE  0C                  byte  $0C
91FF  12                  byte  $12
9200  20                  byte  $20
9201  30                  byte  $30
9202  48                  byte  $48
9203  FF                  byte  $FF

9204  FF                  byte  $FF	; table - independent var is RPM (ref'd @ 3ED9)
9205  FF                  byte  $FF
9206  65                  byte  $65
9207  AA                  byte  $AA
9208  00                  byte  $00
9209  00                  byte  $00
920A  65                  byte  $65
920B  AA                  byte  $AA
920C  00                  byte  $00
920D  00                  byte  $00
920E  65                  byte  $65
920F  AA                  byte  $AA
9210  00                  byte  $00
9211  00                  byte  $00
9212  65                  byte  $65
9213  AA                  byte  $AA
9214  00                  byte  $00
9215  00                  byte  $00
9216  65                  byte  $65
9217  AA                  byte  $AA
9218  00                  byte  $00
9219  00                  byte  $00
921A  65                  byte  $65
921B  AA                  byte  $AA
921C  00                  byte  $00
921D  00                  byte  $00
921E  65                  byte  $65
921F  AA                  byte  $AA
9220  00                  byte  $00
9221  00                  byte  $00
9222  65                  byte  $65
9223  AA                  byte  $AA
9224  00                  byte  $00
9225  00                  byte  $00
9226  65                  byte  $65
9227  AA                  byte  $AA
9228  00                  byte  $00
9229  00                  byte  $00
922A  65                  byte  $65
922B  AA                  byte  $AA

FN389(VBAT) = Dual slope injector breakpoint 
	Input =  VBAT,  volts
	Output = lb/rev
922c	FN389	function	2	8	unsigned	4	2	unsigned	28	924B
922C  FF                  byte  $FF		FFFF	1FE0
922D  FF                  byte  $FF
922E  E0                  byte  $E0
922F  1F                  byte  $1F

9230  00                  byte  $00		0000	1FE0
9231  00                  byte  $00
9232  E0                  byte  $E0
9233  1F                  byte  $1F

9234  00                  byte  $00		0000	1FE0
9235  00                  byte  $00
9236  E0                  byte  $E0
9237  1F                  byte  $1F

9238  00                  byte  $00		0000	1FE0
9239  00                  byte  $00
923A  E0                  byte  $E0
923B  1F                  byte  $1F

923C  00                  byte  $00		0000	1FE0
923D  00                  byte  $00
923E  E0                  byte  $E0
923F  1F                  byte  $1F

9240  00                  byte  $00		0000	1FE0
9241  00                  byte  $00
9242  E0                  byte  $E0
9243  1F                  byte  $1F

9244  00                  byte  $00		0000	1FE0
9245  00                  byte  $00
9246  E0                  byte  $E0
9247  1F                  byte  $1F

9248  00                  byte  $00		0000	1FE0
9249  00                  byte  $00
924A  E0                  byte  $E0
924B  1F                  byte  $1F


924C  7F                  byte  $7F
924D  60                  byte  $60
924E  7D                  byte  $7D
924F  60                  byte  $60
9250  E7                  byte  $E7
9251  00                  byte  $00
9252  80                  byte  $80
9253  00                  byte  $00
9254  80                  byte  $80
9255  00                  byte  $00
9256  FF                  byte  $FF
9257  FF                  byte  $FF
9258  00                  byte  $00
9259  80                  byte  $80
925A  9A                  byte  $9A
925B  25                  byte  $25
925C  00                  byte  $00
925D  80                  byte  $80
925E  F6                  byte  $F6
925F  24                  byte  $24
9260  9A                  byte  $9A
9261  79                  byte  $79
9262  EC                  byte  $EC
9263  21                  byte  $21
9264  CD                  byte  $CD
9265  6C                  byte  $6C
9266  9A                  byte  $9A
9267  1F                  byte  $1F
9268  66                  byte  $66
9269  66                  byte  $66
926A  00                  byte  $00
926B  18                  byte  $18
926C  E1                  byte  $E1
926D  5A                  byte  $5A
926E  00                  byte  $00
926F  0C                  byte  $0C
9270  9A                  byte  $9A
9271  49                  byte  $49
9272  00                  byte  $00
9273  08                  byte  $08
9274  00                  byte  $00
9275  40                  byte  $40
9276  00                  byte  $00
9277  04                  byte  $04
9278  EC                  byte  $EC
9279  31                  byte  $31
927A  EC                  byte  $EC
927B  01                  byte  $01
927C  D7                  byte  $D7
927D  23                  byte  $23
927E  00                  byte  $00
927F  00                  byte  $00
9280  CD                  byte  $CD
9281  0C                  byte  $0C
9282  00                  byte  $00
9283  00                  byte  $00
9284  00                  byte  $00
9285  00                  byte  $00
9286  FF                  byte  $FF
9287  FF                  byte  $FF
9288  00                  byte  $00
9289  00                  byte  $00
928A  60                  byte  $60
928B  09                  byte  $09
928C  00                  byte  $00
928D  00                  byte  $00
928E  08                  byte  $08
928F  07                  byte  $07
9290  AE                  byte  $AE
9291  03                  byte  $03
9292  78                  byte  $78
9293  05                  byte  $05
9294  00                  byte  $00
9295  08                  byte  $08
9296  00                  byte  $00
9297  00                  byte  $00
9298  00                  byte  $00
9299  08                  byte  $08

          ;Func: Crank Fuel Pulse Width Multiplier
          ;X: Time in Crank Mode
          ;Scale: 8.000000 Offset: 0.000000 Math: 1
          ;Y: Crank Fuel Multiplier
          ;Scale: 128.000000 Offset: 0.000000 Math: 1
          ;org 0929Ah
          DW   0FFFFh,00080h
          DW   00000h,00080h
          DW   00000h,00080h
          DW   00000h,00080h
          DW   00000h,00080h
          DW   00000h,00080h

929A  FF                  byte  $FF
929B  FF                  byte  $FF
929C  80                  byte  $80
929D  00                  byte  $00
929E  00                  byte  $00
929F  00                  byte  $00
92A0  80                  byte  $80
92A1  00                  byte  $00
92A2  00                  byte  $00
92A3  00                  byte  $00
92A4  80                  byte  $80
92A5  00                  byte  $00
92A6  00                  byte  $00
92A7  00                  byte  $00
92A8  80                  byte  $80
92A9  00                  byte  $00
92AA  00                  byte  $00
92AB  00                  byte  $00
92AC  80                  byte  $80
92AD  00                  byte  $00
92AE  00                  byte  $00
92AF  00                  byte  $00
92B0  80                  byte  $80
92B1  00                  byte  $00
92B2  FF                  byte  $FF
92B3  C0                  byte  $C0
92B4  38                  byte  $38
92B5  C0                  byte  $C0
92B6  2B                  byte  $2B
92B7  40                  byte  $40
92B8  29                  byte  $29
92B9  40                  byte  $40
92BA  1F                  byte  $1F
92BB  FF                  byte  $FF
92BC  00                  byte  $00
92BD  FF                  byte  $FF
92BE  00                  byte  $00
92BF  FF                  byte  $FF

; Function 7 by 1 initial ECT adder for idle RPM
92C0  7F                  byte  $7F
92C1  00                  byte  $00

92C2  32                  byte  $32
92C3  93                  byte  $93

92C4  B6                  byte  $B6	<<<< this function entry seems like a mistake
92C5  36                  byte  $36

92C6  19                  byte  $19
92C7  06                  byte  $06

92C8  0A                  byte  $0A
92C9  06                  byte  $06

92CA  00                  byte  $00
92CB  13                  byte  $13

92CC  80                  byte  $80
92CD  13                  byte  $13

92CE  FF                  byte  $FF
92CF  7F                  byte  $7F
92D0  06                  byte  $06
92D1  7F                  byte  $7F
92D2  00                  byte  $00
92D3  53                  byte  $53
92D4  00                  byte  $00
92D5  53                  byte  $53
92D6  FF                  byte  $FF
92D7  7F                  byte  $7F
92D8  7F                  byte  $7F
92D9  00                  byte  $00
92DA  64                  byte  $64
92DB  00                  byte  $00
92DC  7F                  byte  $7F
92DD  00                  byte  $00
92DE  28                  byte  $28
92DF  00                  byte  $00
92E0  71                  byte  $71
92E1  00                  byte  $00
92E2  00                  byte  $00
92E3  00                  byte  $00
92E4  60                  byte  $60
92E5  00                  byte  $00
92E6  B0                  byte  $B0
92E7  FF                  byte  $FF
92E8  46                  byte  $46
92E9  00                  byte  $00
92EA  00                  byte  $00
92EB  80                  byte  $80
92EC  46                  byte  $46
92ED  00                  byte  $00
92EE  00                  byte  $00
92EF  80                  byte  $80
92F0  46                  byte  $46
92F1  00                  byte  $00
92F2  FF                  byte  $FF
92F3  7F                  byte  $7F
92F4  7C                  byte  $7C
92F5  00                  byte  $00
92F6  B8                  byte  $B8
92F7  01                  byte  $01
92F8  7C                  byte  $7C
92F9  00                  byte  $00
92FA  00                  byte  $00
92FB  00                  byte  $00
92FC  53                  byte  $53
92FD  00                  byte  $00
92FE  10                  byte  $10
92FF  FF                  byte  $FF
9300  3E                  byte  $3E
9301  00                  byte  $00
9302  00                  byte  $00
9303  80                  byte  $80
9304  3E                  byte  $3E
9305  00                  byte  $00
9306  00                  byte  $00
9307  80                  byte  $80
9308  3E                  byte  $3E
9309  00                  byte  $00
930A  00                  byte  $00
930B  80                  byte  $80
930C  3E                  byte  $3E
930D  00                  byte  $00
930E  FF                  byte  $FF
930F  7F                  byte  $7F
9310  05                  byte  $05
9311  00                  byte  $00
9312  00                  byte  $00
9313  80                  byte  $80
9314  05                  byte  $05
9315  00                  byte  $00
9316  00                  byte  $00
9317  80                  byte  $80
9318  05                  byte  $05
9319  00                  byte  $00
931A  00                  byte  $00
931B  80                  byte  $80
931C  05                  byte  $05
931D  00                  byte  $00
931E  00                  byte  $00
931F  80                  byte  $80
9320  05                  byte  $05
9321  00                  byte  $00
9322  00                  byte  $00
9323  80                  byte  $80
9324  05                  byte  $05
9325  00                  byte  $00
9326  00                  byte  $00
9327  80                  byte  $80
9328  05                  byte  $05
9329  00                  byte  $00

          ;Func: Dashpot Decrement Rate - dashpot_decrement_rate (dashpot decrement step at given flow(Kg/Hr(flow),Kg/Hr(Step))
          ;X: Dashpot[lb/min]
          ;Scale: 4096.000000 Offset: 0.000000 Math: 1
          ;Y: Decrement Rate [lb/min]
          ;Scale: 4096.000000 Offset: 0.000000 Math: 1
          ;org 0932Ah
          DW   0FFFFh,00100h
          DW   00C00h,00100h
          DW   00A66h,000B8h
          DW   00733h,0001Dh
          DW   0059Ah,00008h
          DW   000FEh,0000Ch
          DW   00000h,0000Eh

932A  FF                  byte  $FF
932B  FF                  byte  $FF
932C  00                  byte  $00
932D  01                  byte  $01
932E  00                  byte  $00
932F  0C                  byte  $0C
9330  00                  byte  $00
9331  01                  byte  $01
9332  66                  byte  $66
9333  0A                  byte  $0A
9334  B8                  byte  $B8
9335  00                  byte  $00
9336  33                  byte  $33
9337  07                  byte  $07
9338  1D                  byte  $1D
9339  00                  byte  $00
933A  9A                  byte  $9A
933B  05                  byte  $05
933C  08                  byte  $08
933D  00                  byte  $00
933E  FE                  byte  $FE
933F  00                  byte  $00
9340  0C                  byte  $0C
9341  00                  byte  $00
9342  00                  byte  $00
9343  00                  byte  $00
9344  0E                  byte  $0E
9345  00                  byte  $00

          ;Func: Maximum Dashpot Clip
          ;X: RPM
          ;Scale: 4.000000 Offset: 0.000000 Math: 1
          ;Y: Dashpot Clip [lb/min]
          ;Scale: 4096.000000 Offset: 0.000000 Math: 1
          ;org 09346h
          DW   0FFFFh,0199Ah
          DW   01F40h,0199Ah
          DW   01770h,01000h
          DW   007D0h,001ECh
          DW   00000h,001ECh
9346  FF                  byte  $FF
9347  FF                  byte  $FF
9348  9A                  byte  $9A
9349  19                  byte  $19
934A  40                  byte  $40
934B  1F                  byte  $1F
934C  9A                  byte  $9A
934D  19                  byte  $19
934E  70                  byte  $70
934F  17                  byte  $17
9350  00                  byte  $00
9351  10                  byte  $10
9352  D0                  byte  $D0
9353  07                  byte  $07
9354  EC                  byte  $EC
9355  01                  byte  $01
9356  00                  byte  $00
9357  00                  byte  $00
9358  EC                  byte  $EC
9359  01                  byte  $01
935A  7F                  byte  $7F	; ISC_during_crank (isc duty cycle during crank, keyed off ect at start (ect, duty cycle)
935B  4D                  byte  $4D
935C  5A                  byte  $5A
935D  4D                  byte  $4D
935E  50                  byte  $50
935F  7F                  byte  $7F
9360  80                  byte  $80
9361  7F                  byte  $7F
9362  80                  byte  $80
9363  7F                  byte  $7F
9364  80                  byte  $80
9365  7F                  byte  $7F
9366  A6                  byte  $A6
9367  80                  byte  $80
9368  66                  byte  $66
9369  5A                  byte  $5A
936A  4D                  byte  $4D
936B  48                  byte  $48
936C  44                  byte  $44
936D  A6                  byte  $A6
936E  80                  byte  $80
936F  66                  byte  $66
9370  53                  byte  $53
9371  4D                  byte  $4D
9372  48                  byte  $48
9373  44                  byte  $44
9374  A6                  byte  $A6
9375  9A                  byte  $9A
9376  66                  byte  $66
9377  4D                  byte  $4D
9378  4A                  byte  $4A
9379  48                  byte  $48
937A  44                  byte  $44
937B  9A                  byte  $9A
937C  90                  byte  $90
937D  5A                  byte  $5A
937E  46                  byte  $46
937F  4A                  byte  $4A
9380  48                  byte  $48
9381  44                  byte  $44
9382  86                  byte  $86
9383  7A                  byte  $7A
9384  53                  byte  $53
9385  46                  byte  $46
9386  4A                  byte  $4A
9387  48                  byte  $48
9388  44                  byte  $44
9389  6D                  byte  $6D
938A  66                  byte  $66
938B  53                  byte  $53
938C  46                  byte  $46
938D  40                  byte  $40
938E  40                  byte  $40
938F  40                  byte  $40
9390  FF                  byte  $FF
9391  FF                  byte  $FF
9392  7A                  byte  $7A
9393  FF                  byte  $FF
9394  5E                  byte  $5E
9395  CA                  byte  $CA
9396  3F                  byte  $3F
9397  8D                  byte  $8D
9398  2A                  byte  $2A
9399  60                  byte  $60
939A  00                  byte  $00
939B  00                  byte  $00
939C  FF                  byte  $FF
939D  FF                  byte  $FF
939E  7A                  byte  $7A
939F  FA                  byte  $FA
93A0  2A                  byte  $2A
93A1  60                  byte  $60
93A2  00                  byte  $00
93A3  00                  byte  $00
93A4  00                  byte  $00
93A5  00                  byte  $00
93A6  00                  byte  $00
93A7  00                  byte  $00
;
;*************************************************** REG_F6 points here
;
93A8  3094                word  $9430

93AA  33                  byte  $33
93AB  33                  byte  $33
93AC  00                  byte  $00
93AD  40                  byte  $40
93AE  1A                  byte  $1A
93AF  01                  byte  $01
93B0  01                  byte  $01
93B1  FF                  byte  $FF
93B2  2C                  byte  $2C
93B3  01                  byte  $01
93B4  00                  byte  $00
93B5  00                  byte  $00
93B6  00                  byte  $00
93B7  00                  byte  $00
93B8  00                  byte  $00
93B9  00                  byte  $00
93BA  01                  byte  $01
93BB  00                  byte  $00	; BIHP Brake Input Hardware Present
93BC  00                  byte  $00 ; PSPSHP Power Steering Pressure Switch Present
93BD  00                  byte  $00
93BE  71                  byte  $71
93BF  76                  byte  $76
93C0  05                  byte  $05
93C1  FF                  byte  $FF
93C2  90                  byte  $90
93C3  01                  byte  $01
93C4  A0                  byte  $A0
93C5  0F                  byte  $0F
93C6  14                  byte  $14
93C7  9B                  byte  $9B
93C8  03                  byte  $03
93C9  FF                  byte  $FF
93CA  66                  byte  $66
93CB  66                  byte  $66
93CC  AE                  byte  $AE
93CD  07                  byte  $07
93CE  38                  byte  $38
93CF  5F                  byte  $5F
93D0  00                  byte  $00
93D1  00                  byte  $00
93D2  00                  byte  $00
93D3  00                  byte  $00
93D4  66                  byte  $66
93D5  66                  byte  $66
93D6  D7                  byte  $D7
93D7  03                  byte  $03
93D8  FF                  byte  $FF
93D9  FF                  byte  $FF
93DA  48                  byte  $48
93DB  0D                  byte  $0D
93DC  20                  byte  $20
93DD  03                  byte  $03
93DE  3C                  byte  $3C
93DF  FF                  byte  $FF
93E0  00                  byte  $00
93E1  00                  byte  $00	; ECADHP XXXX Hardware Present (Electronic Control Assembly ????)
93E2  71                  byte  $71
93E3  48                  byte  $48
93E4  1E                  byte  $1E
93E5  6C                  byte  $6C
93E6  22                  byte  $22
93E7  1A                  byte  $1A
93E8  00                  byte  $00
93E9  00                  byte  $00
93EA  00                  byte  $00
93EB  00                  byte  $00
93EC  00                  byte  $00
93ED  76                  byte  $76
93EE  03                  byte  $03
93EF  00                  byte  $00
93F0  01                  byte  $01
93F1  FF                  byte  $FF
93F2  88                  byte  $88
93F3  13                  byte  $13
93F4  20                  byte  $20
93F5  03                  byte  $03
93F6  A5                  byte  $A5
93F7  DC                  byte  $DC
93F8  00                  byte  $00
93F9  00                  byte  $00
93FA  DC                  byte  $DC
93FB  05                  byte  $05
93FC  00                  byte  $00
93FD  18                  byte  $18
93FE  0C                  byte  $0C
93FF  00                  byte  $00
9400  F6                  byte  $F6
9401  00                  byte  $00
9402  79                  byte  $79
9403  04                  byte  $04
9404  C8                  byte  $C8
9405  00                  byte  $00
9406  90                  byte  $90
9407  01                  byte  $01
9408  00                  byte  $00
9409  87                  byte  $87
940A  00                  byte  $00
940B  05                  byte  $05
940C  0C                  byte  $0C
940D  00                  byte  $00
940E  00                  byte  $00	; Is there a ??? present - HPACL Hardware Present Automatic Adjustable Shock Controller
940F  FF                  byte  $FF
9410  D5                  byte  $D5
9411  09                  byte  $09
9412  80                  byte  $80
9413  A2                  byte  $A2
9414  6E                  byte  $6E	; ROM $9414 fan_low_speed_temp (220DegF)
9415  02                  byte  $02
9416  02                  byte  $02
9417  50                  byte  $50
9418  0A                  byte  $0A
9419  0A                  byte  $0A
941A  E0                  byte  $E0
941B  01                  byte  $01
941C  00                  byte  $00	; ROM $941C fan_control_enable - EDFHP Electro Drive Fan Hardware Present
941D  00                  byte  $00	; ROM $941D fan_high_speed_enable - HEDFHP High speed Electro Drive Fan Hardware Present
941E  75                  byte  $75	; ROM $941E fan_high_speed_temp_1(234DegF)
941F  79                  byte  $79	; ROM $941F fan_high_speed_temp_2(242DegF)
9420  71                  byte  $71
9421  50                  byte  $50
9422  00                  byte  $00
9423  C0                  byte  $C0
9424  66                  byte  $66
9425  46                  byte  $46
9426  32                  byte  $32
9427  4B                  byte  $4B
9428  4B                  byte  $4B	; ECT value?
9429  FF                  byte  $FF
942A  00                  byte  $00
942B  02                  byte  $02
942C  CD                  byte  $CD
942D  03                  byte  $03
942E  EF                  byte  $EF
942F  50                  byte  $50
;
;*************************************************** REG_F8 points here
;
9430  A897                word  $97A8

9432  00                  byte  $00
9433  00                  byte  $00
9434  00                  byte  $00	; ROM $9434 spark_adder_part_throttle
9435  00                  byte  $00
9436  68                  byte  $68
9437  10                  byte  $10
9438  E8                  byte  $E8
9439  03                  byte  $03
943A  00                  byte  $00	; ROM $943B spark_adder_WOT
943B  00                  byte  $00
943C  00                  byte  $00
943D  B4                  byte  $B4
943E  80                  byte  $80
943F  20                  byte  $20
9440  01                  byte  $01
9441  00                  byte  $00
9442  00                  byte  $00
9443  00                  byte  $00
9444  10                  byte  $10
9445  03                  byte  $03
9446  10                  byte  $10
9447  03                  byte  $03
9448  FF                  byte  $FF
9449  00                  byte  $00	; HP_HIDRES  = Hardware present - High Data Rate Electronic Spark
944A  00                  byte  $00
944B  FF                  byte  $FF
944C  7B                  byte  $7B
944D  14                  byte  $14
944E  F6                  byte  $F6
944F  28                  byte  $28
9450  30                  byte  $30
9451  00                  byte  $00
9452  EC                  byte  $EC
9453  11                  byte  $11
9454  AE                  byte  $AE
9455  07                  byte  $07
9456  00                  byte  $00	; ROM $9456 max_low_speed_dwell word
9457  80                  byte  $80
9458  33                  byte  $33	; ROM $9458 max_high_speed_dwell word
9459  33                  byte  $33
945A  70                  byte  $70
945B  26                  byte  $26
945C  1F                  byte  $1F
945D  05                  byte  $05
945E  20                  byte  $20
945F  02                  byte  $02
9460  00                  byte  $00
9461  00                  byte  $00
9462  00                  byte  $00	; ROM $9462 tip_in_retard_max = 0 byte
9463  01                  byte  $01
9464  CD                  byte  $CD
9465  1C                  byte  $1C
9466  66                  byte  $66
9467  06                  byte  $06
9468  00                  byte  $00
9469  7D                  byte  $7D
946A  66                  byte  $66
946B  06                  byte  $06
946C  00                  byte  $00
946D  3C                  byte  $3C
946E  00                  byte  $00
946F  00                  byte  $00
9470  00                  byte  $00
9471  80                  byte  $80
9472  00                  byte  $00
9473  00                  byte  $00
9474  80                  byte  $80
9475  3E                  byte  $3E
9476  AE                  byte  $AE
9477  07                  byte  $07
9478  04                  byte  $04
9479  0C                  byte  $0C

947A  00                  byte  $00		; KIHP = 00 Knock Input Hardware Present
947B  01                  byte  $01
947C  EF                  byte  $EF
947D  FF                  byte  $FF
947E  00                  byte  $00
947F  06                  byte  $06
9480  33                  byte  $33
9481  00                  byte  $00
9482  71                  byte  $71
9483  00                  byte  $00
9484  0A                  byte  $0A
9485  02                  byte  $02
9486  0A                  byte  $0A
9487  FF                  byte  $FF
9488  FF                  byte  $FF
9489  7F                  byte  $7F
948A  00                  byte  $00
948B  06                  byte  $06
948C  73                  byte  $73
948D  00                  byte  $00
948E  00                  byte  $00
948F  06                  byte  $06
9490  69                  byte  $69
9491  00                  byte  $00
9492  00                  byte  $00
9493  05                  byte  $05
9494  62                  byte  $62
9495  00                  byte  $00
9496  00                  byte  $00
9497  04                  byte  $04
9498  35                  byte  $35
9499  00                  byte  $00
949A  00                  byte  $00
949B  03                  byte  $03
949C  1E                  byte  $1E
949D  00                  byte  $00
949E  00                  byte  $00
949F  00                  byte  $00
94A0  00                  byte  $00
94A1  80                  byte  $80
94A2  00                  byte  $00
94A3  00                  byte  $00
94A4  00                  byte  $00
94A5  80                  byte  $80
94A6  00                  byte  $00
94A7  00                  byte  $00
94A8  00                  byte  $00
94A9  80                  byte  $80
94AA  00                  byte  $00
94AB  00                  byte  $00
94AC  FF                  byte  $FF
94AD  7F                  byte  $7F
94AE  7C                  byte  $7C
94AF  00                  byte  $00
94B0  40                  byte  $40
94B1  06                  byte  $06
94B2  7C                  byte  $7C
94B3  00                  byte  $00
94B4  BC                  byte  $BC
94B5  02                  byte  $02
94B6  00                  byte  $00
94B7  00                  byte  $00
94B8  00                  byte  $00
94B9  80                  byte  $80
94BA  00                  byte  $00
94BB  00                  byte  $00
94BC  00                  byte  $00
94BD  80                  byte  $80
94BE  00                  byte  $00
94BF  00                  byte  $00
94C0  7F                  byte  $7F
94C1  00                  byte  $00
94C2  12                  byte  $12
94C3  00                  byte  $00
94C4  00                  byte  $00
94C5  0C                  byte  $0C
94C6  80                  byte  $80
94C7  0C                  byte  $0C
94C8  80                  byte  $80
94C9  0C                  byte  $0C
94CA  80                  byte  $80
94CB  0C                  byte  $0C
94CC  80                  byte  $80
94CD  0C                  byte  $0C
94CE  FF                  byte  $FF
94CF  00                  byte  $00
94D0  00                  byte  $00
94D1  00                  byte  $00
94D2  00                  byte  $00
94D3  00                  byte  $00
94D4  00                  byte  $00
94D5  00                  byte  $00
94D6  00                  byte  $00
94D7  00                  byte  $00
94D8  00                  byte  $00
94D9  00                  byte  $00
94DA  FF                  byte  $FF
94DB  FF                  byte  $FF
94DC  8F                  byte  $8F
94DD  02                  byte  $02
94DE  00                  byte  $00
94DF  19                  byte  $19
94E0  8F                  byte  $8F
94E1  02                  byte  $02
94E2  70                  byte  $70
94E3  17                  byte  $17
94E4  A4                  byte  $A4
94E5  10                  byte  $10
94E6  30                  byte  $30
94E7  11                  byte  $11
94E8  A4                  byte  $A4
94E9  10                  byte  $10
94EA  00                  byte  $00
94EB  00                  byte  $00
94EC  CD                  byte  $CD
94ED  2C                  byte  $2C

          ;Func: Spark Advance vs ACT - pt_advance_vs_act
          ;X: Air Charge Temperature
          ;Scale: 2.000000 Offset: 0.000000 Math: 0
          ;Y: Spark Advance [Deg BTDC]
          ;Scale: 4.000000 Offset: 0.000000 Math: 1
          ;org 094EEh
          DB   07Fh,0F8h
          DB   05Fh,0F8h
          DB   050h,000h
          DB   080h,000h
          DB   080h,000h

94EE  7F                  byte  $7F
94EF  F8                  byte  $F8
94F0  5F                  byte  $5F
94F1  F8                  byte  $F8
94F2  50                  byte  $50
94F3  00                  byte  $00
94F4  80                  byte  $80
94F5  00                  byte  $00
94F6  80                  byte  $80
94F7  00                  byte  $00

94F8  FF                  byte  $FF
94F9  00                  byte  $00
94FA  DE                  byte  $DE
94FB  00                  byte  $00
94FC  D4                  byte  $D4
94FD  80                  byte  $80
94FE  BC                  byte  $BC
94FF  80                  byte  $80
9500  60                  byte  $60
9501  9A                  byte  $9A
9502  00                  byte  $00
9503  9A                  byte  $9A

; WOT Spark Advance vs RPM
; words / 4
; 32 bytes
; 2 bytes per entry
; divide by 4 for each entry
; reverse order 
; interleaved x and y
; y = RPM
; x = advance

          ;Func: WOT Spark Advance vs RPM
          ;X: RPM
          ;Scale: 4.000000 Offset: 0.000000 Math: 1
          ;Y: WOT Spark Advance Deg BTDC
          ;Scale: 4.000000 Offset: 0.000000 Math: 1
          ;org 09504h
          DW   0FFFFh,00079h
          DW   04E20h,00079h	//  5,000 RPM = $04E20 >> 4 * 8 ( the var is saved / 4 )
          DW   036B0h,0006Bh	//  3,500 RPM
          DW   028A0h,0006Bh	//  2,600 RPM
          DW   02198h,00067h	//  2,150 RPM
          DW   01C20h,00059h	//  1,800 RPM
          DW   00FA0h,00029h	//  1,000 RPM
          DW   00000h,00029h	//      0 RPM

9504  FF                  byte  $FF	$FFFF	Y8 = 16383.75
9505  FF                  byte  $FF
9506  68                  byte  $68	$0068	X8 = 26.0
9507  00                  byte  $00
9508  20                  byte  $20	$4E20	Y7 = 5000.0
9509  4E                  byte  $4E
950A  68                  byte  $68	$0068	X7 = 26.0
950B  00                  byte  $00
950C  B0                  byte  $B0	$36B0	Y6 = 3500.0
950D  36                  byte  $36
950E  58                  byte  $58	$0058	X6 = 22.0
950F  00                  byte  $00
9510  A0                  byte  $A0	$28A0	Y5 = 2600.0
9511  28                  byte  $28
9512  5A                  byte  $5A	$005A	X5 = 22.5
9513  00                  byte  $00
9514  98                  byte  $98	$2198	Y4 = 2150.0
9515  21                  byte  $21
9516  56                  byte  $56	$0056	X4 = 21.5
9517  00                  byte  $00
9518  20                  byte  $20	$1C20	Y3 = 1800.0
9519  1C                  byte  $1C
951A  4A                  byte  $4A	$004A	X3 = 18.5
951B  00                  byte  $00
951C  A0                  byte  $A0	$0FA0	Y2 = 1000.0
951D  0F                  byte  $0F
951E  20                  byte  $20	$0020	Y2 = 8
951F  00                  byte  $00
9520  00                  byte  $00	$0000	X1 = 0
9521  00                  byte  $00
9522  20                  byte  $20	$0020	Y1 = 8
9523  00                  byte  $00

9524  00                  byte  $00
9525  00                  byte  $00
9526  20                  byte  $20
9527  00                  byte  $00

          ;Func: Spark Advance vs. BP
          ;X: Barometric Pressure
          ;Scale: 8.000000 Offset: 0.000000 Math: 1
          ;Y: Spark Adder Deg
          ;Scale: 4.000000 Offset: 0.000000 Math: 1
          ;org 09528h
          DB   0FFh,000h
          DB   0DEh,000h
          DB   0D4h,010h
          DB   0BCh,010h
          DB   000h,030h

9528  FF                  byte  $FF
9529  00                  byte  $00
952A  DE                  byte  $DE
952B  00                  byte  $00
952C  D4                  byte  $D4
952D  10                  byte  $10
952E  BC                  byte  $BC
952F  10                  byte  $10
9530  00                  byte  $00
9531  30                  byte  $30
;
; WOT Spark Advance vs ECT
;

          ;Func: WOT Spark Advance vs ECT
          ;X: Engine Coolant Temp
          ;Scale: 2.000000 Offset: 0.000000 Math: 0
          ;Y: WOT SparkAdvance Deg BTDC
          ;Scale: 4.000000 Offset: 0.000000 Math: 1
          ;org 09532h
          DB   07Fh,0F0h
          DB   07Bh,0F0h
          DB   076h,0F8h
          DB   064h,000h
          DB   03Ch,000h
          DB   02Bh,00Ch
          DB   080h,00Ch

9532  7F                  byte  $7F	127*2 = 254
9533  F0                  byte  $F0	-10/4 = -2.5
9534  7B                  byte  $7B	123*2 = 246
9535  F0                  byte  $F0	-10/4 = -2.5
9536  76                  byte  $76	118*2 = 236
9537  F8                  byte  $F8	-8/4  = -2
9538  64                  byte  $64	100*2 = 200
9539  00                  byte  $00	0     = 0
953A  3C                  byte  $3C	60*2  = 120
953B  00                  byte  $00	0/4   = 0
953C  2B                  byte  $2B	43*2  = 86
953D  0C                  byte  $0C	12/4  = 3
953E  80                  byte  $80	-128*2= -256
953F  0C                  byte  $0C	s12/4 = 3

          ;Func: WOT Spark Advance vs ACT
          ;X: Intake Air Charge Temp
          ;Scale: 2.000000 Offset: 0.000000 Math: 0
          ;Y: WOT Spark Advance Deg BTDC
          ;Scale: 4.000000 Offset: 0.000000 Math: 1
          ;org 09540h
          DB   07Fh,0E8h
          DB   078h,0E8h
          DB   04Bh,000h
          DB   080h,000h
          DB   080h,000h
          DB   080h,000h


9540  7F                  byte  $7F
9541  E8                  byte  $E8
9542  78                  byte  $78
9543  E8                  byte  $E8
9544  4B                  byte  $4B
9545  00                  byte  $00
9546  80                  byte  $80
9547  00                  byte  $00
9548  80                  byte  $80
9549  00                  byte  $00
954A  80                  byte  $80
954B  00                  byte  $00
954C  80                  byte  $80
954D  00                  byte  $00
954E  FF                  byte  $FF
954F  00                  byte  $00
9550  00                  byte  $00
9551  00                  byte  $00
9552  00                  byte  $00
9553  00                  byte  $00
9554  00                  byte  $00
9555  00                  byte  $00
9556  00                  byte  $00
9557  00                  byte  $00
9558  00                  byte  $00
9559  00                  byte  $00
955A  FF                  byte  $FF
955B  09                  byte  $09
955C  DC                  byte  $DC
955D  00                  byte  $00
955E  05                  byte  $05
955F  00                  byte  $00
9560  00                  byte  $00
9561  08                  byte  $08
9562  00                  byte  $00
9563  08                  byte  $08
9564  00                  byte  $00
9565  08                  byte  $08
9566  00                  byte  $00
9567  08                  byte  $08
9568  7F                  byte  $7F
9569  00                  byte  $00
956A  33                  byte  $33
956B  00                  byte  $00
956C  2D                  byte  $2D
956D  1E                  byte  $1E
956E  23                  byte  $23
956F  1E                  byte  $1E
9570  1E                  byte  $1E
9571  00                  byte  $00
9572  80                  byte  $80
9573  00                  byte  $00

          ;Map: Base Spark [Deg BTDC]					; note values slightly different
          ;Scale: 4.000000 Offset: 0.000000 Math: 1
          ;10 Cols: Speed [RPM]
          ;500|700|900|1100|1300|1500|2000|2500|3000|4000
          ;8 Rows: Load []
          ;.05|.15|.23|.30|.40|.50|.60|.75
          ;org 09574h
          DB   070h,070h,070h,06Dh,074h,078h,078h,078h,078h,078h
          DB   070h,070h,070h,07Dh,085h,089h,089h,089h,071h,071h
          DB   070h,070h,084h,0A6h,0A6h,0ABh,0AFh,0AFh,081h,081h
          DB   073h,078h,081h,085h,094h,094h,0AFh,0B8h,081h,081h
          DB   05Ch,061h,073h,081h,08Fh,094h,098h,09Ch,081h,081h
          DB   045h,045h,04Ah,04Ah,053h,05Ch,06Ah,07Dh,07Dh,07Dh
          DB   02Eh,039h,039h,039h,044h,04Eh,06Dh,06Dh,06Dh,06Dh
          DB   02Eh,02Eh,034h,034h,03Eh,049h,05Eh,06Dh,06Dh,06Dh

9574  70                  byte  $70
9575  70                  byte  $70
9576  70                  byte  $70
9577  7C                  byte  $7C
9578  84                  byte  $84
9579  88                  byte  $88
957A  88                  byte  $88
957B  88                  byte  $88
957C  88                  byte  $88
957D  88                  byte  $88
957E  70                  byte  $70
957F  70                  byte  $70
9580  70                  byte  $70
9581  7C                  byte  $7C
9582  84                  byte  $84
9583  88                  byte  $88
9584  88                  byte  $88
9585  88                  byte  $88
9586  70                  byte  $70
9587  70                  byte  $70
9588  70                  byte  $70
9589  70                  byte  $70
958A  84                  byte  $84
958B  90                  byte  $90
958C  90                  byte  $90
958D  94                  byte  $94
958E  98                  byte  $98
958F  98                  byte  $98
9590  70                  byte  $70
9591  70                  byte  $70
9592  64                  byte  $64
9593  68                  byte  $68
9594  70                  byte  $70
9595  74                  byte  $74
9596  80                  byte  $80
9597  80                  byte  $80
9598  98                  byte  $98
9599  A0                  byte  $A0
959A  70                  byte  $70
959B  70                  byte  $70
959C  50                  byte  $50
959D  54                  byte  $54
959E  64                  byte  $64
959F  70                  byte  $70
95A0  7C                  byte  $7C
95A1  80                  byte  $80
95A2  84                  byte  $84
95A3  88                  byte  $88
95A4  70                  byte  $70
95A5  70                  byte  $70
95A6  3C                  byte  $3C
95A7  3C                  byte  $3C
95A8  40                  byte  $40
95A9  40                  byte  $40
95AA  48                  byte  $48
95AB  50                  byte  $50
95AC  5C                  byte  $5C
95AD  6C                  byte  $6C
95AE  6C                  byte  $6C
95AF  6C                  byte  $6C
95B0  20                  byte  $20
95B1  28                  byte  $28
95B2  28                  byte  $28
95B3  2C                  byte  $2C
95B4  34                  byte  $34
95B5  3C                  byte  $3C
95B6  54                  byte  $54
95B7  54                  byte  $54
95B8  54                  byte  $54
95B9  54                  byte  $54

95BA  20                  byte  $20
95BB  20                  byte  $20
95BC  24                  byte  $24
95BD  28                  byte  $28
95BE  30                  byte  $30
95BF  38                  byte  $38
95C0  48                  byte  $48
95C1  54                  byte  $54
95C2  54                  byte  $54
95C3  54                  byte  $54

          ;Map: Altitude Base Spark [Deg BTDC]					; note values slightly different
          ;Scale: 4.000000 Offset: 0.000000 Math: 1
          ;10 Cols: Speed [RPM]
          ;500|700|900|1100|1300|1500|2000|2500|3000|4000
          ;8 Rows: Load []
          ;.05|.15|.23|.30|.40|.50|.60|.75
          ;org 095C4h
          DB   070h,070h,070h,06Dh,074h,078h,078h,078h,078h,078h
          DB   070h,070h,070h,081h,089h,08Dh,08Dh,089h,071h,071h
          DB   070h,070h,084h,0ABh,0ABh,0AFh,0AFh,0AFh,081h,081h
          DB   073h,078h,08Ah,0ABh,0AFh,0A6h,0A6h,0AFh,081h,081h
          DB   05Ch,061h,073h,094h,09Ch,09Ch,098h,094h,081h,081h
          DB   045h,04Ah,04Ah,04Ah,053h,05Ch,078h,07Dh,07Dh,07Dh
          DB   02Eh,02Eh,034h,034h,039h,049h,06Dh,06Dh,06Dh,06Dh
          DB   02Eh,02Eh,034h,034h,039h,044h,06Dh,06Dh,06Dh,06Dh

95C4  70                  byte  $70
95C5  70                  byte  $70
95C6  70                  byte  $70
95C7  7C                  byte  $7C
95C8  84                  byte  $84
95C9  88                  byte  $88
95CA  88                  byte  $88
95CB  88                  byte  $88
95CC  88                  byte  $88
95CD  88                  byte  $88
95CE  70                  byte  $70
95CF  70                  byte  $70
95D0  70                  byte  $70
95D1  80                  byte  $80
95D2  88                  byte  $88
95D3  8C                  byte  $8C
95D4  8C                  byte  $8C
95D5  88                  byte  $88
95D6  70                  byte  $70
95D7  70                  byte  $70
95D8  70                  byte  $70
95D9  70                  byte  $70
95DA  84                  byte  $84
95DB  94                  byte  $94
95DC  94                  byte  $94
95DD  98                  byte  $98
95DE  98                  byte  $98
95DF  98                  byte  $98
95E0  70                  byte  $70
95E1  70                  byte  $70
95E2  64                  byte  $64
95E3  68                  byte  $68
95E4  78                  byte  $78
95E5  94                  byte  $94
95E6  98                  byte  $98
95E7  90                  byte  $90
95E8  90                  byte  $90
95E9  98                  byte  $98
95EA  70                  byte  $70
95EB  70                  byte  $70
95EC  50                  byte  $50
95ED  54                  byte  $54
95EE  64                  byte  $64
95EF  80                  byte  $80
95F0  88                  byte  $88
95F1  88                  byte  $88
95F2  84                  byte  $84
95F3  80                  byte  $80
95F4  70                  byte  $70
95F5  70                  byte  $70
95F6  3C                  byte  $3C
95F7  40                  byte  $40
95F8  40                  byte  $40
95F9  40                  byte  $40
95FA  48                  byte  $48
95FB  50                  byte  $50
95FC  68                  byte  $68
95FD  6C                  byte  $6C
95FE  6C                  byte  $6C
95FF  6C                  byte  $6C
9600  20                  byte  $20
9601  20                  byte  $20
9602  24                  byte  $24
9603  28                  byte  $28
9604  2C                  byte  $2C
9605  38                  byte  $38
9606  54                  byte  $54
9607  54                  byte  $54
9608  54                  byte  $54
9609  54                  byte  $54

960A  20                  byte  $20	; spark_altitude_table (bad loc???)
960B  20                  byte  $20
960C  24                  byte  $24
960D  28                  byte  $28
960E  2C                  byte  $2C
960F  34                  byte  $34
9610  54                  byte  $54
9611  54                  byte  $54
9612  54                  byte  $54
9613  54                  byte  $54

          ;Map: Limp Mode Spark Table [Deg BTDC]			; Table slightly different
          ;Scale: 4.000000 Offset: 0.000000 Math: 1
          ;10 Cols: Speed [RPM]
          ;500|700|900|1100|1300|1500|2000|2500|3000|4000
          ;8 Rows: Load []
          ;.05|.15|.23|.30|.40|.50|.60|.75
          ;org 09614h
          DB   070h,070h,070h,06Dh,074h,078h,078h,078h,078h,078h
          DB   070h,070h,070h,07Dh,085h,089h,089h,089h,089h,089h
          DB   064h,068h,07Ah,09Bh,0A1h,0A8h,0AFh,0AFh,0AFh,0AFh
          DB   05Ch,061h,05Ch,06Eh,08Fh,094h,098h,098h,098h,098h
          DB   040h,040h,040h,040h,04Ah,061h,07Dh,07Dh,07Dh,07Dh
          DB   024h,029h,02Eh,033h,03Ch,04Fh,066h,066h,066h,066h
          DB   025h,02Eh,034h,034h,03Eh,049h,05Eh,05Eh,05Eh,05Eh
          DB   025h,025h,034h,034h,03Eh,049h,05Eh,05Eh,05Eh,05Eh

9614  70                  byte  $70
9615  70                  byte  $70
9616  70                  byte  $70
9617  7C                  byte  $7C
9618  84                  byte  $84
9619  88                  byte  $88
961A  88                  byte  $88
961B  88                  byte  $88
961C  88                  byte  $88
961D  88                  byte  $88
961E  70                  byte  $70
961F  70                  byte  $70
9620  70                  byte  $70
9621  7C                  byte  $7C
9622  84                  byte  $84
9623  88                  byte  $88
9624  88                  byte  $88
9625  88                  byte  $88
9626  88                  byte  $88
9627  88                  byte  $88
9628  64                  byte  $64
9629  68                  byte  $68
962A  7A                  byte  $7A
962B  86                  byte  $86
962C  8C                  byte  $8C
962D  92                  byte  $92
962E  98                  byte  $98
962F  98                  byte  $98
9630  98                  byte  $98
9631  98                  byte  $98
9632  50                  byte  $50
9633  54                  byte  $54
9634  50                  byte  $50
9635  60                  byte  $60
9636  7C                  byte  $7C
9637  80                  byte  $80
9638  84                  byte  $84
9639  84                  byte  $84
963A  84                  byte  $84
963B  84                  byte  $84
963C  38                  byte  $38
963D  38                  byte  $38
963E  38                  byte  $38
963F  38                  byte  $38
9640  40                  byte  $40
9641  54                  byte  $54
9642  6C                  byte  $6C
9643  6C                  byte  $6C
9644  6C                  byte  $6C
9645  6C                  byte  $6C
9646  20                  byte  $20
9647  24                  byte  $24
9648  28                  byte  $28
9649  2C                  byte  $2C
964A  34                  byte  $34
964B  44                  byte  $44
964C  58                  byte  $58
964D  58                  byte  $58
964E  58                  byte  $58
964F  58                  byte  $58
9650  1A                  byte  $1A
9651  20                  byte  $20
9652  24                  byte  $24
9653  28                  byte  $28
9654  30                  byte  $30
9655  38                  byte  $38
9656  48                  byte  $48
9657  48                  byte  $48
9658  48                  byte  $48
9659  48                  byte  $48

965A  1A                  byte  $1A
965B  1A                  byte  $1A
965C  24                  byte  $24
965D  28                  byte  $28
965E  30                  byte  $30
965F  38                  byte  $38
9660  48                  byte  $48
9661  48                  byte  $48
9662  48                  byte  $48
9663  48                  byte  $48
9664  00                  byte  $00
9665  00                  byte  $00
9666  30                  byte  $30
9667  30                  byte  $30
9668  30                  byte  $30
9669  30                  byte  $30
966A  30                  byte  $30
966B  30                  byte  $30
966C  30                  byte  $30
966D  30                  byte  $30
966E  00                  byte  $00
966F  00                  byte  $00
9670  30                  byte  $30
9671  30                  byte  $30
9672  30                  byte  $30
9673  30                  byte  $30
9674  30                  byte  $30
9675  30                  byte  $30
9676  30                  byte  $30
9677  30                  byte  $30
9678  00                  byte  $00
9679  00                  byte  $00
967A  30                  byte  $30
967B  30                  byte  $30
967C  30                  byte  $30
967D  30                  byte  $30
967E  30                  byte  $30
967F  30                  byte  $30
9680  30                  byte  $30
9681  30                  byte  $30
9682  00                  byte  $00
9683  00                  byte  $00
9684  30                  byte  $30
9685  30                  byte  $30
9686  30                  byte  $30
9687  30                  byte  $30
9688  30                  byte  $30
9689  30                  byte  $30
968A  30                  byte  $30
968B  30                  byte  $30
968C  00                  byte  $00
968D  00                  byte  $00
968E  30                  byte  $30
968F  30                  byte  $30
9690  30                  byte  $30
9691  30                  byte  $30
9692  30                  byte  $30
9693  30                  byte  $30
9694  30                  byte  $30
9695  30                  byte  $30
9696  00                  byte  $00
9697  00                  byte  $00
9698  00                  byte  $00
9699  16                  byte  $16
969A  16                  byte  $16
969B  20                  byte  $20
969C  30                  byte  $30
969D  30                  byte  $30
969E  30                  byte  $30
969F  30                  byte  $30
96A0  00                  byte  $00
96A1  00                  byte  $00
96A2  00                  byte  $00
96A3  00                  byte  $00
96A4  00                  byte  $00
96A5  00                  byte  $00
96A6  00                  byte  $00
96A7  00                  byte  $00
96A8  00                  byte  $00
96A9  00                  byte  $00
96AA  00                  byte  $00
96AB  00                  byte  $00
96AC  00                  byte  $00
96AD  00                  byte  $00
96AE  00                  byte  $00
96AF  00                  byte  $00
96B0  00                  byte  $00
96B1  00                  byte  $00
96B2  00                  byte  $00
96B3  00                  byte  $00
96B4  00                  byte  $00
96B5  10                  byte  $10
96B6  04                  byte  $04
96B7  00                  byte  $00
96B8  20                  byte  $20
96B9  14                  byte  $14
96BA  04                  byte  $04
96BB  08                  byte  $08
96BC  2C                  byte  $2C
96BD  24                  byte  $24
96BE  10                  byte  $10
96BF  10                  byte  $10
96C0  00                  byte  $00
96C1  00                  byte  $00
96C2  00                  byte  $00
96C3  00                  byte  $00
96C4  00                  byte  $00
96C5  00                  byte  $00
96C6  00                  byte  $00
96C7  00                  byte  $00
96C8  00                  byte  $00
96C9  00                  byte  $00
96CA  00                  byte  $00
96CB  00                  byte  $00
96CC  00                  byte  $00
96CD  00                  byte  $00
96CE  00                  byte  $00
96CF  00                  byte  $00
96D0  00                  byte  $00
96D1  00                  byte  $00
96D2  00                  byte  $00
96D3  00                  byte  $00
96D4  00                  byte  $00
96D5  00                  byte  $00
96D6  00                  byte  $00
96D7  00                  byte  $00
96D8  00                  byte  $00
96D9  00                  byte  $00
96DA  00                  byte  $00
96DB  00                  byte  $00
96DC  00                  byte  $00
96DD  00                  byte  $00
96DE  00                  byte  $00
96DF  00                  byte  $00
96E0  00                  byte  $00
96E1  00                  byte  $00
96E2  00                  byte  $00
96E3  00                  byte  $00
96E4  00                  byte  $00
96E5  00                  byte  $00
96E6  00                  byte  $00
96E7  00                  byte  $00
96E8  00                  byte  $00
96E9  00                  byte  $00
96EA  00                  byte  $00
96EB  00                  byte  $00
96EC  00                  byte  $00
96ED  00                  byte  $00
96EE  00                  byte  $00
96EF  00                  byte  $00
96F0  00                  byte  $00
96F1  00                  byte  $00
96F2  00                  byte  $00
96F3  00                  byte  $00
96F4  00                  byte  $00
96F5  00                  byte  $00
96F6  00                  byte  $00
96F7  00                  byte  $00
96F8  00                  byte  $00
96F9  00                  byte  $00
96FA  00                  byte  $00
96FB  00                  byte  $00
96FC  00                  byte  $00
96FD  00                  byte  $00
96FE  00                  byte  $00
96FF  00                  byte  $00
9700  00                  byte  $00
9701  00                  byte  $00
9702  00                  byte  $00
9703  00                  byte  $00
9704  00                  byte  $00
9705  00                  byte  $00
9706  00                  byte  $00
9707  00                  byte  $00
9708  00                  byte  $00
9709  00                  byte  $00
970A  00                  byte  $00
970B  00                  byte  $00
970C  00                  byte  $00
970D  00                  byte  $00
970E  00                  byte  $00
970F  00                  byte  $00
9710  00                  byte  $00
9711  00                  byte  $00
9712  00                  byte  $00
9713  00                  byte  $00
9714  00                  byte  $00
9715  00                  byte  $00
9716  00                  byte  $00
9717  00                  byte  $00
9718  00                  byte  $00
9719  00                  byte  $00
971A  00                  byte  $00
971B  00                  byte  $00
971C  00                  byte  $00
971D  00                  byte  $00
971E  00                  byte  $00
971F  00                  byte  $00
9720  00                  byte  $00
9721  00                  byte  $00
9722  00                  byte  $00
9723  00                  byte  $00
9724  00                  byte  $00
9725  0C                  byte  $0C
9726  00                  byte  $00
9727  00                  byte  $00
9728  00                  byte  $00
9729  00                  byte  $00
972A  00                  byte  $00
972B  00                  byte  $00
972C  0C                  byte  $0C
972D  00                  byte  $00
972E  00                  byte  $00
972F  00                  byte  $00
9730  00                  byte  $00
9731  00                  byte  $00
9732  F0                  byte  $F0
9733  14                  byte  $14
9734  00                  byte  $00
9735  00                  byte  $00
9736  00                  byte  $00
9737  00                  byte  $00
9738  00                  byte  $00
9739  F0                  byte  $F0
973A  14                  byte  $14
973B  00                  byte  $00
973C  00                  byte  $00
973D  00                  byte  $00
973E  00                  byte  $00
973F  FC                  byte  $FC
9740  F0                  byte  $F0
9741  14                  byte  $14
9742  00                  byte  $00
9743  00                  byte  $00
9744  00                  byte  $00
9745  00                  byte  $00
9746  F8                  byte  $F8
9747  F0                  byte  $F0

          ;Func: Min Low Speed Dwell
          ;X: Battery Voltage
          ;Scale: 16.000000 Offset: 0.000000 Math: 1
          ;Y: Dwell / Coil Off Time [ms]
          ;Scale: 512.000000 Offset: 0.000000 Math: 1
          ;org 09748h
          DW   0FFFFh,005BCh
          DW   000F0h,005BCh
          DW   000E0h,00625h
          DW   000C0h,00831h
          DW   000A0h,00937h
          DW   00000h,00937h

9748  FF                  byte  $FF
9749  FF                  byte  $FF
974A  BC                  byte  $BC
974B  05                  byte  $05
974C  F0                  byte  $F0
974D  00                  byte  $00
974E  BC                  byte  $BC
974F  05                  byte  $05
9750  E0                  byte  $E0
9751  00                  byte  $00
9752  25                  byte  $25
9753  06                  byte  $06
9754  C0                  byte  $C0
9755  00                  byte  $00
9756  31                  byte  $31
9757  08                  byte  $08
9758  A0                  byte  $A0
9759  00                  byte  $00
975A  37                  byte  $37
975B  09                  byte  $09
975C  00                  byte  $00
975D  00                  byte  $00
975E  37                  byte  $37
975F  09                  byte  $09

          ;Func: Min High Speed Dwell
          ;X: Battery Voltage
          ;Scale: 16.000000 Offset: 0.000000 Math: 1
          ;Y: Dwell / Coil Off Time [ms]
          ;Scale: 512.000000 Offset: 0.000000 Math: 1
          ;org 09760h
          DW   0FFFFh,00625h
          DW   000F0h,00625h
          DW   000D0h,006DCh
          DW   000C0h,00794h
          DW   000A0h,00A3Dh
          DW   00000h,00A3Dh

9760  FF                  byte  $FF
9761  FF                  byte  $FF
9762  25                  byte  $25
9763  06                  byte  $06
9764  F0                  byte  $F0
9765  00                  byte  $00
9766  25                  byte  $25
9767  06                  byte  $06
9768  D0                  byte  $D0
9769  00                  byte  $00
976A  DC                  byte  $DC
976B  06                  byte  $06
976C  C0                  byte  $C0
976D  00                  byte  $00
976E  94                  byte  $94
976F  07                  byte  $07
9770  A0                  byte  $A0
9771  00                  byte  $00
9772  3D                  byte  $3D
9773  0A                  byte  $0A
9774  00                  byte  $00
9775  00                  byte  $00
9776  3D                  byte  $3D
9777  0A                  byte  $0A
9778  FF                  byte  $FF
9779  04                  byte  $04
977A  9C                  byte  $9C
977B  04                  byte  $04
977C  5E                  byte  $5E
977D  0C                  byte  $0C
977E  1F                  byte  $1F
977F  10                  byte  $10
9780  00                  byte  $00
9781  14                  byte  $14
9782  00                  byte  $00
9783  14                  byte  $14
9784  FF                  byte  $FF
9785  19                  byte  $19
9786  9C                  byte  $9C
9787  19                  byte  $19
9788  5E                  byte  $5E
9789  16                  byte  $16
978A  4E                  byte  $4E
978B  13                  byte  $13
978C  3F                  byte  $3F
978D  04                  byte  $04
978E  2F                  byte  $2F
978F  03                  byte  $03
9790  00                  byte  $00
9791  03                  byte  $03
9792  FF                  byte  $FF
9793  00                  byte  $00
9794  00                  byte  $00
9795  00                  byte  $00
9796  00                  byte  $00
9797  00                  byte  $00
9798  00                  byte  $00
9799  00                  byte  $00
979A  00                  byte  $00
979B  00                  byte  $00

          ;Func: Spark Advance Rate vs RPM
          ;X: RPM
          ;Scale: 32.000000 Offset: 0.000000 Math: 0
          ;Y: Seconds/Degree
          ;Scale: 16.000000 Offset: 0.000000 Math: 1
          ;org 0979Ch
     ;( 8160, 1 )     ( 4000, 1 )     ( 3008, 1.5 )
     ;( 992, 2 )      ( 0, 2 )        ( 0, 2 )
          DB   0FFh,010h
          DB   07Dh,010h
          DB   05Eh,018h
          DB   01Fh,020h
          DB   000h,020h
          DB   000h,020h

979C  FF                  byte  $FF
979D  10                  byte  $10
979E  7D                  byte  $7D
979F  10                  byte  $10
97A0  5E                  byte  $5E
97A1  18                  byte  $18
97A2  1F                  byte  $1F
97A3  20                  byte  $20
97A4  00                  byte  $00
97A5  20                  byte  $20
97A6  00                  byte  $00
97A7  20                  byte  $20
;
;*************************************************** REG_FA points here
;
97A8  7E9A                word  $9A7E

97AA  00                  byte  $00
97AB  02                  byte  $02
97AC  40                  byte  $40
97AD  01                  byte  $01
97AE  40                  byte  $40
97AF  01                  byte  $01
97B0  C0                  byte  $C0	; WOT_Voltage (WOT breakpoint (TPS voltage - 1)) word
97B1  8A                  byte  $8A	; WOT_Throttle_breakpoint
97B2  7F                  byte  $7F ; LDEL - 254 degrees?
97B3  6E                  byte  $6E ; LDEH - 220 degrees?
97B4  0A                  byte  $0A
97B5  28                  byte  $28
97B6  B8                  byte  $B8
97B7  7E                  byte  $7E
97B8  D7                  byte  $D7
97B9  03                  byte  $03
97BA  FF                  byte  $FF	; ROM $97BA fuel_open_loop_multiplier - word
97BB  00                  byte  $00

97BC  08                  byte  $08	; RPM classifications
97BD  FF                  byte  $FF
97BE  20                  byte  $20
97BF  03                  byte  $03
97C0  90                  byte  $90
97C1  01                  byte  $01
97C2  84                  byte  $84
97C3  03                  byte  $03
97C4  C8                  byte  $C8
97C5  00                  byte  $00

97C6  02                  byte  $02
97C7  1E                  byte  $1E
97C8  5A                  byte  $5A
97C9  00                  byte  $00
97CA  00                  byte  $00
97CB  F0                  byte  $F0
97CC  00                  byte  $00
97CD  80                  byte  $80	; ROM $97CD egr_multiplier
97CE  CD                  byte  $CD
97CF  2C                  byte  $2C
97D0  00                  byte  $00
97D1  02                  byte  $02
97D2  0A                  byte  $0A
97D3  FF                  byte  $FF
97D4  FE                  byte  $FE
97D5  54                  byte  $54
97D6  00                  byte  $00
97D7  30                  byte  $30
97D8  01                  byte  $01
97D9  00                  byte  $00	; EGR_Type - egr_type ( 0=sonic, 1=PFE, 2=none) PFEHP - Pressure Feedback EGR Hardware Present
97DA  C8                  byte  $C8
97DB  00                  byte  $00
97DC  5A                  byte  $5A
97DD  FF                  byte  $FF
97DE  3D                  byte  $3D
97DF  00                  byte  $00
97E0  0A                  byte  $0A
97E1  00                  byte  $00
97E2  00                  byte  $00
97E3  01                  byte  $01
97E4  9A                  byte  $9A
97E5  02                  byte  $02
97E6  33                  byte  $33
97E7  0D                  byte  $0D
97E8  01                  byte  $01
97E9  00                  byte  $00
97EA  8F                  byte  $8F
97EB  00                  byte  $00
97EC  00                  byte  $00
97ED  04                  byte  $04
97EE  71                  byte  $71
97EF  00                  byte  $00
97F0  8F                  byte  $8F
97F1  00                  byte  $00
97F2  00                  byte  $00
97F3  01                  byte  $01
97F4  CD                  byte  $CD
97F5  04                  byte  $04
97F6  00                  byte  $00
97F7  08                  byte  $08

97F8  AE                  byte  $AE
97F9  00                  byte  $00
97FA  29                  byte  $29
97FB  00                  byte  $00
97FC  2E                  byte  $2E
97FD  00                  byte  $00
97FE  71                  byte  $71
97FF  01                  byte  $01
9800  5C                  byte  $5C
9801  03                  byte  $03
9802  A4                  byte  $A4
9803  00                  byte  $00
9804  00                  byte  $00
9805  6C                  byte  $6C
9806  5C                  byte  $5C
9807  01                  byte  $01
9808  00                  byte  $00
9809  08                  byte  $08
980A  00                  byte  $00
980B  46                  byte  $46
980C  40                  byte  $40

980D  FF                  byte  $FF
980E  00                  byte  $00
980F  00                  byte  $00
9810  00                  byte  $00
9811  00                  byte  $00
9812  00                  byte  $00
9813  00                  byte  $00
9814  00                  byte  $00
9815  00                  byte  $00
9816  00                  byte  $00
9817  00                  byte  $00
9818  00                  byte  $00
9819  00                  byte  $00
981A  00                  byte  $00
981B  FF                  byte  $FF
981C  FF                  byte  $FF
981D  00                  byte  $00
981E  FF                  byte  $FF
981F  00                  byte  $00
9820  FF                  byte  $FF
9821  00                  byte  $00
9822  FF                  byte  $FF
9823  00                  byte  $00
9824  FF                  byte  $FF
9825  00                  byte  $00
9826  FF                  byte  $FF
9827  00                  byte  $00
9828  FF                  byte  $FF
9829  FF                  byte  $FF

          ;Func: Sea Level Lugging O/L Fuel Multiplier
          ;X: RPM
          ;Scale: 4.000000 Offset: 0.000000 Math: 1
          ;Y: Lugging O/L Fuel Multiplier
          ;Scale: 128.000000 Offset: 0.000000 Math: 1
          ;org 0982Ah
          DW   0FFFFh,00080h
          DW   01770h,00080h
          DW   012C0h,0009Ah
          DW   00BB8h,0009Ah
          DW   00A28h,00080h
          DW   00000h,00080h
          DW   00000h,00080h

982A  FF                  byte  $FF
982B  FF                  byte  $FF
982C  80                  byte  $80
982D  00                  byte  $00
982E  70                  byte  $70
982F  17                  byte  $17
9830  80                  byte  $80
9831  00                  byte  $00
9832  C0                  byte  $C0
9833  12                  byte  $12
9834  9A                  byte  $9A
9835  00                  byte  $00
9836  B8                  byte  $B8
9837  0B                  byte  $0B
9838  9A                  byte  $9A
9839  00                  byte  $00
983A  28                  byte  $28
983B  0A                  byte  $0A
983C  80                  byte  $80
983D  00                  byte  $00
983E  00                  byte  $00
983F  00                  byte  $00
9840  80                  byte  $80
9841  00                  byte  $00
9842  00                  byte  $00
9843  00                  byte  $00
9844  80                  byte  $80
9845  00                  byte  $00

          ;Func: Altitude Lugging O/L Fuel Multiplier
          ;X: RPM
          ;Scale: 4.000000 Offset: 0.000000 Math: 1
          ;Y: Lugging O/L Fuel Multiplier
          ;Scale: 128.000000 Offset: 0.000000 Math: 1
          ;org 09846h
          DW   0FFFFh,00080h
          DW   00000h,00080h
          DW   00000h,00080h
          DW   00000h,00080h
          DW   00000h,00080h
          DW   00000h,00080h
          DW   00000h,00080h

9846  FF                  byte  $FF
9847  FF                  byte  $FF
9848  80                  byte  $80
9849  00                  byte  $00
984A  00                  byte  $00
984B  00                  byte  $00
984C  80                  byte  $80
984D  00                  byte  $00
984E  00                  byte  $00
984F  00                  byte  $00
9850  80                  byte  $80
9851  00                  byte  $00
9852  00                  byte  $00
9853  00                  byte  $00
9854  80                  byte  $80
9855  00                  byte  $00
9856  00                  byte  $00
9857  00                  byte  $00
9858  80                  byte  $80
9859  00                  byte  $00
985A  00                  byte  $00
985B  00                  byte  $00
985C  80                  byte  $80
985D  00                  byte  $00
985E  00                  byte  $00
985F  00                  byte  $00
9860  80                  byte  $80
9861  00                  byte  $00

9862  FF                  byte  $FF	; TABLE $9862 fuel_crank_pw_multiply_time
9863  FF                  byte  $FF
9864  00                  byte  $00
9865  40                  byte  $40
9866  00                  byte  $00
9867  00                  byte  $00
9868  00                  byte  $00
9869  40                  byte  $40
986A  00                  byte  $00
986B  00                  byte  $00
986C  00                  byte  $00
986D  40                  byte  $40
986E  00                  byte  $00
986F  00                  byte  $00
9870  00                  byte  $00
9871  40                  byte  $40
9872  00                  byte  $00
9873  00                  byte  $00
9874  00                  byte  $00
9875  40                  byte  $40
9876  00                  byte  $00
9877  00                  byte  $00
9878  00                  byte  $00
9879  40                  byte  $40

          ;Func: Cranking Fuel Pulsewidth vs ECT
          ;X: Engine Coolant Temperature
          ;Scale: 2.000000 Offset: 0.000000 Math: 0
          ;Y: Pulsewidth [ms]
          ;Scale: 2048.000000 Offset: 0.000000 Math: 1
          ;org 0987Ah
          DW   07FFFh,0020Ch
          DW   0005Ah,0020Ch
          DW   0004Bh,0025Bh
          DW   00023h,005D6h
          DW   00014h,00AC1h
          DW   0000Ah,00E7Dh
          DW   00000h,0166Ah
          DW   0FFF6h,027B1h
          DW   08000h,027B1h

987A  FF                  byte  $FF
987B  7F                  byte  $7F
987C  0C                  byte  $0C
987D  02                  byte  $02
987E  5A                  byte  $5A
987F  00                  byte  $00
9880  0C                  byte  $0C
9881  02                  byte  $02
9882  4B                  byte  $4B
9883  00                  byte  $00
9884  5B                  byte  $5B
9885  02                  byte  $02
9886  23                  byte  $23
9887  00                  byte  $00
9888  D6                  byte  $D6
9889  05                  byte  $05
988A  14                  byte  $14
988B  00                  byte  $00
988C  C1                  byte  $C1
988D  0A                  byte  $0A
988E  0A                  byte  $0A
988F  00                  byte  $00
9890  7D                  byte  $7D
9891  0E                  byte  $0E
9892  00                  byte  $00
9893  00                  byte  $00
9894  6A                  byte  $6A
9895  16                  byte  $16
9896  F6                  byte  $F6
9897  FF                  byte  $FF
9898  B1                  byte  $B1
9899  27                  byte  $27
989A  00                  byte  $00
989B  80                  byte  $80
989C  B1                  byte  $B1
989D  27                  byte  $27
989E  7F                  byte  $7F
989F  40                  byte  $40
98A0  80                  byte  $80
98A1  40                  byte  $40
98A2  80                  byte  $80
98A3  40                  byte  $40
98A4  80                  byte  $80
98A5  40                  byte  $40
98A6  80                  byte  $80
98A7  40                  byte  $40
98A8  80                  byte  $80
98A9  40                  byte  $40
98AA  80                  byte  $80
98AB  40                  byte  $40
98AC  80                  byte  $80
98AD  40                  byte  $40
98AE  80                  byte  $80
98AF  40                  byte  $40

98B0  FF                  byte  $FF
98B1  FF                  byte  $FF
98B2  C4                  byte  $C4
98B3  D5                  byte  $D5
98B4  A2                  byte  $A2
98B5  B9                  byte  $B9
98B6  00                  byte  $00
98B7  40                  byte  $40
98B8  00                  byte  $00
98B9  40                  byte  $40

FN074 = EGR Valve upstream pressure. Input: AM * KAMRF1 and Output = H2O
98ba	FN074	function	2	10	unsigned	11	2	unsigned	7	98E1

98BA  FF                  byte  $FF
98BB  FF                  byte  $FF
98BC  00                  byte  $00
98BD  59                  byte  $59
98BE  00                  byte  $00
98BF  80                  byte  $80
98C0  00                  byte  $00
98C1  59                  byte  $59
98C2  00                  byte  $00
98C3  58                  byte  $58
98C4  00                  byte  $00
98C5  2A                  byte  $2A
98C6  00                  byte  $00
98C7  38                  byte  $38
98C8  00                  byte  $00
98C9  11                  byte  $11
98CA  00                  byte  $00
98CB  28                  byte  $28
98CC  00                  byte  $00
98CD  0C                  byte  $0C

98CE  00                  byte  $00
98CF  20                  byte  $20
98D0  00                  byte  $00
98D1  09                  byte  $09
98D2  00                  byte  $00
98D3  0C                  byte  $0C
98D4  00                  byte  $00
98D5  00                  byte  $00
98D6  00                  byte  $00
98D7  00                  byte  $00
98D8  00                  byte  $00
98D9  00                  byte  $00
98DA  00                  byte  $00
98DB  00                  byte  $00
98DC  00                  byte  $00
98DD  00                  byte  $00
98DE  00                  byte  $00
98DF  00                  byte  $00
98E0  00                  byte  $00
98E1  00                  byte  $00
98E2  7F                  byte  $7F
98E3  20                  byte  $20
98E4  78                  byte  $78
98E5  20                  byte  $20
98E6  73                  byte  $73
98E7  7F                  byte  $7F
98E8  41                  byte  $41
98E9  7F                  byte  $7F
98EA  32                  byte  $32
98EB  00                  byte  $00
98EC  80                  byte  $80
98ED  00                  byte  $00

98EE  FF                  byte  $FF
98EF  80                  byte  $80
98F0  DE                  byte  $DE
98F1  80                  byte  $80
98F2  D4                  byte  $D4
98F3  00                  byte  $00
98F4  00                  byte  $00
98F5  00                  byte  $00
98F6  00                  byte  $00
98F7  00                  byte  $00
98F8  FF                  byte  $FF
98F9  00                  byte  $00
98FA  DE                  byte  $DE
98FB  00                  byte  $00
98FC  D4                  byte  $D4
98FD  80                  byte  $80
98FE  BC                  byte  $BC
98FF  80                  byte  $80
9900  B2                  byte  $B2
9901  0D                  byte  $0D
9902  00                  byte  $00
9903  0D                  byte  $0D
9904  FF                  byte  $FF
9905  FF                  byte  $FF
9906  8A                  byte  $8A
9907  00                  byte  $00
9908  FF                  byte  $FF
9909  00                  byte  $00
990A  8A                  byte  $8A
990B  00                  byte  $00
990C  A2                  byte  $A2
990D  00                  byte  $00
990E  5A                  byte  $5A
990F  00                  byte  $00
9910  71                  byte  $71
9911  00                  byte  $00
9912  42                  byte  $42
9913  00                  byte  $00
9914  32                  byte  $32
9915  00                  byte  $00
9916  20                  byte  $20
9917  00                  byte  $00
9918  00                  byte  $00
9919  00                  byte  $00
991A  00                  byte  $00
991B  00                  byte  $00
991C  7F                  byte  $7F
991D  80                  byte  $80
991E  1C                  byte  $1C
991F  80                  byte  $80
9920  00                  byte  $00
9921  66                  byte  $66
9922  80                  byte  $80
9923  66                  byte  $66
9924  80                  byte  $80
9925  66                  byte  $66
9926  FF                  byte  $FF
9927  FF                  byte  $FF
9928  FF                  byte  $FF
9929  00                  byte  $00
992A  8A                  byte  $8A
992B  00                  byte  $00
992C  FF                  byte  $FF
992D  00                  byte  $00
992E  80                  byte  $80
992F  00                  byte  $00
9930  EC                  byte  $EC
9931  00                  byte  $00
9932  5A                  byte  $5A
9933  00                  byte  $00
9934  A2                  byte  $A2
9935  00                  byte  $00
9936  42                  byte  $42
9937  00                  byte  $00
9938  71                  byte  $71
9939  00                  byte  $00
993A  20                  byte  $20
993B  00                  byte  $00
993C  32                  byte  $32
993D  00                  byte  $00
993E  00                  byte  $00
993F  00                  byte  $00
9940  00                  byte  $00
9941  00                  byte  $00

; Table 16 bit signed input and output - Change in EVR duty cycle as a function of the position error
9942  FF                  byte  $FF			7FFF 07AE	32767 - 
9943  7F                  byte  $7F
9944  AE                  byte  $AE
9945  07                  byte  $07

9946  80                  byte  $80			5980 07AE	22912 - 
9947  59                  byte  $59
9948  AE                  byte  $AE
9949  07                  byte  $07

994A  80                  byte  $80			A680 F852	-22912
994B  A6                  byte  $A6
994C  52                  byte  $52
994D  F8                  byte  $F8

994E  00                  byte  $00			8000 F852	-32768
994F  80                  byte  $80
9950  52                  byte  $52
9951  F8                  byte  $F8

9952  00                  byte  $00			8000 F852	-32768
9953  80                  byte  $80
9954  52                  byte  $52
9955  F8                  byte  $F8

9956  00                  byte  $00			8000 F852	-32768
9957  80                  byte  $80
9958  52                  byte  $52
9959  F8                  byte  $F8

995A  00                  byte  $00			8000 F852	-32768
995B  80                  byte  $80
995C  52                  byte  $52
995D  F8                  byte  $F8

; Table
995E  FF                  byte  $FF			FFFF 8000	8000
995F  FF                  byte  $FF
9960  00                  byte  $00
9961  80                  byte  $80

9962  00                  byte  $00			7F00 8000
9963  7F                  byte  $7F
9964  00                  byte  $00
9965  80                  byte  $80

9966  00                  byte  $00
9967  3C                  byte  $3C
9968  A4                  byte  $A4
9969  70                  byte  $70

996A  00                  byte  $00
996B  32                  byte  $32
996C  66                  byte  $66
996D  66                  byte  $66

996E  00                  byte  $00
996F  28                  byte  $28
9970  9A                  byte  $9A
9971  59                  byte  $59

9972  00                  byte  $00
9973  14                  byte  $14
9974  71                  byte  $71
9975  3D                  byte  $3D

9976  00                  byte  $00			0A00 28F6
9977  0A                  byte  $0A
9978  F6                  byte  $F6
9979  28                  byte  $28

997A  00                  byte  $00			0500 1C29
997B  05                  byte  $05
997C  29                  byte  $29
997D  1C                  byte  $1C

997E  00                  byte  $00			0200 0000
997F  02                  byte  $02
9980  00                  byte  $00
9981  00                  byte  $00

9982  00                  byte  $00			0000 0000
9983  00                  byte  $00
9984  00                  byte  $00
9985  00                  byte  $00

; Table
9986  FF                  byte  $FF
9987  FF                  byte  $FF
9988  00                  byte  $00
9989  7F                  byte  $7F
998A  00                  byte  $00
998B  80                  byte  $80
998C  00                  byte  $00
998D  7F                  byte  $7F
998E  A4                  byte  $A4
998F  70                  byte  $70
9990  00                  byte  $00
9991  3C                  byte  $3C
9992  66                  byte  $66
9993  66                  byte  $66
9994  00                  byte  $00
9995  32                  byte  $32
9996  9A                  byte  $9A
9997  59                  byte  $59
9998  00                  byte  $00
9999  28                  byte  $28
999A  71                  byte  $71
999B  3D                  byte  $3D
999C  00                  byte  $00
999D  14                  byte  $14
999E  F6                  byte  $F6
999F  28                  byte  $28
99A0  00                  byte  $00
99A1  0A                  byte  $0A
99A2  29                  byte  $29
99A3  1C                  byte  $1C
99A4  00                  byte  $00
99A5  05                  byte  $05
99A6  00                  byte  $00
99A7  00                  byte  $00
99A8  00                  byte  $00
99A9  02                  byte  $02
99AA  00                  byte  $00
99AB  00                  byte  $00
99AC  00                  byte  $00
99AD  00                  byte  $00

99AE  00                  byte  $00
99AF  00                  byte  $00
99B0  00                  byte  $00
99B1  00                  byte  $00
99B2  00                  byte  $00
99B3  00                  byte  $00
99B4  00                  byte  $00
99B5  00                  byte  $00
99B6  00                  byte  $00
99B7  00                  byte  $00
99B8  00                  byte  $00
99B9  00                  byte  $00
99BA  00                  byte  $00
99BB  00                  byte  $00
99BC  00                  byte  $00
99BD  00                  byte  $00
99BE  00                  byte  $00
99BF  00                  byte  $00
99C0  00                  byte  $00
99C1  00                  byte  $00
99C2  00                  byte  $00
99C3  00                  byte  $00
99C4  00                  byte  $00
99C5  00                  byte  $00
99C6  00                  byte  $00
99C7  00                  byte  $00
99C8  00                  byte  $00
99C9  00                  byte  $00
99CA  00                  byte  $00
99CB  00                  byte  $00
99CC  00                  byte  $00
99CD  00                  byte  $00
99CE  00                  byte  $00
99CF  10                  byte  $10
99D0  14                  byte  $14
99D1  20                  byte  $20
99D2  20                  byte  $20
99D3  18                  byte  $18
99D4  04                  byte  $04
99D5  00                  byte  $00
99D6  00                  byte  $00
99D7  00                  byte  $00
99D8  08                  byte  $08
99D9  20                  byte  $20
99DA  2C                  byte  $2C
99DB  2C                  byte  $2C
99DC  2C                  byte  $2C
99DD  22                  byte  $22
99DE  04                  byte  $04
99DF  00                  byte  $00
99E0  00                  byte  $00
99E1  00                  byte  $00
99E2  08                  byte  $08
99E3  20                  byte  $20
99E4  24                  byte  $24
99E5  26                  byte  $26
99E6  20                  byte  $20
99E7  17                  byte  $17
99E8  00                  byte  $00
99E9  00                  byte  $00
99EA  00                  byte  $00
99EB  00                  byte  $00
99EC  08                  byte  $08
99ED  0C                  byte  $0C
99EE  0C                  byte  $0C
99EF  0E                  byte  $0E
99F0  0F                  byte  $0F
99F1  0C                  byte  $0C
99F2  00                  byte  $00
99F3  00                  byte  $00
99F4  00                  byte  $00
99F5  00                  byte  $00
99F6  00                  byte  $00
99F7  00                  byte  $00
99F8  00                  byte  $00
99F9  00                  byte  $00
99FA  00                  byte  $00
99FB  00                  byte  $00
99FC  00                  byte  $00
99FD  00                  byte  $00
99FE  00                  byte  $00
99FF  00                  byte  $00
9A00  00                  byte  $00
9A01  00                  byte  $00
9A02  00                  byte  $00
9A03  00                  byte  $00
9A04  00                  byte  $00
9A05  00                  byte  $00
9A06  00                  byte  $00
9A07  00                  byte  $00
9A08  00                  byte  $00
9A09  00                  byte  $00
9A0A  00                  byte  $00
9A0B  00                  byte  $00
9A0C  00                  byte  $00
9A0D  00                  byte  $00
9A0E  00                  byte  $00
9A0F  00                  byte  $00
9A10  00                  byte  $00
9A11  00                  byte  $00
9A12  00                  byte  $00
9A13  00                  byte  $00
9A14  00                  byte  $00
9A15  08                  byte  $08
9A16  0A                  byte  $0A
9A17  10                  byte  $10
9A18  10                  byte  $10
9A19  00                  byte  $00
9A1A  00                  byte  $00
9A1B  00                  byte  $00
9A1C  00                  byte  $00
9A1D  00                  byte  $00
9A1E  00                  byte  $00
9A1F  14                  byte  $14
9A20  26                  byte  $26
9A21  28                  byte  $28
9A22  24                  byte  $24
9A23  20                  byte  $20
9A24  1A                  byte  $1A
9A25  10                  byte  $10
9A26  00                  byte  $00
9A27  00                  byte  $00
9A28  00                  byte  $00
9A29  1C                  byte  $1C
9A2A  24                  byte  $24
9A2B  22                  byte  $22
9A2C  20                  byte  $20
9A2D  14                  byte  $14
9A2E  13                  byte  $13
9A2F  08                  byte  $08
9A30  00                  byte  $00
9A31  00                  byte  $00
9A32  00                  byte  $00
9A33  10                  byte  $10
9A34  10                  byte  $10
9A35  10                  byte  $10
9A36  0F                  byte  $0F
9A37  0A                  byte  $0A
9A38  0A                  byte  $0A
9A39  00                  byte  $00
9A3A  00                  byte  $00
9A3B  00                  byte  $00
9A3C  00                  byte  $00
9A3D  00                  byte  $00
9A3E  00                  byte  $00
9A3F  00                  byte  $00
9A40  00                  byte  $00
9A41  00                  byte  $00
9A42  00                  byte  $00
9A43  00                  byte  $00
9A44  00                  byte  $00
9A45  00                  byte  $00
9A46  00                  byte  $00
9A47  00                  byte  $00
9A48  00                  byte  $00
9A49  00                  byte  $00
9A4A  00                  byte  $00
9A4B  00                  byte  $00
9A4C  00                  byte  $00
9A4D  00                  byte  $00
9A4E  80                  byte  $80
9A4F  80                  byte  $80
9A50  80                  byte  $80
9A51  80                  byte  $80
9A52  2A                  byte  $2A
9A53  31                  byte  $31
9A54  24                  byte  $24
9A55  1D                  byte  $1D
9A56  00                  byte  $00
9A57  0E                  byte  $0E
9A58  16                  byte  $16
9A59  00                  byte  $00

9a5a	FN600	function	1	6	unsigned	0	2	unsigned	7	9A65
FN600 = Canister Purge Duty Cycle Multiplier Y-output = Duty Cycle Multiplier
9A5A  FF                  byte  $FF
9A5B  80                  byte  $80
9A5C  00                  byte  $00
9A5D  80                  byte  $80
9A5E  00                  byte  $00
9A5F  80                  byte  $80
9A60  00                  byte  $00
9A61  80                  byte  $80
9A62  00                  byte  $00
9A63  80                  byte  $80
9A64  00                  byte  $00
9A65  80                  byte  $80

9A66  FF                  byte  $FF
9A67  80                  byte  $80
9A68  08                  byte  $08
9A69  80                  byte  $80
9A6A  00                  byte  $00
9A6B  00                  byte  $00
9A6C  00                  byte  $00
9A6D  00                  byte  $00
9A6E  00                  byte  $00
9A6F  00                  byte  $00
9A70  00                  byte  $00
9A71  00                  byte  $00

9A72  FF                  byte  $FF
9A73  80                  byte  $80
9A74  50                  byte  $50
9A75  80                  byte  $80
9A76  28                  byte  $28
9A77  33                  byte  $33
9A78  14                  byte  $14
9A79  2D                  byte  $2D
9A7A  0C                  byte  $0C
9A7B  00                  byte  $00
9A7C  00                  byte  $00
9A7D  00                  byte  $00
;
;*************************************************** REG_FC points here
;
9A7E  5A9E                word  $9E5A

9A80  00                  byte  $00
9A81  FF                  byte  $FF

          ;Half fuel on
9A82  00                  byte  $00
9A83  7D                  byte  $7D
          ;Half fuel off
9A84  30                  byte  $30
9A85  75                  byte  $75
                    ;* Speed Limiter A On
9A86  FF                  byte  $FF			$8[REG_FC]
                    ;*
                    ;* Speed Limiter A Off
9A87  FF                  byte  $FF
                    ;*
                    ;* Speed Limiter B On
9A88  FF                  byte  $FF
                    ;*
                    ;* Speed Limiter B Off
9A89  FF                  byte  $FF
                    ;*
9A8A  00                  byte  $00
9A8B  28                  byte  $28
9A8C  3C                  byte  $3C		; ECT limit LO
9A8D  64                  byte  $64		; ECT limit Hi
9A8E  00                  byte  $00
9A8F  00                  byte  $00
9A90  03                  byte  $03
9A91  FF                  byte  $FF
9A92  C0                  byte  $C0		; word open_loop_tp_Voltage (throttle position to force open loop (TPS voltage - 1))
9A93  8A                  byte  $8A
9A94  60                  byte  $60
9A95  6D                  byte  $6D		; ROM $9A95 rev_limit
9A96  90                  byte  $90
9A97  01                  byte  $01
9A98  01                  byte  $01
9A99  FF                  byte  $FF
9A9A  A4                  byte  $A4		; ROM $9A9A open_loop_minimum_load
9A9B  00                  byte  $00
9A9C  A4                  byte  $A4		; ROM $9A9C min_load_for_closed_loop 
9A9D  00                  byte  $00
9A9E  AE                  byte  $AE
9A9F  07                  byte  $07
9AA0  10                  byte  $10		; ROM $9AA0 open_loop_time_at_high_load - time_at_high_load_before_open_loop (time at high load to force Open loop(seconds))
9AA1  FF                  byte  $FF

9AA2  66                  byte  $66		; LAMMAX $A666 = 1.3000
9AA3  A6                  byte  $A6

9AA4  00                  byte  $00		; LAMMIN $6000 = 0.7500
9AA5  60                  byte  $60

9AA6  8F                  byte  $8F
9AA7  02                  byte  $02
9AA8  00                  byte  $00
9AA9  01                  byte  $01
9AAA  68                  byte  $68
9AAB  01                  byte  $01
9AAC  00                  byte  $00
9AAD  01                  byte  $01
9AAE  01                  byte  $01
9AAF  01                  byte  $01

9AB0  08                  byte  $08	; number of cylinders

9AB1  01                  byte  $01
9AB2  00                  byte  $00
9AB3  00                  byte  $00
9AB4  00                  byte  $00
9AB5  FF                  byte  $FF
9AB6  48                  byte  $48
9AB7  0D                  byte  $0D
9AB8  20                  byte  $20
9AB9  03                  byte  $03
9ABA  58                  byte  $58
9ABB  58                  byte  $58
9ABC  00                  byte  $00
9ABD  4B                  byte  $4B
9ABE  BD                  byte  $BD
9ABF  00                  byte  $00
9AC0  00                  byte  $00
9AC1  BD                  byte  $BD
9AC2  80                  byte  $80 ; AISFM = Multiplier on AISF when in DFSO. Determines Fuel Puddle size upon re-entering normal fuel
9AC3  46                  byte  $46	; ROM $9AC3 min_ect_decel_fuel_shutoff (140.0DegF)
9AC4  48                  byte  $48
9AC5  01                  byte  $01
9AC6  EC                  byte  $EC
9AC7  01                  byte  $01
9AC8  58                  byte  $58	; ROM $9AC8 min_rpm_decel_fuel_shutoff
9AC9  02                  byte  $02
9ACA  58                  byte  $58
9ACB  02                  byte  $02
9ACC  10                  byte  $10
9ACD  00                  byte  $00

9ACE  F8                  byte  $F8
9ACF  F8                  byte  $F8
9AD0  06                  byte  $06
9AD1  04                  byte  $04
9AD2  C0                  byte  $C0
9AD3  00                  byte  $00
9AD4  28                  byte  $28
9AD5  0A                  byte  $0A
9AD6  58                  byte  $58
9AD7  02                  byte  $02
9AD8  73                  byte  $73
9AD9  00                  byte  $00
9ADA  0A                  byte  $0A
9ADB  04                  byte  $04
9ADC  00                  byte  $00
9ADD  00                  byte  $00
9ADE  00                  byte  $00
9ADF  00                  byte  $00
9AE0  00                  byte  $00
9AE1  00                  byte  $00

9AE2  55                  byte  $55	ECT limit
9AE3  71                  byte  $71	ECT limit

9AE4  32                  byte  $32	; ROM $9AE4 min_act_for_adaptive_control
9AE5  64                  byte  $64	; ROM $9AE5 max_act_for_adaptive_control (200.oDegF)
9AE6  3C                  byte  $3C
9AE7  00                  byte  $00
9AE8  7B                  byte  $7B
9AE9  04                  byte  $04
9AEA  40                  byte  $40
9AEB  00                  byte  $00
9AEC  40                  byte  $40
9AED  00                  byte  $00
9AEE  61                  byte  $61	; adaptive_control_minimum
9AEF  9F                  byte  $9F	; adaptive_control_maximum
9AF0  00                  byte  $00
9AF1  00                  byte  $00
9AF2  00                  byte  $00
9AF3  00                  byte  $00
9AF4  C5                  byte  $C5
9AF5  00                  byte  $00
9AF6  00                  byte  $00
9AF7  00                  byte  $00
9AF8  06                  byte  $06
9AF9  2E                  byte  $2E
9AFA  00                  byte  $00
9AFB  FF                  byte  $FF
9AFC  FF                  byte  $FF
9AFD  FF                  byte  $FF
9AFE  00                  byte  $00
9AFF  05                  byte  $05
9B00  1E                  byte  $1E
9B01  00                  byte  $00
9B02  00                  byte  $00
9B03  05                  byte  $05
9B04  0A                  byte  $0A
9B05  00                  byte  $00
9B06  00                  byte  $00
9B07  03                  byte  $03
9B08  05                  byte  $05
9B09  00                  byte  $00
9B0A  00                  byte  $00
9B0B  02                  byte  $02
9B0C  00                  byte  $00
9B0D  00                  byte  $00
9B0E  00                  byte  $00
9B0F  00                  byte  $00
9B10  FF                  byte  $FF	; emission_table_rpm_scaling
9B11  FF                  byte  $FF
9B12  00                  byte  $00
9B13  03                  byte  $03
9B14  E0                  byte  $E0
9B15  2E                  byte  $2E
9B16  00                  byte  $00
9B17  03                  byte  $03
9B18  10                  byte  $10
9B19  0E                  byte  $0E
9B1A  00                  byte  $00
9B1B  01                  byte  $01
9B1C  F0                  byte  $F0
9B1D  0A                  byte  $0A
9B1E  00                  byte  $00
9B1F  00                  byte  $00
9B20  00                  byte  $00
9B21  00                  byte  $00
9B22  00                  byte  $00
9B23  00                  byte  $00
9B24  00                  byte  $00
9B25  00                  byte  $00
9B26  00                  byte  $00
9B27  00                  byte  $00
9B28  00                  byte  $00
9B29  00                  byte  $00
9B2A  00                  byte  $00
9B2B  00                  byte  $00
9B2C  00                  byte  $00
9B2D  00                  byte  $00
9B2E  00                  byte  $00
9B2F  00                  byte  $00

          ;Func: Injector Offset vs Battery Voltage
          ;X: Battery Voltage
          ;Scale: 16.000000 Offset: 0.000000 Math: 1
          ;Y: InjectorOffset
          ;Scale: 32.000000 Offset: 0.000000 Math: 1
          ;org 09B30h
          DB   0FFh,01Dh
          DB   0E0h,01Dh
          DB   0D0h,020h
          DB   0C0h,025h
          DB   0B0h,02Dh
          DB   0A0h,036h
          DB   090h,041h
          DB   080h,053h
          DB   070h,071h
          DB   060h,0B1h
          DB   058h,0F0h
          DB   000h,0F0h

9B30  FF                  byte  $FF
9B31  1D                  byte  $1D
9B32  E0                  byte  $E0
9B33  1D                  byte  $1D
9B34  D0                  byte  $D0
9B35  20                  byte  $20
9B36  C0                  byte  $C0
9B37  25                  byte  $25
9B38  B0                  byte  $B0
9B39  2D                  byte  $2D
9B3A  A0                  byte  $A0
9B3B  36                  byte  $36
9B3C  90                  byte  $90
9B3D  41                  byte  $41
9B3E  80                  byte  $80
9B3F  53                  byte  $53
9B40  70                  byte  $70
9B41  71                  byte  $71
9B42  60                  byte  $60
9B43  B1                  byte  $B1
9B44  58                  byte  $58
9B45  F0                  byte  $F0
9B46  00                  byte  $00
9B47  F0                  byte  $F0

          ;Func: Open Loop Fuel Multiplier vs ACT
          ;X: Intake Air ChargeTemp
          ;Scale: 2.000000 Offset: 0.000000 Math: 0
          ;Y: Open Loop Fuel Multiplier
          ;Scale: 64.000000 Offset: 0.000000 Math: 1
          ;org 09B48h
          DB   07Fh,040h
          DB   026h,040h
          DB   000h,034h
          DB   0ECh,029h
          DB   080h,029h
          DB   080h,029h

9B48  7F                  byte  $7F
9B49  40                  byte  $40
9B4A  26                  byte  $26
9B4B  40                  byte  $40
9B4C  00                  byte  $00
9B4D  34                  byte  $34
9B4E  EC                  byte  $EC
9B4F  29                  byte  $29
9B50  80                  byte  $80
9B51  29                  byte  $29
9B52  80                  byte  $80
9B53  29                  byte  $29

9B54  FF                  byte  $FF	; TABLE $9B54 fuel_closed_throttle_open_loop_multiply
9B55  FF                  byte  $FF
9B56  80                  byte  $80
9B57  00                  byte  $00
9B58  00                  byte  $00
9B59  00                  byte  $00
9B5A  80                  byte  $80
9B5B  00                  byte  $00
9B5C  00                  byte  $00
9B5D  00                  byte  $00
9B5E  80                  byte  $80
9B5F  00                  byte  $00
9B60  00                  byte  $00
9B61  00                  byte  $00
9B62  80                  byte  $80
9B63  00                  byte  $00
9B64  00                  byte  $00
9B65  00                  byte  $00
9B66  80                  byte  $80
9B67  00                  byte  $00
9B68  00                  byte  $00
9B69  00                  byte  $00
9B6A  80                  byte  $80
9B6B  00                  byte  $00

9b6c	FN301N	function	2	5	unsigned	2	2	unsigned	7	9B7F
FN301N = Neutral Open Loop Fuel Multiplier as a function of engine speed N

9B6C  FF                  byte  $FF	; referenced at 460E & 467B
9B6D  FF                  byte  $FF
9B6E  80                  byte  $80
9B6F  00                  byte  $00
9B70  00                  byte  $00
9B71  00                  byte  $00
9B72  80                  byte  $80
9B73  00                  byte  $00
9B74  00                  byte  $00
9B75  00                  byte  $00
9B76  80                  byte  $80
9B77  00                  byte  $00
9B78  00                  byte  $00
9B79  00                  byte  $00
9B7A  80                  byte  $80
9B7B  00                  byte  $00
9B7C  00                  byte  $00
9B7D  00                  byte  $00
9B7E  80                  byte  $80
9B7F  00                  byte  $00

          ;Func: WOT Fuel Multiplier vs RPM
          ;X: RPM
          ;Scale: 4.000000 Offset: 0.000000 Math: 1
          ;Y: WOT Fuel Multiplier
          ;Scale: 128.000000 Offset: 0.000000 Math: 1
          ;org 09B80h
          DW   0FFFFh,00079h
          DW   05DC0h,00079h
          DW   044C0h,0007Ah
          DW   03B60h,0007Dh
          DW   03200h,00079h
          DW   02580h,0007Ch
          DW   01900h,00074h
          DW   00000h,00080h

9B80  FF                  byte  $FF
9B81  FF                  byte  $FF
9B82  79                  byte  $79
9B83  00                  byte  $00
9B84  C0                  byte  $C0
9B85  5D                  byte  $5D
9B86  79                  byte  $79
9B87  00                  byte  $00
9B88  C0                  byte  $C0
9B89  44                  byte  $44
9B8A  7A                  byte  $7A
9B8B  00                  byte  $00
9B8C  60                  byte  $60
9B8D  3B                  byte  $3B
9B8E  7D                  byte  $7D
9B8F  00                  byte  $00
9B90  00                  byte  $00
9B91  32                  byte  $32
9B92  79                  byte  $79
9B93  00                  byte  $00
9B94  80                  byte  $80
9B95  25                  byte  $25
9B96  7C                  byte  $7C
9B97  00                  byte  $00
9B98  00                  byte  $00
9B99  19                  byte  $19
9B9A  74                  byte  $74
9B9B  00                  byte  $00
9B9C  00                  byte  $00
9B9D  00                  byte  $00
9B9E  80                  byte  $80
9B9F  00                  byte  $00

          ;Map: M7BA0 FN1035(N,LOAD) = Air Meter Backflow Correction Table
               X-input = FN070 - Normalized engine speed, RPM
               Y-input = FN021 - Normalized LOAD
               Output = LOAD.
         ;10 Cols
          ;8 Rows
          ;org 09BA0h
          DB   080h,080h,080h,080h,080h,080h,080h,080h,080h,080h
          DB   080h,080h,080h,080h,080h,080h,080h,080h,080h,080h
          DB   080h,080h,080h,080h,080h,080h,080h,080h,080h,080h
          DB   080h,083h,080h,080h,080h,080h,080h,080h,080h,080h
          DB   080h,083h,083h,080h,080h,080h,080h,080h,080h,080h
          DB   084h,084h,084h,080h,080h,080h,080h,080h,080h,080h
          DB   07Fh,07Fh,07Eh,079h,079h,079h,079h,079h,079h,079h
          DB   07Bh,07Bh,07Bh,075h,075h,075h,075h,075h,075h,075h

9BA0  80                  byte  $80
9BA1  80                  byte  $80
9BA2  80                  byte  $80
9BA3  80                  byte  $80
9BA4  80                  byte  $80
9BA5  80                  byte  $80
9BA6  80                  byte  $80
9BA7  80                  byte  $80
9BA8  80                  byte  $80
9BA9  80                  byte  $80
9BAA  80                  byte  $80
9BAB  80                  byte  $80
9BAC  80                  byte  $80
9BAD  80                  byte  $80
9BAE  80                  byte  $80
9BAF  80                  byte  $80
9BB0  80                  byte  $80
9BB1  80                  byte  $80
9BB2  80                  byte  $80
9BB3  80                  byte  $80
9BB4  80                  byte  $80
9BB5  80                  byte  $80
9BB6  80                  byte  $80
9BB7  80                  byte  $80
9BB8  80                  byte  $80
9BB9  80                  byte  $80
9BBA  80                  byte  $80
9BBB  80                  byte  $80
9BBC  80                  byte  $80
9BBD  80                  byte  $80
9BBE  80                  byte  $80
9BBF  83                  byte  $83
9BC0  80                  byte  $80
9BC1  80                  byte  $80
9BC2  80                  byte  $80
9BC3  80                  byte  $80
9BC4  80                  byte  $80
9BC5  80                  byte  $80
9BC6  80                  byte  $80
9BC7  80                  byte  $80
9BC8  80                  byte  $80
9BC9  83                  byte  $83
9BCA  83                  byte  $83
9BCB  80                  byte  $80
9BCC  80                  byte  $80
9BCD  80                  byte  $80
9BCE  80                  byte  $80
9BCF  80                  byte  $80
9BD0  80                  byte  $80
9BD1  80                  byte  $80
9BD2  84                  byte  $84
9BD3  84                  byte  $84
9BD4  84                  byte  $84
9BD5  80                  byte  $80
9BD6  80                  byte  $80
9BD7  80                  byte  $80
9BD8  80                  byte  $80
9BD9  80                  byte  $80
9BDA  80                  byte  $80
9BDB  80                  byte  $80
9BDC  86                  byte  $86
9BDD  86                  byte  $86
9BDE  85                  byte  $85
9BDF  80                  byte  $80
9BE0  80                  byte  $80
9BE1  80                  byte  $80
9BE2  80                  byte  $80
9BE3  80                  byte  $80
9BE4  80                  byte  $80
9BE5  80                  byte  $80
9BE6  86                  byte  $86
9BE7  86                  byte  $86
9BE8  86                  byte  $86
9BE9  80                  byte  $80
9BEA  80                  byte  $80
9BEB  80                  byte  $80
9BEC  80                  byte  $80
9BED  80                  byte  $80
9BEE  80                  byte  $80
9BEF  80                  byte  $80

          ;Map: Base Fuel [A/F Ratio]
          ;Scale: 8.000000 Offset: 0.000000 Math: 1
          ;10 Cols: ECT [DegF]
          ;-30|0|30|60|90|120|150|180|210|240
          ;8 Rows: Load []
          ;.05|.15|.30|.40|.55|.70|.80|.90
          ;org 09BF0h
          DB   08Fh,08Fh,08Dh,08Ah,085h,083h,080h,07Ah,07Ah,07Ah
          DB   08Dh,08Dh,088h,085h,084h,083h,080h,07Ah,07Ah,07Ah
          DB   071h,072h,072h,073h,074h,076h,076h,07Ah,07Ah,073h
          DB   06Dh,073h,073h,073h,077h,07Ah,07Ah,080h,080h,076h
          DB   066h,06Fh,072h,073h,077h,077h,07Ah,080h,080h,078h
          DB   061h,061h,06Ch,06Ch,06Fh,073h,071h,072h,06Dh,06Dh
          DB   05Ah,05Ah,066h,066h,069h,06Ch,06Eh,06Eh,06Dh,06Ch
          DB   054h,054h,064h,064h,066h,069h,06Ch,06Ch,06Ch,06Ch

9BF0  8F                  byte  $8F
9BF1  8F                  byte  $8F
9BF2  8D                  byte  $8D
9BF3  8A                  byte  $8A
9BF4  85                  byte  $85
9BF5  83                  byte  $83
9BF6  80                  byte  $80
9BF7  7A                  byte  $7A
9BF8  7A                  byte  $7A
9BF9  7A                  byte  $7A
9BFA  8D                  byte  $8D
9BFB  8D                  byte  $8D
9BFC  88                  byte  $88
9BFD  85                  byte  $85
9BFE  84                  byte  $84
9BFF  83                  byte  $83
9C00  80                  byte  $80
9C01  7A                  byte  $7A
9C02  7A                  byte  $7A
9C03  7A                  byte  $7A
9C04  71                  byte  $71
9C05  72                  byte  $72
9C06  72                  byte  $72
9C07  73                  byte  $73
9C08  74                  byte  $74
9C09  76                  byte  $76
9C0A  76                  byte  $76
9C0B  7A                  byte  $7A
9C0C  7A                  byte  $7A
9C0D  73                  byte  $73
9C0E  6D                  byte  $6D
9C0F  73                  byte  $73
9C10  73                  byte  $73
9C11  73                  byte  $73
9C12  77                  byte  $77
9C13  7A                  byte  $7A
9C14  7A                  byte  $7A
9C15  80                  byte  $80
9C16  80                  byte  $80
9C17  76                  byte  $76
9C18  66                  byte  $66
9C19  6F                  byte  $6F
9C1A  72                  byte  $72
9C1B  73                  byte  $73
9C1C  77                  byte  $77
9C1D  77                  byte  $77
9C1E  7A                  byte  $7A
9C1F  80                  byte  $80
9C20  80                  byte  $80
9C21  78                  byte  $78
9C22  61                  byte  $61
9C23  61                  byte  $61
9C24  6C                  byte  $6C
9C25  6C                  byte  $6C
9C26  6F                  byte  $6F
9C27  73                  byte  $73
9C28  71                  byte  $71
9C29  72                  byte  $72
9C2A  6D                  byte  $6D
9C2B  6D                  byte  $6D
9C2C  5A                  byte  $5A
9C2D  5A                  byte  $5A
9C2E  66                  byte  $66
9C2F  66                  byte  $66
9C30  69                  byte  $69
9C31  6C                  byte  $6C
9C32  6E                  byte  $6E
9C33  6E                  byte  $6E
9C34  6D                  byte  $6D
9C35  6C                  byte  $6C

9C36  54                  byte  $54	; fuel_base_table (correct address??)
9C37  54                  byte  $54
9C38  64                  byte  $64
9C39  64                  byte  $64
9C3A  66                  byte  $66
9C3B  69                  byte  $69
9C3C  6C                  byte  $6C
9C3D  6C                  byte  $6C
9C3E  6C                  byte  $6C
9C3F  6C                  byte  $6C

FN1306 = Startup Open Loop Fuel table
          ;Map: Startup Fuel [A/F Ratio]
          ;Scale: 8.000000 Offset: 0.000000 Math: 1
          ;10 Cols: ECT [DegF]
          ;-30|0|30|60|90|120|150|180|210|240
          ;8 Rows: Time [Sec]
          ;0|3|5|10|15|25|35|45
          ;org 09C40h
          DB   01Bh,021h,018h,00Fh,00Fh,00Fh,00Fh,00Bh,00Fh,01Bh
          DB   017h,01Dh,015h,00Fh,00Fh,00Fh,00Fh,00Dh,00Fh,017h
          DB   016h,016h,013h,00Fh,00Fh,00Fh,00Fh,00Ch,00Fh,016h
          DB   012h,011h,011h,00Fh,00Fh,00Fh,00Fh,00Ah,00Fh,012h
          DB   00Dh,00Dh,00Ch,00Bh,00Ah,00Bh,00Bh,009h,00Bh,00Dh
          DB   00Ah,00Ch,009h,008h,008h,00Ah,00Ah,007h,008h,00Ah
          DB   008h,00Ah,007h,004h,003h,007h,007h,002h,004h,008h
          DB   000h,000h,000h,000h,000h,000h,000h,000h,000h,000h


9C40  1B                  byte  $1B
9C41  21                  byte  $21
9C42  18                  byte  $18
9C43  0F                  byte  $0F
9C44  0F                  byte  $0F
9C45  0F                  byte  $0F
9C46  0F                  byte  $0F
9C47  0B                  byte  $0B
9C48  0F                  byte  $0F
9C49  1B                  byte  $1B
9C4A  17                  byte  $17
9C4B  1D                  byte  $1D
9C4C  15                  byte  $15
9C4D  0F                  byte  $0F
9C4E  0F                  byte  $0F
9C4F  0F                  byte  $0F
9C50  0F                  byte  $0F
9C51  0D                  byte  $0D
9C52  0F                  byte  $0F
9C53  17                  byte  $17
9C54  16                  byte  $16
9C55  16                  byte  $16
9C56  13                  byte  $13
9C57  0F                  byte  $0F
9C58  0F                  byte  $0F
9C59  0F                  byte  $0F
9C5A  0F                  byte  $0F
9C5B  0C                  byte  $0C
9C5C  0F                  byte  $0F
9C5D  16                  byte  $16
9C5E  12                  byte  $12
9C5F  11                  byte  $11
9C60  11                  byte  $11
9C61  0F                  byte  $0F
9C62  0F                  byte  $0F
9C63  0F                  byte  $0F
9C64  0F                  byte  $0F
9C65  0A                  byte  $0A
9C66  0F                  byte  $0F
9C67  12                  byte  $12
9C68  0D                  byte  $0D
9C69  0D                  byte  $0D
9C6A  0C                  byte  $0C
9C6B  0B                  byte  $0B
9C6C  0A                  byte  $0A
9C6D  0B                  byte  $0B
9C6E  0B                  byte  $0B
9C6F  09                  byte  $09
9C70  0B                  byte  $0B
9C71  0D                  byte  $0D
9C72  0A                  byte  $0A
9C73  0C                  byte  $0C
9C74  09                  byte  $09
9C75  08                  byte  $08
9C76  08                  byte  $08
9C77  0A                  byte  $0A
9C78  0A                  byte  $0A
9C79  07                  byte  $07
9C7A  08                  byte  $08
9C7B  0A                  byte  $0A
9C7C  08                  byte  $08
9C7D  0A                  byte  $0A
9C7E  07                  byte  $07
9C7F  04                  byte  $04
9C80  03                  byte  $03
9C81  07                  byte  $07
9C82  07                  byte  $07
9C83  02                  byte  $02
9C84  04                  byte  $04
9C85  08                  byte  $08
9C86  00                  byte  $00
9C87  00                  byte  $00
9C88  00                  byte  $00
9C89  00                  byte  $00
9C8A  00                  byte  $00
9C8B  00                  byte  $00
9C8C  00                  byte  $00
9C8D  00                  byte  $00
9C8E  00                  byte  $00
9C8F  00                  byte  $00

9C90  FF                  byte  $FF	; TABLE $9C90 fuel_table_time_scaling
9C91  FF                  byte  $FF
9C92  1F                  byte  $1F
9C93  65                  byte  $65
9C94  20                  byte  $20
9C95  4E                  byte  $4E
9C96  1F                  byte  $1F
9C97  65                  byte  $65
9C98  B0                  byte  $B0
9C99  36                  byte  $36
9C9A  71                  byte  $71
9C9B  6D                  byte  $6D
9C9C  40                  byte  $40
9C9D  1F                  byte  $1F
9C9E  CD                  byte  $CD
9C9F  5C                  byte  $5C
9CA0  18                  byte  $18
9CA1  15                  byte  $15
9CA2  85                  byte  $85
9CA3  5B                  byte  $5B
9CA4  A0                  byte  $A0
9CA5  0F                  byte  $0F
9CA6  66                  byte  $66
9CA7  56                  byte  $56
9CA8  00                  byte  $00
9CA9  00                  byte  $00
9CAA  33                  byte  $33
9CAB  53                  byte  $53


9CAC  FF                  byte  $FF
9CAD  7F                  byte  $7F
9CAE  9A                  byte  $9A
9CAF  59                  byte  $59

9CB0  69                  byte  $69
9CB1  00                  byte  $00
9CB2  9A                  byte  $9A
9CB3  59                  byte  $59

9CB4  64                  byte  $64
9CB5  00                  byte  $00
9CB6  D7                  byte  $D7
9CB7  63                  byte  $63

9CB8  00                  byte  $00
9CB9  80                  byte  $80
9CBA  D7                  byte  $D7
9CBB  63                  byte  $63

9CBC  00                  byte  $00
9CBD  80                  byte  $80
9CBE  D7                  byte  $D7
9CBF  63                  byte  $63

9CC0  00                  byte  $00
9CC1  80                  byte  $80
9CC2  D7                  byte  $D7
9CC3  63                  byte  $63

9CC4  00                  byte  $00
9CC5  80                  byte  $80
9CC6  D7                  byte  $D7
9CC7  63                  byte  $63


9CC8  FF                  byte  $FF
9CC9  7F                  byte  $7F
9CCA  00                  byte  $00
9CCB  01                  byte  $01
9CCC  00                  byte  $00
9CCD  80                  byte  $80
9CCE  00                  byte  $00
9CCF  01                  byte  $01
9CD0  00                  byte  $00
9CD1  80                  byte  $80

9CD2  00                  byte  $00	; fuel_table_ect_scaling
9CD3  01                  byte  $01
9CD4  00                  byte  $00
9CD5  80                  byte  $80
9CD6  00                  byte  $00
9CD7  01                  byte  $01
9CD8  00                  byte  $00
9CD9  80                  byte  $80
9CDA  00                  byte  $00
9CDB  01                  byte  $01
9CDC  00                  byte  $00
9CDD  80                  byte  $80
9CDE  00                  byte  $00
9CDF  01                  byte  $01
9CE0  00                  byte  $00
9CE1  80                  byte  $80
9CE2  00                  byte  $00
9CE3  01                  byte  $01
9CE4  00                  byte  $00
9CE5  80                  byte  $80
9CE6  00                  byte  $00
9CE7  01                  byte  $01
9CE8  87                  byte  $87
9CE9  87                  byte  $87
9CEA  80                  byte  $80
9CEB  79                  byte  $79
9CEC  70                  byte  $70
9CED  5A                  byte  $5A
9CEE  2E                  byte  $2E
9CEF  02                  byte  $02
9CF0  02                  byte  $02
9CF1  02                  byte  $02
9CF2  93                  byte  $93
9CF3  93                  byte  $93
9CF4  8C                  byte  $8C
9CF5  84                  byte  $84
9CF6  7A                  byte  $7A
9CF7  63                  byte  $63
9CF8  34                  byte  $34
9CF9  04                  byte  $04
9CFA  04                  byte  $04
9CFB  04                  byte  $04
9CFC  A3                  byte  $A3
9CFD  A3                  byte  $A3
9CFE  9A                  byte  $9A
9CFF  91                  byte  $91
9D00  86                  byte  $86
9D01  6D                  byte  $6D
9D02  3A                  byte  $3A
9D03  05                  byte  $05
9D04  04                  byte  $04
9D05  04                  byte  $04
9D06  B3                  byte  $B3
9D07  B3                  byte  $B3
9D08  A9                  byte  $A9
9D09  9E                  byte  $9E
9D0A  92                  byte  $92
9D0B  78                  byte  $78
9D0C  43                  byte  $43
9D0D  08                  byte  $08
9D0E  07                  byte  $07
9D0F  06                  byte  $06
9D10  C3                  byte  $C3
9D11  C3                  byte  $C3
9D12  B9                  byte  $B9
9D13  AD                  byte  $AD
9D14  A0                  byte  $A0
9D15  85                  byte  $85
9D16  4E                  byte  $4E
9D17  0C                  byte  $0C
9D18  09                  byte  $09
9D19  08                  byte  $08
9D1A  D5                  byte  $D5
9D1B  D5                  byte  $D5
9D1C  C9                  byte  $C9
9D1D  BD                  byte  $BD
9D1E  AF                  byte  $AF
9D1F  94                  byte  $94
9D20  5D                  byte  $5D
9D21  12                  byte  $12
9D22  0D                  byte  $0D
9D23  09                  byte  $09
9D24  E7                  byte  $E7
9D25  E7                  byte  $E7
9D26  DC                  byte  $DC
9D27  CF                  byte  $CF
9D28  C0                  byte  $C0
9D29  A7                  byte  $A7
9D2A  75                  byte  $75
9D2B  1B                  byte  $1B
9D2C  13                  byte  $13
9D2D  0B                  byte  $0B
9D2E  FF                  byte  $FF
9D2F  FF                  byte  $FF
9D30  F2                  byte  $F2
9D31  E3                  byte  $E3
9D32  D2                  byte  $D2
9D33  BF                  byte  $BF
9D34  98                  byte  $98
9D35  29                  byte  $29
9D36  1D                  byte  $1D
9D37  10                  byte  $10

          ;Map: M7D38
          ;10 Cols
          ;8 Rows
          ;org 09D38h
          DB   018h,018h,018h,018h,018h,018h,020h,030h,030h,030h
          DB   018h,018h,018h,018h,018h,018h,020h,030h,030h,030h
          DB   018h,018h,018h,018h,018h,018h,020h,030h,030h,030h
          DB   018h,018h,018h,018h,018h,018h,020h,030h,030h,030h
          DB   018h,018h,018h,018h,018h,018h,020h,030h,030h,030h
          DB   018h,018h,018h,018h,018h,018h,020h,030h,030h,030h
          DB   018h,018h,018h,018h,018h,018h,020h,030h,030h,030h
          DB   018h,018h,018h,018h,018h,018h,020h,030h,030h,030h

9D38  18                  byte  $18
9D39  18                  byte  $18
9D3A  18                  byte  $18
9D3B  18                  byte  $18
9D3C  18                  byte  $18
9D3D  18                  byte  $18
9D3E  20                  byte  $20
9D3F  30                  byte  $30
9D40  30                  byte  $30
9D41  30                  byte  $30
9D42  18                  byte  $18
9D43  18                  byte  $18
9D44  18                  byte  $18
9D45  18                  byte  $18
9D46  18                  byte  $18
9D47  18                  byte  $18
9D48  20                  byte  $20
9D49  30                  byte  $30
9D4A  30                  byte  $30
9D4B  30                  byte  $30
9D4C  18                  byte  $18
9D4D  18                  byte  $18
9D4E  18                  byte  $18
9D4F  18                  byte  $18
9D50  18                  byte  $18
9D51  18                  byte  $18
9D52  20                  byte  $20
9D53  30                  byte  $30
9D54  30                  byte  $30
9D55  30                  byte  $30
9D56  18                  byte  $18
9D57  18                  byte  $18
9D58  18                  byte  $18
9D59  18                  byte  $18
9D5A  18                  byte  $18
9D5B  18                  byte  $18
9D5C  20                  byte  $20
9D5D  30                  byte  $30
9D5E  30                  byte  $30
9D5F  30                  byte  $30
9D60  18                  byte  $18
9D61  18                  byte  $18
9D62  18                  byte  $18
9D63  18                  byte  $18
9D64  18                  byte  $18
9D65  18                  byte  $18
9D66  20                  byte  $20
9D67  30                  byte  $30
9D68  30                  byte  $30
9D69  30                  byte  $30
9D6A  18                  byte  $18
9D6B  18                  byte  $18
9D6C  18                  byte  $18
9D6D  18                  byte  $18
9D6E  18                  byte  $18
9D6F  18                  byte  $18
9D70  20                  byte  $20
9D71  30                  byte  $30
9D72  30                  byte  $30
9D73  30                  byte  $30
9D74  18                  byte  $18
9D75  18                  byte  $18
9D76  18                  byte  $18
9D77  18                  byte  $18
9D78  18                  byte  $18
9D79  18                  byte  $18
9D7A  20                  byte  $20
9D7B  30                  byte  $30
9D7C  30                  byte  $30
9D7D  30                  byte  $30
9D7E  18                  byte  $18
9D7F  18                  byte  $18
9D80  18                  byte  $18
9D81  18                  byte  $18
9D82  18                  byte  $18
9D83  18                  byte  $18
9D84  20                  byte  $20
9D85  30                  byte  $30
9D86  30                  byte  $30
9D87  30                  byte  $30
     EXHAUST_PULSE_DLY_BP2:
9D88  28                  byte  $28
9D89  28                  byte  $28
9D8A  28                  byte  $28
9D8B  28                  byte  $28
9D8C  28                  byte  $28
9D8D  28                  byte  $28
9D8E  28                  byte  $28
9D8F  28                  byte  $28
9D90  28                  byte  $28
9D91  28                  byte  $28
9D92  28                  byte  $28
9D93  28                  byte  $28
9D94  28                  byte  $28
9D95  28                  byte  $28
9D96  28                  byte  $28
9D97  28                  byte  $28
9D98  28                  byte  $28
9D99  28                  byte  $28
9D9A  28                  byte  $28
9D9B  28                  byte  $28
9D9C  28                  byte  $28
9D9D  28                  byte  $28
9D9E  28                  byte  $28
9D9F  28                  byte  $28
9DA0  28                  byte  $28
9DA1  28                  byte  $28
9DA2  28                  byte  $28
9DA3  28                  byte  $28
9DA4  28                  byte  $28
9DA5  28                  byte  $28
9DA6  28                  byte  $28
9DA7  28                  byte  $28
     HEGO_AMPLITUDE_BP9:
9DA8  11                  byte  $11
9DA9  11                  byte  $11
9DAA  11                  byte  $11
9DAB  11                  byte  $11
9DAC  11                  byte  $11
9DAD  11                  byte  $11
9DAE  11                  byte  $11
9DAF  11                  byte  $11
9DB0  11                  byte  $11
9DB1  11                  byte  $11
9DB2  11                  byte  $11
9DB3  11                  byte  $11
9DB4  11                  byte  $11
9DB5  11                  byte  $11
9DB6  11                  byte  $11
9DB7  11                  byte  $11
9DB8  11                  byte  $11
9DB9  11                  byte  $11
9DBA  11                  byte  $11
9DBB  11                  byte  $11
9DBC  11                  byte  $11
9DBD  11                  byte  $11
9DBE  11                  byte  $11
9DBF  11                  byte  $11
9DC0  11                  byte  $11
9DC1  11                  byte  $11
9DC2  11                  byte  $11
9DC3  11                  byte  $11
9DC4  11                  byte  $11
9DC5  11                  byte  $11
9DC6  11                  byte  $11
9DC7  11                  byte  $11
     HEGO_BIAS_BP11:
9DC8  00                  byte  $00
9DC9  0E                  byte  $0E
9DCA  0E                  byte  $0E
9DCB  0E                  byte  $0E
9DCC  00                  byte  $00
9DCD  04                  byte  $04
9DCE  04                  byte  $04
9DCF  04                  byte  $04
9DD0  00                  byte  $00
9DD1  00                  byte  $00
9DD2  00                  byte  $00
9DD3  00                  byte  $00
9DD4  00                  byte  $00
9DD5  FC                  byte  $FC
9DD6  FC                  byte  $FC
9DD7  FC                  byte  $FC
9DD8  00                  byte  $00
9DD9  FC                  byte  $FC
9DDA  FC                  byte  $FC
9DDB  FC                  byte  $FC
9DDC  FC                  byte  $FC
9DDD  F8                  byte  $F8
9DDE  F8                  byte  $F8
9DDF  F8                  byte  $F8
9DE0  FC                  byte  $FC
9DE1  F4                  byte  $F4
9DE2  F4                  byte  $F4
9DE3  F4                  byte  $F4
9DE4  F0                  byte  $F0
9DE5  F0                  byte  $F0
9DE6  F0                  byte  $F0
9DE7  F0                  byte  $F0

          ;Func: Open Loop Fuel Multiplier vs RPM
          ;X: RPM
          ;Scale: 4.000000 Offset: 0.000000 Math: 1
          ;Y: Open Loop Fuel Multiplier
          ;Scale: 128.000000 Offset: 0.000000 Math: 1
          ;org 09DE8h
          DW   0FFFFh,00000h
          DW   01130h,00000h
          DW   010CCh,00080h
          DW   00000h,00080h
          DW   00000h,00080h
          DW   00000h,00080h


9DE8  FF                  byte  $FF
9DE9  FF                  byte  $FF
9DEA  00                  byte  $00
9DEB  00                  byte  $00
9DEC  30                  byte  $30
9DED  11                  byte  $11
9DEE  00                  byte  $00
9DEF  00                  byte  $00
9DF0  CC                  byte  $CC
9DF1  10                  byte  $10
9DF2  80                  byte  $80
9DF3  00                  byte  $00
9DF4  00                  byte  $00
9DF5  00                  byte  $00
9DF6  80                  byte  $80
9DF7  00                  byte  $00
9DF8  00                  byte  $00
9DF9  00                  byte  $00
9DFA  80                  byte  $80
9DFB  00                  byte  $00
9DFC  00                  byte  $00
9DFD  00                  byte  $00
9DFE  80                  byte  $80
9DFF  00                  byte  $00
9E00  AE                  byte  $AE
9E01  AE                  byte  $AE
9E02  AE                  byte  $AE
9E03  AE                  byte  $AE
9E04  AE                  byte  $AE
9E05  AE                  byte  $AE
9E06  AE                  byte  $AE
9E07  AE                  byte  $AE
9E08  AE                  byte  $AE
9E09  AE                  byte  $AE
9E0A  AE                  byte  $AE
9E0B  AE                  byte  $AE
9E0C  AE                  byte  $AE
9E0D  AE                  byte  $AE
9E0E  AE                  byte  $AE
9E0F  AE                  byte  $AE
9E10  AE                  byte  $AE
9E11  AE                  byte  $AE
9E12  AE                  byte  $AE
9E13  AE                  byte  $AE
9E14  64                  byte  $64
9E15  64                  byte  $64
9E16  0A                  byte  $0A
9E17  0A                  byte  $0A
9E18  0A                  byte  $0A
9E19  0A                  byte  $0A
9E1A  0A                  byte  $0A
9E1B  0A                  byte  $0A
9E1C  0A                  byte  $0A
9E1D  0A                  byte  $0A
9E1E  64                  byte  $64
9E1F  64                  byte  $64
9E20  0A                  byte  $0A
9E21  0A                  byte  $0A
9E22  0A                  byte  $0A
9E23  0A                  byte  $0A
9E24  0A                  byte  $0A
9E25  0A                  byte  $0A
9E26  0A                  byte  $0A
9E27  0A                  byte  $0A
9E28  D5                  byte  $D5
9E29  D5                  byte  $D5
9E2A  D5                  byte  $D5
9E2B  0A                  byte  $0A
9E2C  0A                  byte  $0A
9E2D  0A                  byte  $0A
9E2E  0A                  byte  $0A
9E2F  0A                  byte  $0A
9E30  0A                  byte  $0A
9E31  0A                  byte  $0A
9E32  CB                  byte  $CB
9E33  CB                  byte  $CB
9E34  CB                  byte  $CB
9E35  0A                  byte  $0A
9E36  0A                  byte  $0A
9E37  0A                  byte  $0A
9E38  0A                  byte  $0A
9E39  0A                  byte  $0A
9E3A  0A                  byte  $0A
9E3B  0A                  byte  $0A
9E3C  C1                  byte  $C1
9E3D  C1                  byte  $C1
9E3E  C1                  byte  $C1
9E3F  0A                  byte  $0A
9E40  0A                  byte  $0A
9E41  0A                  byte  $0A
9E42  0A                  byte  $0A
9E43  0A                  byte  $0A
9E44  C7                  byte  $C7
9E45  C7                  byte  $C7
9E46  C7                  byte  $C7
9E47  C7                  byte  $C7
9E48  C7                  byte  $C7
9E49  C7                  byte  $C7
9E4A  C7                  byte  $C7
9E4B  C7                  byte  $C7
9E4C  C7                  byte  $C7
9E4D  C7                  byte  $C7
9E4E  C7                  byte  $C7
9E4F  C7                  byte  $C7
9E50  C7                  byte  $C7
9E51  C7                  byte  $C7
9E52  0A                  byte  $0A
9E53  0A                  byte  $0A
9E54  A7                  byte  $A7
9E55  A7                  byte  $A7
9E56  A7                  byte  $A7
9E57  A7                  byte  $A7
9E58  A7                  byte  $A7
9E59  64                  byte  $64
;
;*************************************************** REG_FE points here
;
9E5A  A29E                word  $9EA2

9E5C  03                  byte  $03
9E5D  00                  byte  $00
9E5E  55                  byte  $55
9E5F  1C                  byte  $1C
9E60  44                  byte  $44
9E61  08                  byte  $08
9E62  20                  byte  $20
9E63  03                  byte  $03
9E64  01                  byte  $01
9E65  01                  byte  $01	; THRMHP - Thermactor Hardware Present
9E66  00                  byte  $00	; HP_CID - HP_CID Hardware Present Cylinder Identification 
9E67  00                  byte  $00	; HP_CIDSEL - Hardware Present ??
9E68  33                  byte  $33
9E69  33                  byte  $33
9E6A  00                  byte  $00
9E6B  7D                  byte  $7D
9E6C  90                  byte  $90
9E6D  01                  byte  $01
9E6E  02                  byte  $02
9E6F  02                  byte  $02
9E70  02                  byte  $02	; ROM $9E70 number_of_HEGOs

9E71  FF                  byte  $FF
9E72  2C                  byte  $2C
9E73  B3                  byte  $B3
9E74  00                  byte  $00
9E75  02                  byte  $02
9E76  00                  byte  $00
9E77  00                  byte  $00
9E78  3F                  byte  $3F
9E79  06                  byte  $06
9E7A  13                  byte  $13
9E7B  9A                  byte  $9A
9E7C  66                  byte  $66
9E7D  FF                  byte  $FF
9E7E  40                  byte  $40
9E7F  00                  byte  $00
9E80  CD                  byte  $CD
9E81  08                  byte  $08
9E82  00                  byte  $00
9E83  60                  byte  $60
9E84  66                  byte  $66
9E85  A6                  byte  $A6
9E86  33                  byte  $33
9E87  73                  byte  $73
9E88  A0                  byte  $A0
9E89  40                  byte  $40
9E8A  80                  byte  $80
9E8B  FF                  byte  $FF
9E8C  C8                  byte  $C8
9E8D  00                  byte  $00
9E8E  E8                  byte  $E8
9E8F  03                  byte  $03
9E90  50                  byte  $50
9E91  FF                  byte  $FF
9E92  E8                  byte  $E8
9E93  03                  byte  $03
9E94  7D                  byte  $7D
9E95  00                  byte  $00
9E96  9A                  byte  $9A
9E97  09                  byte  $09
9E98  66                  byte  $66
9E99  F6                  byte  $F6
9E9A  93                  byte  $93
9E9B  00                  byte  $00
9E9C  BD                  byte  $BD
9E9D  00                  byte  $00
9E9E  05                  byte  $05
9E9F  00                  byte  $00
9EA0  80                  byte  $80
                    ;*
9EA1
9EA2 ; end of calibration data + 1

9EA1                      ds    $1D9F   ; bytes ignored by 'ignore' command
BC40                      end
